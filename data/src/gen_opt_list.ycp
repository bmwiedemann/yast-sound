{
    include "./include/gen_routines.ycp";

    import "String";

    define any translate_descr (string descr) {

	list<string> matches = [
	    "(.*for) (.*) (soundcard.)",
            "(.*for) (.*) (driver.)",
            "(.*for) (.*) (interface.)",
            "(.*for) (.*) (MIDI.)",
            "(.*for) (.*) (bridge.)"
	];

	list<list> guess = maplist(string e, matches,
	    ``(regexptokenize(descr, e))
	);

	guess = filter (list e, guess, ``(size(e)==3));

	if (size(guess) >= 1)
	{
	    list l = guess[0]:[];
	    y2milestone ("translating %1...", descr);
	    string s = sformat("%1 %%1 %2", l[0]:"", l[2]:"");
	    any a	= s;
	    locale loc	= (locale) a;
	    return [loc, l[1]:""];
	}
	any a = descr;
	return (locale) a;
	// FIXME changing "text" into _("text") cannot work this way any more!
    }

    // collect param descriptions of all snd-card-* modules

    map<integer,string> mod_idx	=
	(map<integer,string>) SCR::Read (.target.ycp, "./src/module_index.ycp");

    map<string,map> mixer	=
	(map<string,map>) SCR::Read (.target.ycp, "./addons/mixer.ycp");

    map<string,map> joy_mods	=
	(map<string,map>) SCR::Read (.target.ycp, "./addons/joy_mods.ycp");


    // SCR::Dir(.modinfo.misc);
    list<string> mods	= maplist (integer k, string v, mod_idx, ``(v));

//    mods = filter(`e, mods, ``(regexpmatch(e, "^snd-card-.*")));
    map modopts = $[];
    map subopt = $[];


    foreach (string e, mods, {
	subopt	= (map) SCR::Read(add(.modinfo, e));
	modopts = add (modopts, e, subopt);
    });

    string mod_name		= "";
    string mod_descr		= "";
    map mod_params		= $[];
    map<string,map> database	= $[];
    map mod_data		= $[];

    foreach (string e, mods, {
	mod_name	= e;
	mod_descr	= modopts[mod_name, "module_description"]:"";
	mod_params	= $[];

	mod_data = $["description" : mod_descr,
                     "params" : mod_params
                     ];

	maplist (string k, map v, (map<string,map>) mixer[mod_name]:$[], ``{
	    mod_data[k]=v;
	});

	database = add(database, mod_name, mod_data);
    });

    map out	= (map) SCR::Execute (.target.bash_output, "uname -r", $[]);
    string kernel_ver = out["stdout"]:"";
    kernel_ver = String::FirstChunk(kernel_ver, "\n");

//    string generic_string = (string) SCR::Read(.target.string, "/lib/modules/"+kernel_ver+"/modules.generic_string");
    string generic_string = (string) SCR::Read(.target.string, "./alsa-module-syntax");
    if (generic_string == nil)
	generic_string	= "";


    list<string> gs	= splitstring(generic_string, "\n");

//    string pattern = "(snd-[^ \t]*)[\t ]*info_parm_(snd_[^=]*)=enable:\\(snd_enable\\)(.*)";
//    string pattern = "(snd-[^ \t]*)[\t ]*info_parm_([^=]*)=enable:\\(enable\\)(.*)";

    /*
	pattern for current alsa-module-syntax (big #45646)
	example:

snd-sb8 index   enable:(enable),allows:{{0,7}},unique,skill:required,dialog:list
snd-sb8 id      enable:(enable),unique
snd-sb8 enable  allows:{{0,Disabled},{1,Enabled}},default:0,dialog:check
snd-sb8 port    enable:(enable),allows:{{0,0x3fff}},base:16
snd-sb8 irq     enable:(enable),allows:{{5},{7},{9},{10,12},{14,15}},dialog:list
snd-sb8 dma8    enable:(enable),allows:{{0,1},{3}},dialog:list
    */
    string pattern = "(snd-[^ \t]*)[\t ]*([^ \t]*)[\t ]*enable:\\(enable\\)(.*)";

    list ltmp = [];
    list lx = [];

    map tmpmap = $[];
    string modname = "";
    string parmname = "";
    string descr = "";


    maplist (string e, gs, {

	lx = regexptokenize(e, pattern);
	parmname = lx[1]:"";

	if (size(lx) > 0 && !contains(["index", "enable", "id"], parmname))
	{
	    tmpmap	= parse_line (lx[2]:"");
	    modname	= lx[0]:"";
	    if (!contains(mods, modname))
	    {
		return;
	    }
	    descr = modopts[modname, parmname]:" ";

	    // these two declaration must be here
	    any anydescr = translate_descr(descr);

	    if (is(anydescr, list) && size((list)anydescr) > 1)
	    {
		list lanydescr	= (list) anydescr;
		if (lanydescr[1]:"" == "specified")
		{
		    lanydescr[1] = database[modname, "description"]:"";
		    anydescr	= lanydescr;
		}
	    }
//	    locale locdescr = anydescr;

//	    y2error("%1 %2 %3", modname, parmname, tmpmap);

	    map oldmap	= database[modname]:$[];
	    map oldopts = oldmap["params"]:$[];

	    tmpmap = add (tmpmap, "descr", anydescr); //locdescr);

	    oldopts = add(oldopts, parmname, tmpmap);
	    oldmap = add(oldmap, "params", oldopts);

//	    if (haskey(joy_mods, modname))
//	    {
//		oldmap = add(oldmap, "joystick", joy_mods[modname]:$[]);
//	    }
	    database[modname]	= oldmap;
	}
    });

    // now merge stuff from ../addons/mod_addons.ycp

    map<string,map> addm	=
	(map<string,map>) SCR::Read (.target.ycp, "./addons/mod_addons.ycp");

    foreach (string k, map v, addm, {

	map added	= eval (v);
	// FIXME this is hack for one current addon module... FIXME
	string descr = added["params", "snd_enable_beep", "descr"]:" ";

	if (descr != " ")
	{
	    added["params", "snd_enable_beep", "descr"]	=
		translate_descr(descr);
	}

	database = add (database, k, added);
    });

    // now add joystick data

    map outdb = $[];

    foreach (string k, map v, database, {
	if (haskey(joy_mods, k))
	{
	    v["joystick"]	= joy_mods[k]:$[];
	}
	outdb [k]		= v;
    });

    SCR::Write(.target.ycp, "./modlist.ycp", outdb);
}
