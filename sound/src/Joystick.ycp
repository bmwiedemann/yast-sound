/**
 * File:
 *   modules/Joystick.ycp
 *
 * Package:
 *   Configuration of joystick
 *
 * Summary:
 *   Data for configuration of joystick, input and output functions.
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of joystick.
 * Input and output routines.
 *
 */

{
    // Set the name of the module
    module "Joystick";
    import "Progress";

    textdomain "sound";

    /**
     * joystick config datastructure (list of maps)
     */
    global list joystick = [];

    list vars = [   "GAMEPORT_MODULE",
                    "JOYSTICK_MODULE",
                    "JOYSTICK_MODULE_OPTION",
                    "JOYSTICK_CONTROL",
                    "JOYSTICK_CONTROL_PORT"];

    list joystick_backup = [];

    // comment for JOYSTICK_MODULE section in sysconfig
    string module_comment = "";

    /**
     * Read all joystick settings from the SCR
     * @param abort A block that can be called by Read to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @return True on success
     */
    global define boolean Read (block abort) ``{
	integer pos = 0;

	joystick = [];

	string tmp = "";

	while (pos < 4)
	{
	    map j = $[];

	    // go thru 'vars' list and read all variable values
	    foreach(`v, vars, ``{
		tmp = SCR::Read(topath(sformat(".sysconfig.joystick.%1_%2", v, pos)));
		j = add(j, v, tmp);
	    });

	    // read model comment
	    string model = SCR::Read(topath(sformat(".sysconfig.joystick.JOYSTICK_MODULE_%1.comment", pos)));

	    y2debug("Read comment: %1", model);

	    // remove trailing newline character
	    if (size(model) > 0 && substring(model, size(model) - 1, 1) == "\n")
	    {
		model = substring(model, 0, size(model) - 1);
	    }


	    // if comment has more lines get last line as model name
	    list lines = splitstring(model, "\n");

	    // select last line from comment
	    if (size(lines) > 1)
	    {
		model = select(lines, size(lines) - 1, "");

		// store global comment for joystick modules - it is before first module
		if (pos == 0)
		{
		    lines = remove(lines, size(lines) - 1);
		    module_comment = mergestring(lines, "\n");

		    y2debug("global comment: %1", module_comment);
		}
	    }


	    // set model
	    if (SCR::Read(topath(sformat(".sysconfig.joystick.JOYSTICK_MODULE_%1", pos))) == "" || model == nil)
	    {
		model = "";
	    }
	    else
	    {

		// remove comment char
		if (substring(model, 0, 1) == "#")
		{
                    if (size(model) > 1)
		    {
			model = substring(model, 1);
		    }
		    else
		    {
			model = "";
		    }
		}

		// remove new line char
		if (size(model) > 1 && substring(model, size(model) - 1, 1) == "\n")
		{
		    model = substring(model, 0, size(model) - 1);
		}
	    }

	    j = add(j, "model", model);

	    joystick = add(joystick, j);

	    pos = pos + 1;
	}

	joystick_backup = joystick;
    }

    global define boolean Changed() ``{
	if (joystick != joystick_backup)
	{
	    return true;
	}
	return false;
    }

    /**
     * Update the SCR according to joystick settings
     * @param abort A block that can be called by Write to find
     *	      out whether abort is requested. Returns true if abort
     *	      was pressed.
     * @return True on success
     */
    global define boolean Write (block abort) ``{
	integer pos = 0;

	map j = $[];
	string start = "disable";

	while (pos < 4)
	{
	    // first remove old settings
	    maplist(`e, vars, ``(SCR::Write(topath(sformat(".sysconfig.joystick.%1_%2", e, pos)), "")));

	    // delete old model
	    SCR::Write(topath(sformat(".sysconfig.joystick.JOYSTICK_MODULE_%1.comment", pos)), "");

	    j = select(joystick, pos, $[]);

	    foreach(`v, vars, ``{
		SCR::Write(topath(sformat(".sysconfig.joystick.%1_%2", v, pos)), lookup(j, v, ""));

		if (lookup(j, v, "") != "")
                {
		    // if there is variable with value != "" enable joystick service
		    start = "enable";
                }

	    });


	    // write model comment
	    string model = lookup(j, "model", nil);

	    // add comment before first model
	    if (pos == 0)
	    {
		if (size(model) > 0)
		{
		    model = module_comment + "\n#" + model + "\n";
		}
		else
		{
		    model = module_comment + "\n#\n";
		}
	    }
	    else
	    {
		if (size(model) > 0)
		{
		    model = "#" + model + "\n";
		}
	    }

	    y2milestone("Model: %1", model);

	    if (size(model) > 0)
	    {
		SCR::Write(topath(sformat(".sysconfig.joystick.JOYSTICK_MODULE_%1.comment", pos)), model);
	    }


	    pos = pos + 1;
	}

	// flush config to file
	SCR::Write(.sysconfig.joystick, nil);

	// restart joystick service
	SCR::Execute(.target.bash, "/etc/init.d/joystick restart", $[]);

	// enable/disable service
        Runlevel::ServiceAdjust("joystick", start);

	return true;
    }

    /**
     * Get all joystick settings from the first parameter
     * (For use by autoinstallation.)
     * @param settings The YCP structure to be imported.
     * @return True on success
     */
    global define boolean Import (map settings) ``{
	joystick = settings;
	return true;
    }

    /**
     * Dump the joystick settings to a single map
     * (For use by autoinstallation.)
     * @return Dumped settings (later acceptable by Import ())
     */
    global define map Export () ``{
	return joystick;
    }

    /**
     * Build a textual summary that can be used e.g. in inst_hw_config () or
     * something similar.
     * @return Summary of the configuration.
     */
    global define string Summary () ``{
	// TODO FIXME: your code here...
	return _("Summary of the joystick configuration...");
    }

}
