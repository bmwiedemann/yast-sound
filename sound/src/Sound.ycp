/**
 * File:
 *   modules/Sound.ycp
 *
 * Package:
 *   Configuration of sound
 *
 * Summary:
 *   Input and output functions.
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of sound.
 * Input and output routines.
 *
 */

{
    // Set the name of the module
    module "Sound";
    import "Runlevel";
    import "Summary";
    import "Mode";
    import "Arch";

    include "sound/read_routines.ycp";
    include "sound/routines.ycp";

    /**
     * what sound system we're using (true=alsa, false=oss)
     */

    global boolean use_alsa = true;


    /**
     * flag for letting the module know, that it's launched from then hardware
     * installation screen
     */
    global boolean installation = false;

    /**
     * was the proposal already generated?
     */
    global boolean proposal_created = false;

    /**
     * autoinstallation mode?
     */
    global boolean autoinstallation = false;

    /**
     * list for storing detected cards
     */
    global list detected_cards = nil;

    /**
     * list of detected and unconfigured cards
     */
    global list unconfigured_cards = nil;

    /**
     * settings to save to /etc/modules.conf (only those concerning to sound)
     */
    global list modules_conf = [];

    /**
     * settings to save using .audio.alsa ... mixer
     */
    global list volume_settings = [];

    /**
     * rc settings
     */
    global map rc_vars = $[];

    /**
     * alsa sound card database
     */

    /**
     * card list
     */
    global map db_cards = nil;
    /**
     * module details
     */
    global map db_modules = nil;
    /**
     *
     */
    global map db_indices = nil;
    /**
     *
     */
    global map db_module_index = nil;

    /**
     * flag for showing/not showing ui stuff (eg when loading alsa database)
     */
    global boolean use_ui = false;

    /**
     * ctor
     */

    global define void Sound() ``{
	if (Arch::sparc)
	{
	    use_alsa = false;
	}

	maplist(`e, Args(), ``{
	    if (is(e, path) && (e == .oss))
	    {
		use_alsa = false;
	    }
	});

	if (use_alsa)
	{
	    include "sound/alsa_routines.ycp";
	}
	else
	{
	    include "sound/oss_routines.ycp";
	}

    }

    /**
     * do hardware detection
     * @return boolean success/failure
     */

    global define boolean DetectHardware() ``{
	if (Mode::test)
	{
	    autoinstallation = true;
	    detected_cards = [$[
		    "bus"	: "PCI",
		    "class_id"	: 4,
		    "device"	: "SB Live! EMU10000",
		    "device_id"	:65538,
		    "drivers"	:
		    [
			$[
			    "active"	: false,
			    "modprobe"	: true,
			    "modules"	:
			    [
				[
				    "emu10k1",
				    ""
				]
			    ]
			]
		    ],
		    "old_unique_key" : "LaV9.FfCiMJnnUxC",
		    "resource"	:
		    $[
			"io":
			[
			    $[
				"active"    : true,
				"length"    : 0,
				"mode"	    : "rw",
				"start"	    : 49152
			    ]
			],
			"irq":
			[
			    $[
				"count"	    : 41833,
				"enabled"   : true,
				"irq":10
			    ]
			]
		    ],
		    "rev"	    : "7",
		    "slot_id"	    : 5,
		    "sub_class_id"  : 1,
		    "sub_device"    : "CT4832 SBLive! Value",
		    "sub_device_id" : 98343,
		    "sub_vendor"    : "Creative Labs",
		    "sub_vendor_id" : 69890,
		    "unique_key"    : "CvwD.FfCiMJnnUxC",
		    "vendor"	    : "Creative Labs",
		    "vendor_id"	    : 69890
		]];
	    return true;
	}

	if (autoinstallation)
	{
	    detected_cards = [];
	}

	// do noop if cards were already detected
	if (detected_cards != nil)
	{
	    return true;
	}
	detected_cards  = SCR::Read(.probe.sound);
	return true;
    }


    /**
     * searches for sound alias in /etc/modules.conf
     * @return void
     */

    global define void ReadModulesConf() ``{
	modules_conf = read_save_info();
    }

    /**
     * update list of unconfigured cards (necessaty when deleting configured card)
     * @return void
     */

    global define void UpdateUnconfiguredCards() ``{
//	if (autoinstallation)
//	{
//	    return;
//	}
	unconfigured_cards = getConfigurableCards(modules_conf);
    }

    /**
     * Read all sound settings from the SCR
     * @param _unused unused parameter
     * @return boolean True on success
     */
    global define boolean Read(block _unused) ``{
	// first detect sound cards
	DetectHardware();

	if (Mode::test)
	{
	    modules_conf = [];
	    rc_vars = $[];
	    UpdateUnconfiguredCards();
	    return true;
	}
	// load data from /etc/modules.conf
	ReadModulesConf();
	// create list of unconfigured cards
	UpdateUnconfiguredCards();
	// read rc.config values
	rc_vars = read_rc_vars ();
	// load volume settings
	volume_settings = get_vol_settings();
	UpdateUnconfiguredCards();
	return true;
    }

    /**
     * Get all sound settings from the first parameter
     * (For autoinstallation use.)
     * @param settings settings to import
     * @return boolean True on success
     */
    global define boolean Import(map settings) ``{
	// initialize these unneeded values
	detected_cards = [];
	unconfigured_cards = [];

	// import values
	if (lookup(settings, "modules_conf", nil) == nil)
	{
	    y2error("Import error: 'modules_conf' key is missing");
	    return false;
	}
	Set(settings);

	return true;
    }
    
    /**
     * Just Set module data
     * @param settings Sound configuration settings
     * @return: void
     */
    global define void Set(map settings)  ``{
	modules_conf = lookup(settings, "modules_conf", []);
	rc_vars = lookup(settings, "rc_vars", $[]);
	volume_settings = lookup(settings, "volume_settings", []);	
    }

    /**
     * Update the SCR according to sound settings
     * @param _unused unused parameter
     * @param _unused2 unused parameter
     * @return boolean True on success
     */
    global define boolean Write(block _unused, block _unused2) ``{
	// TODO: check return value

	if (Mode::test == false)
	{
	    map settings = Export();
	    settings = add (settings, "autoinstall", false);
	    CallFunction (`sound_write(settings));
	}

	return true;
    }

    /**
     * Dump the sound settings to a single map. self explaining
     * (For use by autoinstallation.)
     * @return map Dumped settings (later acceptable by Import())
     */
    global define map Export() ``{
	return $[
		"modules_conf"	    : modules_conf,
		"rc_vars"	    : rc_vars,
		"volume_settings"   : volume_settings,
		"autoinstall"	    : true
	    ];
    }

    /**
     * opens alsa sound cards database
     * @return void
     */

    global define void LoadDatabase() ``{
	map sound_db =$[];
	if (db_cards == nil || db_cards == $[])
	{
            string message = _("Loading the sound card database...");
	    UI::`OpenDialog(`opt(`decorated), `Label(message));
	    textdomain "sound_db";
	    y2debug("Reading card database");
	    sound_db = eval(SCR::Read (.target.yast2, "sndcards.ycp"));

	    db_cards	= lookup(sound_db, "cards", $[]);
	    db_modules	= lookup(sound_db, "modules", $[]);
	    db_indices	= lookup(sound_db, "indices", $[]);
	    db_module_index = lookup(sound_db, "mod_idx", $[]);

	    textdomain "sound";
	    UI::CloseDialog();
	}
    }

    /**
     * just writes all variables to log. don't use in Master.
     */

    global define void DumpToLog() ``{
	y2error(sformat("%1", [Sound::modules_conf, rc_vars, true, true, get_vol_settings()]));
    }

    /**
     * returns html formated configuration summary
     * @return string Summary string
     */

    global define string Summary() ``{
	list retlist    = [];       // return value of the module

	list keys = maplist(`e, Sound::modules_conf, ``(lookup(e, "unique_key", "...")));

	retlist = maplist(`card, Sound::modules_conf,
	``(
	    // to translators: '(sound card is) Configured as snd-card-1'
	    Summary::Device(lookup(card, "model", "Sound card"), sformat(_("Configured as %1."), 
		lookup(card, "alias", "snd-card-0")))
	));

	foreach(`card, Sound::detected_cards,
	``{
	    if (!contains(keys, lookup(card, "unique_key", "...")))
	    {
		retlist = add(retlist, Summary::Device(get_card_label(card), Summary::NotConfigured()));
	    }
	});

	return Summary::DevicesList(retlist);

    }

    /**
     * this function converts options for modules from 'modules_conf' data structure
     * to another- this is needed for writing options to modules conf.
     * eg. we have these configured cards:
     * [
     *           $["model":"sblive", "module":"snd-emu10k1", "options":$["opt1": "a", "opt2": "b"]],
     *           $["model":"sblive", "module":"snd-emu10k1", "options":$["opt2": "c"]],
     *           $["model":"other", "module":"mod2", "options":$["opt1": "a", "opt2": "b"]]
     * ]
     * CollectOptions("snd-emu10k1") returns $["opt1":"a,b", "opt2":",c"]
     * @param modname module name
     * @return map Map with collected options
     *
     */

    global define map CollectOptions(string modname) ``{
	// first filter out entries with other module
	list mod_entries = filter(`e, modules_conf, ``(lookup(e, "module", "off") == modname));

	// create list of options (list of maps)
	list mod_opts = maplist(`e, mod_entries, ``(lookup(e, "options", $[])));

	list opts = [];

	foreach(`a, mod_opts,
	``{
	    foreach(`b, `c, a,
	    ``{
	        opts = add(opts, b);
	    });
	});
	opts = toset(opts);
	opts = filter(`e, opts, ``(e != "snd_id"));

	map res = $[];
	// for each option collect their values
	foreach(`opname, opts,
	``{
	    boolean coma = false;
	    string value = "";
	    foreach(`s, mod_opts,
	    ``{
	        if (coma)
	        {
	            value = value + ",";
	        }
	        value = value + lookup(s, opname, "");

	        coma = true;
	    });
	    res = add(res, opname, value);
	});

	return res;

    }

    /**
     * creates list of command that will be used for sound system start (emulates 'rcalsasound start' somehow)
     * @return list of shell commands
     *
     */

    global define list CreateModprobeCommands() ``{
	list outlist = [];
	// create distinct list of all modules
        list mods = toset(maplist(`e, modules_conf, ``(lookup(e, "module", "off"))));
	maplist(`modname, mods, ``{
	    map opts = CollectOptions(modname);
	    string optstr = "";
	    maplist(`k, `v, opts, ``{
		optstr = optstr+ sformat(" %1=%2", k, v);
	    });
	    // we need to tell 'modprobe' not to look into modules.conf now, because
	    // it may contain messed options for the module %1 that will break the module
	    // loading. (modprobe will merge options specified in param %2 with those specified
	    // in modules.conf)
	    string modprobe = sformat("/sbin/modprobe -C /dev/null %1 %2", modname, optstr);
	    outlist = add(outlist, modprobe);
	});

	return outlist;

    }

    /**
     * reset settings. used at installation time when user invokes 'reset to original proposal'
     */

    global define void ForceReset() ``{
	modules_conf = [];
	DetectHardware();
	UpdateUnconfiguredCards();
	proposal_created = false;
    }

    /**
     * create a proposal
     * @return boolean success/failure
     */

    global define boolean Propose() ``{
	if (proposal_created)
	{
	    return true;
	}
	ForceReset();

	// fix for nm256 cards: see bug #10384: leave this card unconfigured.
	// loading of this module fails under some notebooks, nm256 module
	// also makes some problems on other notebooks: there are detected
	// two cards on some machines, althrough there is a sinlge card.
	// two cards are detected: one that use opl3sa module and second one
	// that uses nm256. let's solve this problem by filtering the nm256 mofdule out.

	unconfigured_cards = filter(`e, unconfigured_cards, ``(lookup(e, "module", "") != "snd-nm256"));

	modules_conf = recalc_save_entries(unconfigured_cards);
	rc_vars = $[
		"LOAD_ALSA_SEQ": "yes"
	    ];
	proposal_created = true;
	return true;
    }

    /* settings' backup */

    list modules_conf_b = nil;
    map rc_vars_b = nil;
    list volume_settings_b = nil;

    /**
     * copy settings to backup variables
     */

    global define void StoreSettings() ``{
	modules_conf_b = modules_conf;
	rc_vars_b = rc_vars;
	volume_settings_b = volume_settings;
    }

    /**
     * restore settings from backup variables
     */

    global define void RestoreSettings() ``{
	if (modules_conf_b == nil)
	{
	    y2error("restoring sound setting without storing them before. bailing out.");
	}
	modules_conf = modules_conf_b;
	rc_vars = rc_vars_b;
	volume_settings = volume_settings_b;
    }

    /**
     * Status of configuration
     * @return boolean true if configuration was changed
     */

    global define boolean Changed() ``{
	if (modules_conf != modules_conf_b ||
	    rc_vars != rc_vars_b)
	{
	    return true;
	}
	return false;
    }

    /**
     * returns list of configured/proposed sound cards.
     * @return list of maps: [$["name": "ASDASD", "card_no": 0]...]
     *
     */

    global define list GetSoundCardList() ``{
	if (installation)
	{
	    integer pos = -1;
	    return maplist(`c, modules_conf, ``{
		    pos = pos + 1;
		    return
		    $[
			"name" : lookup(c, "model", _("Sound card")),
			"card_no": pos
		    ];
		});
	}
	else
	{
	    path cards_path = .audio.alsa.cards;

	    list cards_numbers = SCR::Dir(cards_path);

	    list cards = [];
	    if (cards_numbers != nil)
	    {
		cards =
		    maplist(`card_no, cards_numbers, ``{
			path curcard_path = add(cards_path, sformat("%1", card_no));
			return $[ "card_no" : tointeger(card_no),
                              "name" :    SCR::Read(curcard_path + .name) ];
		    });
	    }

	    y2debug("List of the sound cards: %1", cards);
	    return cards;
	}
    }

    /**
     * stores unique keys. this function is not part of sound_write module
     * because it should not be called during autoinstallation
     *
     */

    global define void StoreUniqueKeys() ``{
	UpdateUnconfiguredCards();
	list conf = maplist(`e, modules_conf, ``(lookup(e, "unique_key", "")));
	list unconf = maplist(`e, unconfigured_cards, ``(lookup(e, "unique_key", "")));
	SaveUniqueKeys(conf, unconf);
    }

    /**
     * Get joystick settings from sound database
     * @param modname name of sound module
     * @return map map with options
     */

    global define map GetJoystickSettings(string modname) ``{
	map mod = lookup(db_modules, modname, $[]);
	return lookup(mod, "joystick", $[]);
    }

    /**
     * store mixer settings
     */

    global define void StoreMixer() ``{
	if (size(SCR::Dir(.audio.alsa.cards)) == 0)
	{
	    return;
	}
	volume_settings = [];
	path p = nil;
	list cards = SCR::Dir(.audio.alsa.cards);
	maplist(`c, cards, ``{
	    p = topath(sformat(".audio.alsa.cards.%1.channels", c));
	    list channels = SCR::Dir(p);
	    maplist(`ch, channels, ``{
		p = topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", c, ch));
		if (!SCR::Read(p))
		{
		    p = topath(sformat(".audio.alsa.cards.%1.channels.%2.volume", c, ch));
		    volume_settings[tointeger(c)] = add(volume_settings[tointeger(c)]:$[],
			ch, SCR::Read(p));

		}

	    });

	});
    }

    /**
     * sets the channel volume to value [0..100]
     * @param card_id card #
     * @param channel channel name
     * @param value volume of channel [0..100]
     */

    global define void SetVolume(integer card_id, string channel, integer value) ``{
	// two cases: we have sound system already running:
	if (!autoinstallation && size(SCR::Dir(.audio.alsa.cards)) > card_id)
	{
            string p = sformat(".audio.alsa.cards.%1.channels.%2.volume", card_id, channel);
	    string p2 = sformat(".audio.alsa.cards.%1.channels.%2.mute", card_id, channel);
	    SCR::Write(topath(p2), false);
            return SCR::Write(topath(p), value);
	}
	else
	{
	    // alsa is not running. probably autoinstallation or someone wants
	    // to change proposed volume
	    // store volume to Sound::volume_settings datastricure in autoinstallation
            map oldmap = Sound::volume_settings[card_id]:$[];
            Sound::volume_settings[card_id] = add(oldmap, channel, value);
            return true;
	}
    }

    /**
     * initialises volume after adding a new card. unmutes and sets volume for some channels
     * @param card_id card id.
     * @param modname name of sound module
     */

    global define void  InitMixer(integer card_id, string modname) ``{
        map devs = lookup(lookup(Sound::db_modules, modname, $[]), "mixer",
            $["Master":70, "PCM":70, "CD":70, "Synth": 70]);

	// now let's merge settings from volume_settings list
	if (size(volume_settings) != 0)
	{
	    maplist(`k, `v, volume_settings[card_id]:$[],
	    ``{
		devs = add(devs, k, v);
	    });
	}

        list devs2 = maplist(`k, `v, devs, ``(k));

        foreach (`dev, `vol, devs, ``{
	    SetVolume (card_id, dev, vol);
	});

        unmute(devs2, card_id);

	// in addidtion, some other channels can be specified or some volumes may be overriden
    }

    /**
     * Test whether sound card supports joystick
     * @param card_id id of sound card
     * @return boolean True if sound card card_id supports joystick
     */

    global define boolean HasJoystick(integer card_id) ``{
	if (card_id == nil)
	{
	    return false;
	}

	if (use_alsa == true)
	{
	    map entry = select(modules_conf, card_id, $[]);
	    string modname = lookup(entry, "module", "");

	    if (lookup(lookup(db_modules, modname, $[]), "joystick", $[]) == $[])
	    {
		return false;
	    }
	    else
	    {
		return true;
	    }
	}
	else
	{
	    return false;
	}
    }

    /**
     * Return list of configured/proposed sound cards which support joystick
     * @return list list of maps: [$["card_no":0, "name":"Sound Blaster Live!"]]
     */
    global define list GetSoundCardListWithJoy() ``{

	// get list of installed sound cards
	list cards = GetSoundCardList();

	// cards which support joysticks
	list filtered = [];

	// remove cards without joystick support
	foreach(map m, cards, ``{
		integer cid = lookup(m, "card_no", nil);

		if (cid != nil && Sound::HasJoystick(cid) == true)
		{
		    filtered = add(filtered, m);
		}
	    }
	);

	return filtered;
    }

}
