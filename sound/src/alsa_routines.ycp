/**
 *
 *
 * File:
 *   alsa_routines.ycp
 *
 * Module:
 *   Sound
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * routines for alsa sound system
 *
 *
 */

{
    textdomain "sound";

    /**
     * sets volume in percents (0..100) for given card and card_id
     * @param group channel
     * @param cardid
     * @param value
     * @return boolean success/failure
     */

    global define boolean SetVolume (string group, integer cardid, integer value) ``{
        string p = sformat(".audio.alsa.cards.%1.channels.%2.volume", cardid, group);

        return SCR::Write(topath(p), value);
    }

    /**
     * plays test sound to card #card_id
     * @param card_id
     *
     */

    global define string PlayTest (integer card_id) ``{

	string fname = "/usr/share/sounds/alsa/test.wav";
        if (SCR::Read(.target.size, fname) == -1)
        {

                  // To translators: just one file will be displayed
                  // To translators: if the test audio file can not be found this message is displayed
                  // To translators: This is just popup message, shouldn't be too long
            string msg = sformat (_("Cannot find file:\n %1\n\n(test audio file)"), fname);

            return msg;
        }
        else
        {
            SCR::Execute (.target.bash_background, sformat("/usr/bin/aplay -c %1 %2 > /dev/null 2>&1", card_id, fname));
        }
        return "";
    }


    /**
     * sound_start_tmp starts alsa using temporary modules.conf
     * @param restore true - call alsactl restore, false - don't
     *
     *
     */

    global define void sound_start_tmp(boolean restore, integer count) ``{

	string pattern = "options (snd-card-.*)";

	string str = SCR::Read(.target.string, "/tmp/modules.conf");

	list l = splitstring(str, "\n");

	string cmd = sformat("/sbin/modprobe snd snd_cards_limit=%1", count);
	y2error("executing %1", cmd);
	SCR::Execute(.target.bash, cmd, $[]);

	foreach(`e, l,
	``{
	    list tmp = regexptokenize(e, pattern);
	    if (size(tmp)>0)
	    {
		cmd = sformat("/sbin/modprobe %1", select(tmp, 0, "off"));
		y2error("executing %1", cmd);
		SCR::Execute(.target.bash, cmd, $[]);
	    }
	});

	if (restore)
        {
            SCR::Execute(.audio.alsa.restore, 0, 0);
        }

/*
        string cmd = "/sbin/depmod -C " + get_tmp_modules_conf() + " /dev/null 2>&1";
        SCR::Execute(.target.bash, cmd, $[]);

        list als = SCR::Read(.tmp.modules.alias);


        string modname = "";
        integer pos = 0;
        map res = $[];
        while (contains(als, sformat("snd-card-%1", pos)))
        {
            modname = SCR::Read(.tmp.modules.alias, sformat("snd-card-%1", pos));
            cmd     = sformat("/sbin/modprobe -C %1 %2 ", get_tmp_modules_conf(), modname);
            res     = SCR::Execute(.target.bash_output, cmd, $[]);
            if (lookup(res, "stderr", "") != "")
            {
                y2error("modprobe error output: \n" + lookup(res, "stderr", ""));
            }
            pos = pos + 1;
        }


        if (restore)
        {
            SCR::Execute(.audio.alsa.restore, 0, 0);
        }
*/  }

    /**
     * removes all sound modules from kernel
     * 
     *
     */


    global define map sound_stop() ``{
	SCR::Execute (.target.bash, "/etc/init.d/alsasound stop > /dev/null 2>&1", $[]);
    }
    
    /** returns card models list 
     *
     * @param modname if "all" returns all models
     * @return list with sound cards driven by given module
     *
     *
     */

    global define list get_card_names(string modname) ``{
	// we need module index :(


        if (modname == "all")
        {
            list cards = [];
            cards = maplist(`k, `v, Sound::db_cards, ``(v));
	    cards = flatten(cards);
            return sort(cards);
        }
	else
	{
	    map mods = mapmap(`k, `v, Sound::db_module_index, ``([v, k]));
	    integer index = lookup(mods, modname, 0);

	    list cards = sort(lookup(Sound::db_cards, index, []));

	    if (cards == [])
	    {
		cards = [lookup(
			    lookup(Sound::db_modules, modname, $[]),
			    "description", "")];
	    }

	    return cards;
	}
    }

    /**  
     * returns module name for a given card model
     * @param cardname string card name
     * @return modules name
     *
     */

    global define string get_module_by_cardname(string cardname) ``{
	integer i = -1;
	foreach(`e, `f, Sound::db_cards, 
	``{
	    if (contains(f, cardname))
	    {
		i = e;
	    }
	});

	return lookup(Sound::db_module_index, i, "error");

    }

    /**
     * returns the 'params' section from sndcards.ycp of the given module
     * @param modname module name
     * @return list with params and their descriptions
     */

    global define map get_module_params(string modname) ``{
	map mod = lookup(Sound::db_modules, modname, $[]);
	return lookup(mod, "params", $[]);
    }


    /** 
     * creates a list of sound modules for selection box
     * @return list of items: [`item(`id(module_name), "module label")]
     */
    global define list get_module_names() ``{
	list mods = maplist(`k, `v, Sound::db_modules,
	    ``(`item(`id(k), lookup(v, "description", k))));

	mods = sort(`a, `b, mods, ``(select(a, 1, nil) < select(b, 1, nil)));

	mods = prepend(mods,  `item(`id("all"), _("All")));
	return mods;
    }


    /**
     * get_vol_settings
     * creates a list of stored values of volume and mute for each channel
     * of each card.
     * example: [ 
		    [ ["PCM", 32, false], ["Master", 100, true]],
		    [ [....], .....                            ]
		]
     *
     */

    global define list get_vol_settings() ``{
	integer bound	= size(SCR::Dir(.audio.alsa.cards));
	integer i	= 0;
	list retlist	= [];
	while (i < bound)
	{
	    list sublist = [];
	    foreach(`e, SCR::Dir(topath(sformat(".audio.alsa.cards.%1.channels", i))),
	    ``{
		path pth1 = topath(sformat(".audio.alsa.cards.%1.channels.%2.volume", i, e));	
		path pth2 = topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", i, e));
		sublist = add(sublist, [e, SCR::Read(pth1), SCR::Read(pth2)]);
	    });
	    retlist = add(retlist, sublist);
	    i = i + 1;
	}
	return retlist;

    }

    /**
     * stores values generated by get_vol_settings
     * @param vol_settings
     */


    global define boolean set_vol_settings(list vol_settings) ``{
	integer i = 0;
	foreach(`e, vol_settings,
	``{
	    foreach(`f, e, 
	    ``{
		path pth1 = topath(sformat(".audio.alsa.cards.%1.channels.%2.volume", i, select(f, 0, "Master")));
		path pth2 = topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", i, select(f,0, "Master")));
		SCR::Write(pth1, select(f, 1, 0));
		SCR::Write(pth2, select(f, 2, false));
	    });
	    i = i + 1;
	});
	SCR::Execute(.audio.alsa.store, nil);
    }

    /**
     *  Returns list of already running cards
     *  @return list
     *  
     *
     */

    global define list get_running_cards () ``{
        if (SCR::Read(.target.size, "/proc/asound/cards") != -1)
        {
            list asound = SCR::Read(.proc.asound.cards);
            if (is(select (asound, 0, $[]), map))
            {
                return asound;
            }
        }
        return [];
    }


    /**
     * fliters out already configured cards
     * @param save_info info from modules.conf
     * @param cards autodetected cards
     * @return list of entries of not configured cards
     */

    global define list filter_configured(list save_info, list cards) ``{
	cards = filter(`e, cards,
	``{
	    string uniq	    = lookup(e, "unique_key", "");
	    boolean retval  = true;
	    foreach(`s, save_info,
	    ``{
		if (lookup(s, "unique_key", "") == uniq)
		{
		    retval = false;
		}
	    });
	    return retval;
	});
	return cards;
    }


    /**         
     * adds alias to save_info entry
     * @param entry card config
     * @param card_id
     * @return modified card entry with filled alias value
     */


    global define map add_alias(map entry, integer card_id) ``{
	return add(entry, "alias", sformat("snd-card-%1", card_id));
    }

    /**
     *  adds common options for module. for alsa it is 'snd_id=card(#+1) snd_index=#'
     *  @param entry card config
     *  @param card_id
     *  noop for oss
     */ 

    global define map add_common_options(map entry, integer card_id) ``{
	map opts = lookup(entry, "options", $[]);
	opts = add(opts, "snd_index", card_id);
        opts = add(opts, "snd_id", sformat("card%1", card_id+1));

	opts = add(opts, "snd_enable", "1");

	entry = add(entry, "options", opts);
	return entry;
    }

    /**
     * Simply returns list with ALSA OSS/Free emulation modules
     * @param number number of sound cards
     * @return list
     */
    global define list alsa_oss (integer number) ``{
        list modules = [];
        integer i = 0;
        // map with minor as a key and module as value
        map oss_list = $[
            0  : "snd-mixer-oss",
            11 : "snd-mixer-oss",
            3  : "snd-pcm-oss",
            12 : "snd-pcm-oss",
            1  : "snd-seq-oss",
            8  : "snd-seq-oss"
            ];

        while (i < number)
        {
            modules = add(modules, $[ "alias": sformat ("sound-slot-%1", i),
                                    "module": sformat ("snd-card-%1", i)]);
            foreach(`k, `v, oss_list,
            ``{
                modules = add(modules, $[ "alias": sformat("sound-service-%1-%2",i, k),
                                        "module": v]);
            });
            i = i + 1;
        }
        return modules;
    }
    
    /**
     * returns list of autodetected sound cards that haven't been already configured
     * @param save_info list of already configured cards
     */

    global define list getConfigurableCards(list save_info) ``{
        list snd = Sound::detected_cards;
        snd = filter_configured(save_info, snd);
        if (size(snd) > 0)
        {
            // get all the apropriate information from the database
            snd =  maplist(`e, snd, ``(add (e, "module", get_module (e))));

            // filter out modules with unspecified module name (sound card not supported by alsa / no module found)
            // create save_info entries

	    snd = maplist(`c, snd, ``{
		map mod = get_module (c);
		if (mod == $[])
		{
		    return $[];
		}
		map options = lookup(mod, "params", $[]);
		map opts = $[];
		maplist(`op, `data, options,
		``{
		    if (lookup(data, "default", "") != "")
		    {
			opts = add(opts, op, lookup(data, "default", ""));
		    }
		});
		map entry = $[
		    "model"     : get_card_label(c),
		    "module"    : lookup(mod,"name", ""),
		    "unique_key": lookup(c, "unique_key", ""),
		    "options"   : opts];
		return entry;
	    });
	    snd = filter(`e, snd, ``(lookup(e, "module", $[])!=$[]));
        }
        return snd;
    }

}
