/**
 *
 *
 * File:
 *   alsa_routines.ycp
 *
 * Module:
 *   Sound
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * routines for alsa sound system
 *
 *
 */

{
    textdomain "sound";
    import "Sound";
    import "Mode";
    import "Directory";

    // list of all card models (generated only once and cached)
    global list all_card_names = [];

    /**
     * sets volume in percents (0..100) for given card and card_id
     * @param group channel
     * @param cardid card id
     * @param value volume 0-100
     * @return boolean success/failure
     */

    global define boolean setVolume (string group, integer cardid, integer value) ``{
	if (!Mode::config)
	{
	    string p = sformat(".audio.alsa.cards.%1.channels.%2.volume", cardid, group);

	    return SCR::Write(topath(p), value);
	}
	else
	{
	    // store volume to Sound::volume_settings datastricure in autoinstallation
	    map oldmap = Sound::volume_settings[cardid]:$[];
	    Sound::volume_settings[cardid] = add(oldmap, group, value);
	    return true;
	}
    }

    /**
     * plays test sound to card #card_id
     * @param card_id card id
     * @return string with error message. empty on success
     *
     */

    global define string PlayTest (integer card_id) ``{

	string fname = "/usr/share/sounds/alsa/test.wav";
        if (SCR::Read(.target.size, fname) == -1)
        {
            return
            // If the test audio file can not be found this message is displayed
            // %1 is file name (only one)
	    sformat (_("Cannot find file:\n %1\n\n(test audio file)"), fname);
        }
        else
        {
	    // ----- FIXME temporary sound! remove before 9.1 FIXME!
	    fname = Directory::datadir + "/test.wav";
            SCR::Execute (.target.bash_background, sformat("/usr/bin/aplay -D plughw:%1 %2 > /dev/null 2>&1", card_id, fname));
        }
        return "";
    }


    /**
     * sound_start_tmp starts alsa using temporary modules.conf
     * @param restore true - call alsactl restore, false - don't
     * @return void
     *
     */

    global define void sound_start_tmp(boolean restore) ``{
	string snd = sformat("/sbin/modprobe snd snd_cards_limit=%1 snd_major=116", size(Sound::modules_conf));

	// get the list of commands needed for start
	list cmds = Sound::CreateModprobeCommands();

	// start 'snd' module first
	cmds = flatten ([[snd], cmds]);
	maplist(`cmd, cmds, ``{
	    map res = SCR::Execute(.target.bash_output, cmd, $[]);
	    if (res["stderr"]:"" != "")
                y2error("/sbin/modprobe error output: \n" + res["stderr"]:"");
	});

        if (restore)
        {
            SCR::Execute(.audio.alsa.restore, 0, 0);
        }
    }

    /**
     * removes all sound modules from kernel
     * @return void
     */
    global define void sound_stop() ``{
	SCR::Execute (.target.bash, "/etc/init.d/alsasound stop > /dev/null 2>&1", $[]);
    }

    /**
     * returns cards manufactured by given vendor
     * @param vendor if "all" returns all models
     * @return list with sound card models
     */
    global define list get_card_names (string vendor) ``{

	Sound::LoadDatabase();
        if (vendor == "all" || vendor == "")
        {
	    if (all_card_names == [] || all_card_names == nil)
	    {
		// use card names from db_cards (they contain the vendor name)
		all_card_names = maplist (`k, `v, Sound::db_cards, ``(v));
		all_card_names = sort (flatten (all_card_names));
	    }
	    return all_card_names;
        }
	else
	{
	    // names from db_vendors (vendor name not included - not necessary)
	    return sort (Sound::db_vendors[vendor]:[]);
	}
    }

    /**
     * returns list of card vendors
     * @return list of items with vendors (into table)
     */
    global define list get_vendor_names () ``{
	Sound::LoadDatabase();
	list items = maplist (string v, list cs, Sound::db_vendors, ``{
	    if (v == "other")
		// table entry (vendor was not defined)
		return `item(`id(v), _("Other"));
	    return `item(`id(v), v);
	});
	// table entry (all vendors)
	return prepend (items, `item(`id("all"), _("All")));
    }


    /**
     * returns module name for a given card model
     * @param cardname string card name
     * @return string module name
     */
    global define string get_module_by_cardname(string cardname) ``{
	integer i = -1;
	foreach(`e, `f, Sound::db_cards, ``{
	    if (contains(f, cardname))
	    {
		i = e;
	    }
	});
	return Sound::db_module_index[i]:"error";
    }

    /**
     * returns the 'params' section from sndcards.ycp of the given module
     * @param modname module name
     * @return map with params and their descriptions
     */

    global define map get_module_params(string modname) ``{
	Sound::LoadDatabase();
	map mod = lookup(Sound::db_modules, modname, $[]);
	return lookup(mod, "params", $[]);
    }


    /**
     * get_vol_settings
     * creates a list of stored values of volume and mute for each channel
     * of each card.
     * example: [
		    [ ["PCM", 32, false], ["Master", 100, true]],
		    [ [....], .....                            ]
		]
     * @return list as above
     */

    global define list get_vol_settings() ``{
	Sound::LoadDatabase();
	integer bound	= size(SCR::Dir(.audio.alsa.cards));
	integer i	= 0;
	list retlist	= [];
	while (i < bound)
	{
	    list sublist = [];
	    string modname = lookup(select(Sound::modules_conf, i, $[]), "module", "snd-dummy");

	    list chans = lookup(lookup(Sound::db_modules, modname, $[]), "mixer_elements", []);

	    if (chans == [])
	    {
		if (contains(SCR::Dir(.audio.alsa.cards), sformat("%1", i)))
		{
		    chans = SCR::Dir(topath(sformat(".audio.alsa.cards.%1.channels", i)));
		}
		else
		{
		    chans = [];
		}
	    }

	    foreach(`e, chans,
	    ``{
		path pth1 = topath(sformat(".audio.alsa.cards.%1.channels.%2.volume", i, e));
		path pth2 = topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", i, e));
		sublist = add(sublist, [e, SCR::Read(pth1), SCR::Read(pth2)]);
	    });
	    retlist = add(retlist, sublist);
	    i = i + 1;
	}
	return retlist;

    }

    /**
     * stores values generated by get_vol_settings
     * @param vol_settings volume settings
     * @return boolean success/failure
     */


    global define boolean set_vol_settings(list vol_settings) ``{
	integer i = 0;
	foreach(`e, vol_settings,
	``{
	    foreach(`f, e,
	    ``{
		path pth1 = topath(sformat(".audio.alsa.cards.%1.channels.%2.volume", i, select(f, 0, "Master")));
		path pth2 = topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", i, select(f,0, "Master")));
		SCR::Write(pth1, select(f, 1, 0));
		SCR::Write(pth2, select(f, 2, false));
	    });
	    i = i + 1;
	});
	SCR::Execute(.audio.alsa.store, nil);
    }

    /**
     *  Returns list of already running cards
     *  @return list
     *
     *
     */

    global define list get_running_cards () ``{
	path proot = .audio.alsa.cards;

	list cards = SCR::Dir(proot);

	return maplist(`e, cards, ``($["number":tointeger(e), "name": SCR::Read(add(add(proot, e), "name"))]));
    }


    /**
     * fliters out already configured cards
     * @param save_info info from modules.conf
     * @param cards autodetected cards
     * @return list of entries of not configured cards
     */

    global define list filter_configured(list save_info, list cards) ``{
	if (cards == nil) return [];
	cards = filter(`e, cards,
	``{
	    string uniq	    = lookup(e, "unique_key", "");
	    boolean retval  = true;
	    foreach(`s, save_info,
	    ``{
		if (lookup(s, "unique_key", "") == uniq)
		{
		    retval = false;
		}
	    });
	    return retval;
	});
	return cards;
    }


    /**
     * adds alias to save_info entry
     * @param entry card config
     * @param card_id card id
     * @return map modified card entry with filled alias value
     */
    global define map add_alias(map entry, integer card_id) ``{
	return add(entry, "alias", sformat("snd-card-%1", card_id));
    }

    /**
     *  adds common options for module. for alsa it is 'snd_index=${card_id}'
     *  @param entry card config
     *  @param card_id card id
     *  @return map modified save_entry
     */
    global define map add_common_options(map entry, integer card_id) ``{
	map opts = lookup(entry, "options", $[]);
	opts = add(opts, "snd_index", sformat("%1", card_id));
//        opts = add(opts, "snd_id", sformat("card%1", card_id+1));

	opts = add(opts, "snd_enable", "1");

	entry = add(entry, "options", opts);
	return entry;
    }

    /**
     * Simply returns list with ALSA OSS/Free emulation modules
     * @param number number of sound cards
     * @return list of oss-alsa aliases
     */
    global define list alsa_oss (integer number) ``{
        list modules = [];
        integer i = 0;
        // map with minor as a key and module as value
        map oss_list = $[
            0  : "snd-mixer-oss",
            11 : "snd-mixer-oss",
            3  : "snd-pcm-oss",
            12 : "snd-pcm-oss",
            1  : "snd-seq-oss",
            8  : "snd-seq-oss"
            ];

        while (i < number)
        {
            modules = add(modules, $[ "alias": sformat ("sound-slot-%1", i),
                                    "module": sformat ("snd-card-%1", i)]);
            foreach(`k, `v, oss_list,
            ``{
                modules = add(modules, $[ "alias": sformat("sound-service-%1-%2",i, k),
                                        "module": v]);
            });
            i = i + 1;
        }
        return modules;
    }

    /**
     * returns list of autodetected sound cards that haven't been already configured
     * @param save_info list of already configured cards
     * @return list of unconfigured cards
     */
    global define list getConfigurableCards(list save_info) ``{
        list snd = Sound::detected_cards;
        snd = filter_configured(save_info, snd);
        if (size(snd) > 0)
        {
            // create save_info entries
	    snd = maplist(`c, snd, ``{
		if (c["alsaconf_detected"]:false)
		    return c;
		// get all the apropriate information from the database
		map mod = get_module (c);
		if (mod == $[])
		{
		    return $[];
		}
		map options = lookup(mod, "params", $[]);
		map opts = $[];
		maplist(`op, `data, options,
		``{
		    if (lookup(data, "default", "") != "")
		    {
			opts = add(opts, op, lookup(data, "default", ""));
		    }
		});
		map entry = $[
		    "model"     : get_card_label(c),
		    "module"    : lookup(mod,"name", ""),
		    "unique_key": lookup(c, "unique_key", ""),
		    "options"   : opts];
		return entry;
	    });
            // filter out modules with unspecified module name
	    // (sound card not supported by alsa / no module found)
	    snd = filter(`e, snd, ``(lookup(e, "module", "")!=""));
        }

        return snd;
    }

}
