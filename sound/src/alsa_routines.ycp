/**
 *
 *
 * File:
 *   alsa_routines.ycp
 *
 * Module:
 *   Sound
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * routines for alsa sound system
 *
 *
 */

{
    textdomain "sound";

    /**
     * sets volume in percents (0..100) for given card and card_id
     * @param group channel
     * @param cardid card id
     * @param value volume 0-100
     * @return boolean success/failure
     */

    global define boolean setVolume (string group, integer cardid, integer value) ``{
	if (!Sound::autoinstallation)
	{
	    string p = sformat(".audio.alsa.cards.%1.channels.%2.volume", cardid, group);

	    return SCR::Write(topath(p), value);
	}
	else
	{
	    // store volume to Sound::volume_settings datastricure in autoinstallation
	    map oldmap = Sound::volume_settings[cardid]:$[];
	    Sound::volume_settings[cardid] = add(oldmap, group, value);
	    return true;
	}
    }

    /**
     * plays test sound to card #card_id
     * @param card_id card id
     * @return string with error message. empty on success
     *
     */

    global define string PlayTest (integer card_id) ``{

	string fname = "/usr/share/sounds/alsa/test.wav";
        if (SCR::Read(.target.size, fname) == -1)
        {

                  // To translators: just one file will be displayed
                  // To translators: if the test audio file can not be found this message is displayed
                  // To translators: This is just popup message, shouldn't be too long
            string msg = sformat (_("Cannot find file:\n %1\n\n(test audio file)"), fname);

            return msg;
        }
        else
        {
            SCR::Execute (.target.bash_background, sformat("/usr/bin/aplay -D hw:card%1 %2 > /dev/null 2>&1", card_id, fname));
        }
        return "";
    }


    /**
     * sound_start_tmp starts alsa using temporary modules.conf
     * @param restore true - call alsactl restore, false - don't
     * @return void
     *
     */

    global define void sound_start_tmp(boolean restore) ``{
	string snd = sformat("/sbin/modprobe snd snd_cards_limit=%1 snd_major=116", size(Sound::modules_conf));

	// get the list of commands needed for start
	list cmds = Sound::CreateModprobeCommands();

	// start 'snd' module first
	cmds = flatten ([[snd], cmds]);
	maplist(`cmd, cmds, ``{
	    map res = SCR::Execute(.target.bash_output, cmd, $[]);
	    if (lookup(res, "stderr", "") != "")
            {
                y2error("/sbin/modprobe error output: \n" + lookup(res, "stderr", ""));
            }
	});

        if (restore)
        {
            SCR::Execute(.audio.alsa.restore, 0, 0);
        }
  }

    /**
     * removes all sound modules from kernel
     * @return void
     */

    global define void sound_stop() ``{
	SCR::Execute (.target.bash, "/etc/init.d/alsasound stop > /dev/null 2>&1", $[]);
    }

    /**
     * returns cards that use module 'modname'
     * @param modname if "all" returns all models
     * @return list with sound cards driven by given module
     *
     *
     */

    global define list get_card_names(string modname) ``{
	// we need module index :(

	Sound::LoadDatabase();

        if (modname == "all")
        {
            list cards = [];
            cards = maplist(`k, `v, Sound::db_cards, ``(v));
	    cards = flatten(cards);
            return sort(cards);
        }
	else
	{
	    map mods = mapmap(`k, `v, Sound::db_module_index, ``([v, k]));
	    integer index = lookup(mods, modname, 0);

	    list cards = sort(lookup(Sound::db_cards, index, []));

	    if (cards == [])
	    {
		cards = [lookup(
			    lookup(Sound::db_modules, modname, $[]),
			    "description", "")];
	    }

	    return cards;
	}
    }

    /**
     * returns module name for a given card model
     * @param cardname string card name
     * @return string module name
     *
     */

    global define string get_module_by_cardname(string cardname) ``{
	integer i = -1;
	foreach(`e, `f, Sound::db_cards,
	``{
	    if (contains(f, cardname))
	    {
		i = e;
	    }
	});

	return lookup(Sound::db_module_index, i, "error");

    }

    /**
     * returns the 'params' section from sndcards.ycp of the given module
     * @param modname module name
     * @return map with params and their descriptions
     */

    global define map get_module_params(string modname) ``{
	Sound::LoadDatabase();
	map mod = lookup(Sound::db_modules, modname, $[]);
	return lookup(mod, "params", $[]);
    }


    /** 
     * creates a list of sound modules for selection box
     * @return list of items: [`item(`id(module_name), "module label")]
     */
    global define list get_module_names() ``{
	Sound::LoadDatabase();
	list mods = maplist(`k, `v, Sound::db_modules,
	    ``(`item(`id(k), lookup(v, "description", k))));

	mods = sort(`a, `b, mods, 
	``{
	    return select(a, 1, "") <= select(b, 1, "");

	});

	// item for all sound card models in sound card driver list
	mods = prepend(mods,  `item(`id("all"), _("All")));
	return mods;
    }


    /**
     * get_vol_settings
     * creates a list of stored values of volume and mute for each channel
     * of each card.
     * example: [ 
		    [ ["PCM", 32, false], ["Master", 100, true]],
		    [ [....], .....                            ]
		]
     * @return list as above
     */

    global define list get_vol_settings() ``{
	Sound::LoadDatabase();
	integer bound	= size(SCR::Dir(.audio.alsa.cards));
	integer i	= 0;
	list retlist	= [];
	while (i < bound)
	{
	    list sublist = [];
	    string modname = lookup(select(Sound::modules_conf, i, $[]), "module", "snd-dummy");

	    list chans = lookup(lookup(Sound::db_modules, modname, $[]), "mixer_elements", []);

	    if (chans == [])
	    {
		if (contains(SCR::Dir(.audio.alsa.cards), sformat("%1", i)))
		{
		    chans = SCR::Dir(topath(sformat(".audio.alsa.cards.%1.channels", i)));
		}
		else
		{
		    chans = [];
		}
	    }

	    foreach(`e, chans,
	    ``{
		path pth1 = topath(sformat(".audio.alsa.cards.%1.channels.%2.volume", i, e));	
		path pth2 = topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", i, e));
		sublist = add(sublist, [e, SCR::Read(pth1), SCR::Read(pth2)]);
	    });
	    retlist = add(retlist, sublist);
	    i = i + 1;
	}
	return retlist;

    }

    /**
     * stores values generated by get_vol_settings
     * @param vol_settings volume settings
     * @return boolean success/failure
     */


    global define boolean set_vol_settings(list vol_settings) ``{
	integer i = 0;
	foreach(`e, vol_settings,
	``{
	    foreach(`f, e,
	    ``{
		path pth1 = topath(sformat(".audio.alsa.cards.%1.channels.%2.volume", i, select(f, 0, "Master")));
		path pth2 = topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", i, select(f,0, "Master")));
		SCR::Write(pth1, select(f, 1, 0));
		SCR::Write(pth2, select(f, 2, false));
	    });
	    i = i + 1;
	});
	SCR::Execute(.audio.alsa.store, nil);
    }

    /**
     *  Returns list of already running cards
     *  @return list
     *
     *
     */

    global define list get_running_cards () ``{
	path proot = .audio.alsa.cards;

	list cards = SCR::Dir(proot);

	return maplist(`e, cards, ``($["number":tointeger(e), "name": SCR::Read(add(add(proot, e), "name"))]));
    }


    /**
     * fliters out already configured cards
     * @param save_info info from modules.conf
     * @param cards autodetected cards
     * @return list of entries of not configured cards
     */

    global define list filter_configured(list save_info, list cards) ``{
	cards = filter(`e, cards,
	``{
	    string uniq	    = lookup(e, "unique_key", "");
	    boolean retval  = true;
	    foreach(`s, save_info,
	    ``{
		if (lookup(s, "unique_key", "") == uniq)
		{
		    retval = false;
		}
	    });
	    return retval;
	});
	return cards;
    }


    /**         
     * adds alias to save_info entry
     * @param entry card config
     * @param card_id card id
     * @return map modified card entry with filled alias value
     */


    global define map add_alias(map entry, integer card_id) ``{
	return add(entry, "alias", sformat("snd-card-%1", card_id));
    }

    /**
     *  adds common options for module. for alsa it is 'snd_index=${card_id}'
     *  @param entry card config
     *  @param card_id card id
     *  @return map modified save_entry
     */

    global define map add_common_options(map entry, integer card_id) ``{
	map opts = lookup(entry, "options", $[]);
	opts = add(opts, "snd_index", sformat("%1", card_id));
//        opts = add(opts, "snd_id", sformat("card%1", card_id+1));

	opts = add(opts, "snd_enable", "1");

	entry = add(entry, "options", opts);
	return entry;
    }

    /**
     * Simply returns list with ALSA OSS/Free emulation modules
     * @param number number of sound cards
     * @return list of oss-alsa aliases
     */
    global define list alsa_oss (integer number) ``{
        list modules = [];
        integer i = 0;
        // map with minor as a key and module as value
        map oss_list = $[
            0  : "snd-mixer-oss",
            11 : "snd-mixer-oss",
            3  : "snd-pcm-oss",
            12 : "snd-pcm-oss",
            1  : "snd-seq-oss",
            8  : "snd-seq-oss"
            ];

        while (i < number)
        {
            modules = add(modules, $[ "alias": sformat ("sound-slot-%1", i),
                                    "module": sformat ("snd-card-%1", i)]);
            foreach(`k, `v, oss_list,
            ``{
                modules = add(modules, $[ "alias": sformat("sound-service-%1-%2",i, k),
                                        "module": v]);
            });
            i = i + 1;
        }
        return modules;
    }
    
    /**
     * returns list of autodetected sound cards that haven't been already configured
     * @param save_info list of already configured cards
     * @return list of unconfigured cards
     */

    global define list getConfigurableCards(list save_info) ``{
        list snd = Sound::detected_cards;
        snd = filter_configured(save_info, snd);
        if (size(snd) > 0)
        {
            // get all the apropriate information from the database
            snd =  maplist(`e, snd, ``(add (e, "module", get_module (e))));

            // filter out modules with unspecified module name (sound card not supported by alsa / no module found)
            // create save_info entries

	    snd = maplist(`c, snd, ``{
		map mod = get_module (c);
		if (mod == $[])
		{
		    return $[];
		}
		map options = lookup(mod, "params", $[]);
		map opts = $[];
		maplist(`op, `data, options,
		``{
		    if (lookup(data, "default", "") != "")
		    {
			opts = add(opts, op, lookup(data, "default", ""));
		    }
		});
		map entry = $[
		    "model"     : get_card_label(c),
		    "module"    : lookup(mod,"name", ""),
		    "unique_key": lookup(c, "unique_key", ""),
		    "options"   : opts];
		return entry;
	    });
	    snd = filter(`e, snd, ``(lookup(e, "module", $[])!=$[]));
        }

	// just for testing the nm256-opl3sa2 stuff

//	return [
//	    $[
//		"model" : "first opl3sa2 card",
//		"module": "snd-opl3sa2",
//		"unique_key": "sdfasdfas",
//		"options": $[]
//	    ],
//	    $[
//		"model" : "second nm256 card",
//		"module": "snd-nm256",
//		"unique_key": "234tqadz",
//		"options": $[]
//	    ]
//
//	];

        return snd;
    }

}
