/**
 *
 * File:
 *   sound_options.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Module for setting options passed to the module
 *
 * String corrections by Christian Steinruecken <cstein@suse.de>, 2001/08/01
 *
 *
 * Authors:
 *   Dan Vesely <dan@suse.cz>, Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * parameters: 1st: parameter list
 *
 */

{

    textdomain "sound";
    import "Wizard";

    /**
     * parses string eg. '{{0,2},{0,100,20}}' to a list [0,1,2,0,20,40,60,80]
     * @param input input string
     * @return list
     */

    global define list parse_bracket(string input) ``{
        integer pos = 0;
        string inner = input; // substring(input, 1, size(input)-2);
        integer siz = size(inner);
        string tmp = "";

        list output = [];

        integer oldpos = 0;

        while(pos < siz)
        {
            if (substring(inner, pos, 1) == "{")
            {
                oldpos = pos;
                pos = pos + 1;
                integer cnter = 1;
                // let's find the pair bracket for '{'
                while((cnter > 0) && (pos < siz))
                {
                    if (substring(inner, pos, 1) == "}")
                    {
                        cnter = cnter - 1;
                    }
                    else if (substring(inner, pos, 1) == "{")
                    {
                        cnter = cnter + 1;
                    }
                    pos = pos + 1;
                }
                output = add(output, parse_bracket(substring(inner, oldpos + 1, pos - oldpos - 2)));
                pos = pos + 1;
            }
            else
            {
                oldpos = pos;
                while ((substring(inner, pos, 1) != ",") && pos < siz)
                {
                    pos = pos + 1;
                }
                output = add(output, substring(inner, oldpos, pos - oldpos));
                pos = pos + 1;
            }
        }
        return output;
    }

    global define list string2vallist(string input) ``{
	boolean parse_error = false;

	list l = parse_bracket(input);

	l = flatten(l);

	l = maplist(`e, l,
	``{
	    if (size(e) == 0)
	    {
		return [];
	    }
	    if (size(e) == 1)
	    {
		return e;
	    }

	    integer step = 1;
	    if (size(e) == 3)
	    {
		step = tointeger(select(e, 2, 1));
	    }
	    if (step < 1)
	    {
		parse_error = true;
		return [];
	    }

	    boolean hex = false;
	    if (regexpmatch(select(e, 1, ""), "^-[0-9]*$") || regexpmatch(select(e, 1, ""), "^[0-9]*$"))
	    {
		hex = false;
	    }
	    else if (regexpmatch(select(e, 1, ""), "^-0x[0-9a-fA-F]*")
			|| regexpmatch(select(e, 1, ""), "^0x[0-9a-fA-F]*"))
	    {
		hex = true;
	    }
	    else
	    {
		if (contains(["Disabled", "Enabled"], select(e, 1, "")))
		{
		    return [select(e, 0, "")];
		}
	    }

	    integer from = tointeger(select(e, 0, ""));
	    integer to = tointeger(select(e, 1, ""));

	    if (((to - from) / step) > 50)
	    {
		// too many values :(
		parse_error = true;
		return [];
	    }

	    list outlist = [];

	    while (from <= to)
	    {
		if (hex)
		{
		    outlist = add(outlist, tohexstring(from));
		}
		else
		{
		    outlist = add(outlist, sformat("%1", from));
		}
		from = from + step;
	    }
	    return outlist;
	});

	l = flatten(l);

	if (parse_error)
	{
	    y2debug("parse error: %1", input);
	}

	return l;

    }

    /**
     * default widget when there are no known values
     * @return term widget
     */

    global define term defWidget() ``{
	return `Label(_("Possible value:\nnot known"));
    }

    /**
     * widget for choosing one value from list
     * @param tail string with values eg. "12,3,4,6"
     * @param default string default value (preselected in combo)
     * @return term combobox widget
     */

    global define term gen_list(list vals, string default) ``{
	vals = maplist(`e, vals, ``(`item(`id(e), sformat("%1", e), default == e)));

	return `ComboBox(`id(`poss), `opt(`notify), _("&Possible value:"), vals);
    }

    global define void updatePossibleValues(string values, string default) ``{
	list l = string2vallist(values);
	if (l == [])
	{
	    UI::ReplaceWidget(`id(`reppoint), defWidget());
	    return;
	}
	term widg = gen_list(l, default);

	UI::ReplaceWidget(`id(`reppoint), widg);

    }

    /**
     * displays dialog with card options
     *
     * @param cardlabel string label for the card
     * @param options list. list where each item is map
     *        with keys: name, value, type, default, description.
     *	      values in map are strings
     * @return map
     *
     */

    global define map OptionsDialog (string cardlabel, map opts) ``{


	string help_text = lookup(STRINGS, "OptionsDialog", "");

	term con = `VBox ();

	map origOptions = opts;
//	y2error(sformat("%1", origOptions));
				    // always omit these options -- they are assigned dynamically
//	options = filter (`op, options, ``(lookup (op, "name", "") != "snd_id"));
//	options = filter (`op, options, ``(lookup (op, "name", "") != "snd_index"));
	list options = maplist (`e, `f, opts, ``($["description" : lookup (f, "descr", _("No description available")),
						// if no option name is available
						"name"         : e,
						"value"        : lookup (f, "value", ""),
						"type"         : lookup (f, "type", "string"),
						"default"      : lookup (f, "default", "")]));

	list itemized_descriptions = create_table (options, ["description", "name", "value"]);

	integer current_option = 0;
	string current_option_name = lookup (select (options, 0, ""), "name", "");

	if (size (itemized_descriptions) > 0)
	{
	    con = OptionsCon(cardlabel, itemized_descriptions, current_option, current_option_name);
	}
	else			// there are no options
	{
	    con = `VBox (//`Top(`Label ( cardlabel)),
			       // To translators: label message
			       `HVCenter (`Label (_("There are no options for this module"))));

	}


		// dialog title
	Wizard::SetContents (_("Sound card advanced options"), con, help_text, true, true);
	if (size (itemized_descriptions) > 0)
	{
	    UI::ChangeWidget(`id(`table), `CurrentItem, 0);
	}

	symbol ui = `table;

	repeat
	{
	    if (ui == `table)
	    {
		current_option = UI::QueryWidget (`id(`table), `CurrentItem);
		current_option_name = select(UI::QueryWidget(`id(`table), `Item(current_option)), 2, "");

		    // to translators: name of currently selected option: eg. 'Option: snd_asdf'
		UI::ChangeWidget(`id(`des), `Label, sformat("%1 %2", _("Option: "),current_option_name));
		UI::ChangeWidget(`id(`des), `Value, select(UI::QueryWidget(`id(`table), `Item(current_option)), 3, ""));

		    // update possible values
		map optmap = lookup(origOptions, current_option_name, $[]);
		string vals = "";
		if (size(optmap) == 0)
		{
		    vals = "";
		}
		else
		{
		    vals = lookup(optmap, "allows", "");
		}

		updatePossibleValues(vals, select(UI::QueryWidget(`id(`table), `Item(current_option)), 3, ""));

	    }
	    if (ui == `poss)
	    {
		current_option = UI::QueryWidget (`id(`table), `CurrentItem);
                current_option_name = select(UI::QueryWidget(`id(`table), `Item(current_option)), 2, "");

		string value = sformat("%1", (UI::QueryWidget(`id(`poss), `Value)));

		UI::ChangeWidget(`id(`des), `Value, value);
	    }
	    if (ui == `set)	// ui ==`set) set button pressed
	    {
		string value = UI::QueryWidget(`id(`des), `Value);

		if (size (value) == 0)  // we don't care  about empty values
		{
		    UI::ChangeWidget(`id(`table), `Item(current_option, 2), "");
		    continue;
		}

		list possible_values = parse_values(lookup (select (options, current_option, ""), "values", ""));

		string err = check_value (value,
						  lookup (select (options, current_option, ""), "type", "string"),
						  []); //possible_values);

		if (size (err) > 0)  // error - wrong value
		{
		    UI::MessagePopup (err);
		    UI::ChangeWidget(`id(`des), `Value, "");

		}
		else		// value is correct
		{

		    UI::ChangeWidget(`id(`table), `Item(current_option, 2), value);
		    list tmp = [];
		    maplist (`e, itemized_descriptions, ``{
				  if (current_option == select(select (e, 0, ""), 0, ""))
				      tmp = add (tmp, `item(select (e, 0, ""), 
					    select (e, 1, ""), select (e, 2, ""), value));
				  else
				      tmp = add (tmp, e);
			      });
		    itemized_descriptions = tmp;
		}

	    }
	    else if (ui == `reset && UI::YesNoPopup(_("Do you really want to reset all values?")))
	    {
		UI::ChangeWidget(`id(`des), `Value, "");

		integer i = 0;
		while (i < size (itemized_descriptions))
		{
		  UI::ChangeWidget(`id(`table), `Item(i, 2), lookup (select(options, i, ""), "default", ""));
		  i = i + 1;
		}

	    }
	    else if (ui == `abort || ui == `cancel)
	    {
		if (ReallyAbort())
		{
		    ui = `abort;
		    break;
		}
	    }
	    ui = UI::UserInput();
	} until (((ui == `back) || (ui == `next) || ui == `cancel));

	return $["ui" : ui, "return" : itemized_descriptions];
    }

// ===== MAIN =====

    /**
     * just calls options dialog
     * @param save_entry map with card configuration
     * @return symbol
     */

    global define map sound_options(map save_entry) ``{


//    map save_entry	= Args(0);
    string modname	= lookup(save_entry, "module", "");
    string cardlabel	= lookup(save_entry, "model", "");
    map params		= get_module_params(modname);


    map p2 = restore_mod_params(params, lookup(save_entry, "options", []));

    params = restore_mod_params(params, lookup(save_entry, "options", []));

    UI::ChangeWidget(`id(`next), `Label, UI::NextButtonLabel());

    // now show the dialog
    map result  = OptionsDialog (cardlabel, params);
    list vals	= lookup(result, "return", []);

      // convert from table entries back to card
    map opts = $[];
    foreach(`v, vals,
    ``{
	if (select(v, 3, "") != "")
	{
	    opts = add(opts, select(v, 2, ""), select(v, 3, ""));
	}

    });

    save_entry = add(save_entry, "options", opts);

    return $["ui" : lookup (result, "ui", `cancel), "return" : save_entry];
}

}
