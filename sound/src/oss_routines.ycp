/**
 *
 *
 * File:
 *   alsa_routines.ycp
 *
 * Module:
 *   Sound       
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * routines for alsa sound system
 *                   
 *
 */

{
    textdomain "sound";
    /**
     * sets volume in percents (0..100) for given card and card_id
     * @param group channel
     * @param cardid card_id
     * @param value volume 0-100
     * @return boolean success/failure
     */
    global define boolean setVolume (string group, integer cardid, integer value) ``{
	if (Arch::sparc)
	{
	    string cmd = sformat("/usr/bin/aumix -d /dev/mixer%1 -w %2", cardid, value);
	    SCR::Execute(.target.bash, cmd, $[]);
	}
	else
	{
	    string p = sformat(".audio.oss.cards.%1.channels.%2", cardid, group);

            SCR::Write(topath(p), value);
	}
	return true;
    }


    /**
     * plays test sound to card #card_id
     * @param card_id card id
     * @return string error string. empty on success
     */
    global define string PlayTest (integer card_id) ``{

	string fname="/usr/share/sounds/test.mp3";
        if (SCR::Read(.target.size, fname) == -1)
        {
                  // To translators: just one file will be displayed
                  // To translators: if the test audio file can not be found this message is displayed
                  // To translators: This is just popup message, shouldn't be too long
            string msg = sformat (_("Cannot find file:\n %1\n\n(test audio file)"), fname);

            return msg;
        }
        else
        {
	    y2debug("executing: "+ sformat("mpg123 -a /dev/dsp%1 %2", card_id, fname));
            SCR::Execute (.target.bash_background, sformat("/usr/bin/mpg123 -a /dev/dsp%1 %2", card_id, fname));
        }
        return "";
    }
    
    /**
     * removes all sound modules from kernel
     * 
     *
     */

    global define void sound_stop() ``{
	// TODO:
	list mods=SCR::Dir(.modinfo.kernel.drivers.sound);
	mods = add(mods, "emu10k1");
	mods = add(mods, "cs4281");
	map modules=SCR::Read(.proc.modules);
	foreach(`e, mods, 
	``{
	    if(haskey(modules, e))
	    {	    
		SCR::Execute(.target.bash, sformat("/sbin/rmmod -r %1", e), $[]);
	    }
	});
    }

    /**
     * sound_start_tmp starts alsa using temporary modules.conf
     * @param restore true - call alsactl restore, false - don't
     * @return void
     *
     */

    global define void sound_start_tmp(boolean restore) ``{
	// broken: TODO: reimplement this function in the alsa style (see alsa_routines:sound_start_tmp)
        string cmd = "/sbin/depmod -C " + get_tmp_modules_conf() + " /dev/null 2>&1";
        SCR::Execute(.target.bash, cmd, $[]);

        list als = SCR::Read(.tmp.modules.alias);


        string modname = "";
        integer pos = 0;
        map res = $[];
	string alias="";
        while (pos < 24)
        {
	    alias = sformat("sound-slot-%1", pos);
	    if (contains(als, alias))
	    {
		cmd     = sformat("/sbin/modprobe -C %1 %2 ", get_tmp_modules_conf(), alias);
		res     = SCR::Execute(.target.bash_output, cmd, $[]);
		if (lookup(res, "stderr", "") != "")
		{
		    y2error("modprobe error output: \n" + lookup(res, "stderr", ""));
		}
	    }
	    pos = pos + 1;
        }
    }

    /**
     * returns list of sound card names that are supported by given module
     * @param modname module name
     * @return list of cards
     */

    global define list get_card_names(string modname) ``{
	return [sformat("Sound card (%1)", modname)];
    }

    /**
     * returns a module name for sound card name 
     * not supported function for oss
     * @param cardname sound card name
     * @return string module name
     */

    global define string get_module_by_cardname(string cardname) ``{
	return "";
    }

    /**
     * returns list of parameters for module 'modname'
     * @param modname module name
     * @return map of parameters
     *
     */

    global define map get_module_params(string modname) ``{
	map params = SCR::Read(topath(sformat(".modinfo.kernel.drivers.sound.%1", modname)));
	params = filter(`k, `v, params, 
	    ``(!contains(["module_author", "module_description", "module_filename"], k)));

	list ret = maplist(`k, `v, params, ``(
	    $[
		"name"		:   k,
		"description"	:   [v],
		"type"		:   "string"
	    ]
	));
	return ret;
    }

    /**
     * returns list of all available sound modules
     * @return list as above
     *
     */

    global define list get_module_names() ``{
	list ret = SCR::Dir(.modinfo.kernel.drivers.sound);
	ret = filter(`e, ret, ``(e != "sound"));
	ret = add(ret, "emu10k1");
	ret = add(ret, "cs4281");
//	ret = sort(ret);
	ret = maplist(`e, ret, 
	``{
	    string descr = lookup(SCR::Read(add(.modinfo.kernel.drivers.sound, e)), 
		"module_description", "");
	    return `item(`id(e), (descr != "" && descr != "<none>") ? descr : e);
	});  

	ret = sort(`a, `b, ret, ``(select(a, 1, "") < select(b, 1, "")));

	return ret;
    }

    /**
     * returns number of currently running cards
     * oss is nasty hacked, because it's
     * not trivial to check this.
     * @return list of running cards
     */

    global define list get_running_cards() ``{
	return [1,2,3,4,5]; //size(save_info);
    }

    /**
     * get_vol_settings
     * creates a list of stored values of volume and mute for each channel
     * of each card.
     * example: [ 
		    [ ["PCM", 32, false], ["Master", 100, true]],
		    [ [....], .....                            ]
		]
     * @return list empty
     */

    global define list get_vol_settings() ``{
	return [];

    }

    /**
     * reads list generated by get_vol_settings and restores values for all cards
     * param1 looks like this:
     * [ 
	    [	// card #0
		["PCM", 15, false] // channel/volume/mute
		...	
	    ],
	    [   // card #1
		....
	    ]
	]
     * @param vol_settings list of list of list
     * @return boolean true
     * noop for oss
     */

    global define boolean set_vol_settings(list vol_settings) ``{
	return true;
    }


    /**
     * creates a save-info-like list of cards
     * @param cards detected cards
     * @return list of save_entries
     */

    global define list convert_to_save_info(list cards) ``{
	cards = maplist(`e, cards,
	``{
	    list options = lookup(e, "options", []);
	    map opts = $[];
	    maplist(`op, options,
	    ``{
		if (lookup(op, "default", "") != "")
		{
		    opts = add(opts, lookup(op, "name", ""), lookup(op, "default", ""));
		}
	    });
	    string modname = "";
	    list drivers = lookup(e, "drivers", []);
	    if (size(drivers) > 0)
	    {
		map driver = select(drivers, 0, $[]);
		list m = lookup(driver, "modules", []);
		if (size(m) > 0)
		{
		    modname = select(select(m, 0 ,[]), 0, "");
		    modname = select(splitstring(modname, "."), 0, "");
		}
	    }

	    map entry = $[
		"model"     : get_card_label(e),
		"module"    : modname,
		"unique_key": lookup(e, "unique_key", ""),
		"options"   : opts];
	    return entry;
	});
	return cards;
    }

    /**
     * adds alias to save_info entry
     * @param entry card config
     * @param card_id card id
     * @return modified card entry with filled alias value
     */

    global define map add_alias(map entry, integer card_id) ``{
	return add(entry, "alias", sformat("sound-slot-%1", card_id));
    }

    /**
     *	adds common options for module. for alsa it is 'snd_id=card(#+1) snd_index=#'
     *  @param entry card config
     *  @param card_id card_id
     *  @return map save_entry
     *  noop for oss
     */

    global define map add_common_options(map entry, integer card_id) ``{
	map opts = lookup(entry, "options", $[]);

	list parms = get_module_params(lookup(entry, "module", ""));
	if (size(parms) != 0)
	{
	    list enab = filter(`e, parms, ``(lookup(e, "name", "") == "snd_enable"));
	    if (size(enab) != 0)
	    {
		opts = add(opts, "snd_enable", "1");
	    }
	}

	entry = add(entry, "options", opts);
	return entry;
    }

    /**
     * Simply returns list with ALSA OSS/Free emulation modules
     * @param number number of sound cards
     * @return list
     * noop for oss
     */
    global define list alsa_oss (integer number) ``{
	return [];
    }

    /**
     * returns list of autodetected sound cards that haven't been already configured
     * @param save_info list of already configured cards
     * @return list of save_entries of unconfigured cards
     */

    

    global define list getConfigurableCards(list save_info) ``{
        list snd = Sound::detected_cards;
        snd = filter_configured(save_info, snd);
        if (size(snd) > 0)
        {
            snd = convert_to_save_info(snd);
        }
        return snd;
    }
 

}
