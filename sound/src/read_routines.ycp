/**
 * File:
 *   read_routines.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Routines for reading sound card configuration
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 */

{

    /**
     * tries to determine card model name from audio.alsa agent
     * @param card_id card id
     * @return card name, "Sound card" on failure
     */

    global define string read_card_name_from_alsa(integer card_id) ``{
	path pth = topath(sformat(".audio.alsa.cards.%1.name", card_id));
	string name = SCR::Read(pth);
	if (name == nil)
	{
	    return "Sound card";
	}
	return name;
    }


    /**
     * Extacts the unique key and the name of the card from comment in the
     * modules.conf placed before char-major-81-x
     * @param comment before the char-major-81-x
     * @return map Returns map: $[ "unique_key" : string, "name" : string ] or nil
     */
    global define map extractUniqueKey(string comment) ``{
	map result = nil;

	// split to lines
	list comment_lines = splitstring(comment, "\n");

	// find last line with a ":"
	string line_with_uk = "";
	integer colon_pos_uk = nil;
	foreach(`line, comment_lines, ``{
	    integer c_pos = findfirstof(line, ":");
	    if (c_pos != nil)
	    {
		line_with_uk = line;
		colon_pos_uk = c_pos;
	    }
	});

	// did we find it?
	if (colon_pos_uk != nil)
	{
	    // extract name
	    string name = substring(line_with_uk,
				    colon_pos_uk + 1,
				    size(line_with_uk) - colon_pos_uk - 1);
	    // extract unique key
	    integer start_uk = findfirstnotof(line_with_uk, "# \t");
	    string uk = substring(line_with_uk,
				  start_uk,
				  colon_pos_uk - start_uk);

	    result = $[ "name" : name, "unique_key" : uk ];
	}

	return result;
    }


    /**
     * reads already saved info from modules.conf
     * example:
     * [
     *	    $[
     *		"alias":    "snd-card-0",
     *		"module":   "snd-card-emu10k1",
     *		"options":  ["snd_id":"0", "snd_index":"card1"],
     *		"unique_key":"asdf.asdfasdfasdf",
     *		"model":    "Sound Blaster Live!"
     *	    ],
     *	    $[...]
     *	]
     * @return ist 
     */
    global define list read_save_info () ``{
        string prefix = "";
        list aliases  = SCR::Read(topath (sformat ("%1.modules.alias", prefix)));
        list options  = SCR::Read(topath (sformat ("%1.modules.options", prefix)));
        list save     = [];             // structure to save
        integer i     = 0;

	// since parameters in modules options are separated by comas (eg. options mod snd_id=1,2,3, snd_index=1,2,3)
	// we have to count occurences for each module

        if (true) // use_alsa )//contains (aliases, "char-major-116"))
        {
              // alsa modules
	    map mod_occur = $[];

	    list aliases = SCR::Read(.modules.alias);

	    aliases = filter(`e, aliases, ``(is_snd_alias(e)));

	    integer position = -1;

	    foreach(`e, aliases,
	    ``{
		position = position + 1;
		map entry = $[];
//		string modname = SCR::Read(.modules.alias, e);
		string modname = SCR::Read(add (.modules.alias, e));

		integer opt_pos = lookup(mod_occur, modname, 0);

		mod_occur = add(mod_occur, modname, lookup(mod_occur, modname, 0) + 1);

//		map options = SCR::Read(.modules.options, modname);
		map options = SCR::Read(add (.modules.options, modname));
		options = mapmap(`k, `v, options,
		``{
		    list vals = splitstring(v, ",");
		    if (size(v) > opt_pos)
		    {
			return [k, select(vals, opt_pos, "")];
		    }
		    return [nil, nil];
		}
		);

//		string comment = SCR::Read(.modules.alias.comment, e);
		string comment = SCR::Read(add (add (.modules.alias, e), "comment"));
		// first remove trash from the end and beginning of the comment string
		string uniq = "";
		string model = "";
		map res = extractUniqueKey(comment); //  parseModuleComment(comment);
		y2debug("%1", res);
		if (res != nil)
		{
		    uniq = lookup(res, "unique_key", ""); //substring(comment, 0, pos);
		    model = lookup(res, "name", ""); //substring(comment, pos+1, size(comment)-pos-1);
		}

		else
		{
		    // probably system upgrade
		    list cards = Sound::detected_cards;
		    // although the /var/lib/YaST/unique.inf is deprecated since 8.0,
		    // sometimes (if it exists) can help to assign old configuration
		    // to detected hardware (this applies only to upgrade)
		    list keys = read_unique_keys();
		    if (size(keys) <= position)
		    {
			uniq = isa_uniq();
			model = read_card_name_from_alsa(position);
		    }
		    else
		    {
			string key = select(keys, position, "");
			list card = filter(`cc, cards, ``(lookup(cc, "unique_key", "") == key));
			if (size(card) > 0)
			{
			    uniq = key;
			    model = get_card_label(select(card, 0, ""));
			}
			else
			{
			    uniq = isa_uniq();
			    model = read_card_name_from_alsa(position);
			}
		    }
		}

		entry = $[    "alias"	: e,
			    "module"	: modname,
			    "options"	: options,
			    "unique_key": uniq,
			    "model"	: model
		];

		save = add(save, entry);
	    });

        }

        return save;
    }


}
