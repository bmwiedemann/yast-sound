/** File:
 *   routines.ycp
 * 
 * Module:
 *   Sound
 * 
 * Summary:
 *   Routines for sound card configuration
 * 
 * Authors:
 *   Dan Veselý <dan@suse.cz>
 *
 * $Id$
 *
 */

{
    textdomain "sound";

    /**
     * fliters out already configured cards
     * @param save_info info from modules.conf
     * @param cards autodetected cards
     * @return list of entries of not configured cards
     */

    global define filter_configured(list save_info, list cards) ``{
        cards = filter(`e, cards,
        ``{
            string uniq     = lookup(e, "unique_key", "");
            boolean retval  = true;
            foreach(`s, save_info,
            ``{
                if (lookup(s, "unique_key", "") == uniq)
                {
                    retval = false;
                }
            });
            return retval;
        });
        return cards;
    }

    /**
     * returns the result of /usr/bin/whoami
     * @return string
     */

    global define whoami() ``{
	string cmd = "/usr/bin/whoami";
	map ret = SCR::`Execute(.target.bash_output, cmd, $[]);
	string out = lookup(ret, "stdout", "");
	list l = splitstring(out, "\n");
	if (size(l) > 0)
	{
	    return select(l, 0);
	}
	return "";
    }

    /**
     * logtime- logs current time - used for performance 
     * improvements. logs comment with current time
     * @param comment string
     */    

    global define logtime(string comment) ``{
	string s    = SCR::Read(.target.string, "/proc/uptime");
	list l	    = splitstring(s, " ");
	float f	    = tofloat(select(l, 0));
	y2error("%1 %2 : %3", comment, select(l, 0), f-oldf);
	oldf = f;
    }	

    /**
     * for a given card detected by libhd this function creates a 
     * label
     * @param card map entry from .probe.audio
     * @return string card label
     *
     */

    global define get_card_label(map card)
    ``{
        list lab = splitstring(hardware_name(card),"\n");
	if (size(lab) == 0 )
	{
	    return "";
	}
        if (size(lab) == 1 || select(lab, 1) == "")
        {
            return select(lab, 0);
        }
        return select(lab, 1);
    }

    /**
     * returns true if given string is valid sound alias
     * (snd-card-1 .. snd-card-16)
     * @param alias string
     * @return boolean
     *
     */

    global define is_snd_alias(string alias) ``{
	if (use_alsa)
	{
	    return regexpmatch(alias, "^snd-card-[0-9]*$");
	}
	else
	{
	    return regexpmatch(alias, "^sound-slot-[0-9]*$");
	}
    }


    /**
     * unique key for non-pci/pnp cards or virtual cards	
     * @return string
     */

    global define isa_uniq() ``{
	return "uniq.virtual";
    }

  /**
   * reads variables listed in 'vars' from rc.config
   * @param vars list of variables to read
   * @return map optname: value
   */
    global define read_rc_vars (list vars) ``{
        return listmap (`k, vars, ``([k, SCR::Read(topath(sformat (".rc.system.%1", k)))]));
    }

    

    /**
     *  Converts hex num to integer keeps decimal number as is. Hexadecimal
     *  number assumes to have prefix ``0x''. Doesn't  check the syntax.
     *	@param num string value
     *  @return integer
     */

    global define hextoi(string num) ``{
	return tointeger(num);
    }

    /**
     *  writes unique keys of the configured cards to /var/lib/YaST/unique.inf
     *  @param keys list with uniq keys
     *  @return boolean
     *  
     *
     */

    global define save_unique_keys (list keys) ``{
        list orig = SCR::Read(.var.lib.yast.unique);
        if (orig == nil)
        {
            orig = [];
        }
        list keys = maplist (`e, keys, ``($["unique" : e, "state" : "configured"]));
        orig = filter (`e, orig, ``(lookup(e, "section", "") != "sound"));
	list final = add (orig, $["contents" : keys, "section" : "sound"]);
        return SCR::Write(.var.lib.yast.unique, final);
    }


    /**
     * loads sound card database to global variable sound_db
     * @return list
     */

    global define GetCardDatabase() ``{
	textdomain "sound_db";
	y2debug("Reading card database");
	sound_db = eval(SCR::Read (.target.yast2, "sndcards.ycp"));
	textdomain "sound";
    }

    /** 
     * function for reading sound_db on demand
     * checks if sound_db is empty. if true, loads the database
     * to it. otherwise does nothing
     * @return void
     */

    global define read_db() ``{
	if (sound_db == nil || size(sound_db) == 0)
	{
	    GetCardDatabase();
	}
    }

    /**
     * Used for searching. returns index of the card in the database identified by name
     * @param name card name
     * @return integer
     */

    global define search_card_id (string name) ``{
        list all_cards = get_cards ("all");
        integer pos = 0;
        integer len = size (name);
	name = tolower(name);
	integer bound = size (all_cards);
        while (pos < bound)
        {
            if (substring (tolower(select (all_cards, pos)), 0, len) == name)
            {
                return pos;
            }
            pos = pos + 1;
        };
        return -1;
    }

    /**
     * returns list of sound cards that use module_name. get_cards("all") returns all cards
     * @param module_name 
     * @return list
     */

    global define get_cards (string module_name) ``{
        list ret = [];

	read_db();
        if (tolower(module_name) == "all")
        {	// copy the whole database
        maplist (`e, sound_db,
            ``{
                if (size (lookup (e, "cards", [])) > 0) ret = add (ret, lookup (e, "cards", []));
                else ret = add (ret, [lookup (e, "name", "")]);
            });
        }
        else
        {	// filter by name 
            ret = maplist (`c, filter (`e, sound_db, ``(lookup (e, "name", "") == module_name)), ``(lookup (c, "cards", [])));
            ret = filter (`e, ret, ``(size(e) > 0));

            if (size (ret) == 0)
            {
                ret = add (ret, [module_name]);
            }
        }
        return sort(flatten(ret));
    }

    /**
     * Itemize list for selection box
     * @param l list with values
     * @param default value to select as default
     * @return list
     */
    global define itemize_list (list l, integer default) ``{
        integer i = 0;
        list itemized_list = [];
        integer s = size (l);
        while (i < s)
        {
            itemized_list = add (itemized_list, `item (`id(i), select (l, i), (i == default)));
            i = i + 1;
        }
        return itemized_list;
    };



    /**
     * Returns list of keys read from /var/lib/YaST/unique.inf
     * @return list with unique keys
     */

    global define read_unique_keys () ``{
	list already = [];
	if (SCR::Read(.target.size, "/var/lib/YaST/unique.inf") > 0)
	{
	    already = SCR::Read(.var.lib.yast.unique);
	}
	else
	{
	    already = [];
	}
	// select the sound section

	list output = [];

	already = filter(`e, already, ``(lookup(e, "section", "") == "sound"));
	if (size(already) == 0) return [];
	already = lookup(select(already, 0), "contents", []);
	already = maplist(`e, already, 
	``{
	    if (lookup(e, "state", "") == "configured")
	    {
		output = add(output, lookup(e, "unique", ""));
	    }
	}

	);

	already = output;

	return already;
    }

    /**
     *	show a warning popup for nm256 snd cards if needed
     *  @param modname string module name
     *  @return boolean
     */

    global define nm256hack (string modname) ``{
        if (modname == "snd-card-nm256")
        {
            // special warning message for in a special case
            string warn_text = lookup(STRINGS, "nm256hackWarning", "");
	    return UI::YesNoPopup(warn_text);
        }
        return true;
    }



    /** 
     * returns list of detected soundcards
     *
     * return example:
     *          [       
     *          "bus"           : "PCI",
     *          "device"        : "ES1371 [AudioPCI-97]",
     *          "device_id"     : 70513,
     *          "resource"      : $["io":[$["active":true, "length":0, "mode":"rw", "start":28672]],
     *                             "irq":[$["count":0, "enabled":true, "irq":10]]],
     *          "rev"           : "6",
     *          "sub_device"    : "Creative Sound Blaster AudioPCI64V, AudioPCI128",
     *          "sub_device_id" : 70513,
     *          "sub_vendor"    : "Ensoniq",
     *          "sub_vendor_id" : 70260,
     *          "vendor"        : "Ensoniq",
     *          "vendor_id"     : 70260,
     *          "unique_key"    : "test.test",
     *          "module"        : $["name":"eps23"]]
     *          ]
     */

    global define get_audio() ``{
        string tmpdir = SCR::Read (.target.tmpdir);
        if (SCR::Read(.target.size, tmpdir+"/audio.ycp") != -1) // fileexist(tmpdir+"/audio.ycp"))
        {
            return SCR::Read(.target.ycp, tmpdir+"/audio.ycp");
        }

        list ret = SCR::Read(.probe.sound);
        if (ret == nil) ret = [];
        SCR::Write(.target.ycp, tmpdir + "/audio.ycp", ret);
        return ret;
    }


    /**
     * Looks up in the database for the module
     * @param card map read from .probe.sound
     * @return map
     */
    global define get_module (map card) ``{
	read_db();

	string bus        = lookup (card, "bus", "");
	integer offset    = (tolower (bus) == "isa") ? 0x20000 : 0x10000;
	integer vendor_id = lookup (card, "vendor_id", 0);
	integer device_id = lookup (card, "device_id", 0);

	list fc = [];
	if (tolower (bus) == "pci") 
	{
	    fc = filter (`d, sound_db, 
		 ``(filter(`c, lookup (d, "libhd", []), 
		    ``((lookup (c, "vendor_id", 0) == vendor_id - offset) && 
		       (contains(lookup(c, "device_id", 0), device_id - offset)))) != []));
	}
	else 
	{
	    fc = filter (`d, sound_db, 
		   ``(filter(`c, lookup (d, "libhd", []), 
			``((lookup (c, "vendor_id", 0) == vendor_id - offset) &&
			   (lookup (c, "device_id", 0) == device_id - offset))) != []));
	}

	if (fc != nil)
	{
	    if (size (fc) > 0) return select (fc, 0);
	}

	return $[];
    }

    /**
     * umnute channel 'devide' of the 'card_id'-th sound card. alsa only
     * @param devices list of channels to be unmuted
     * @param card_id of the card
     * @return void
     */

    global define unmute(list devices, integer card_id) ``{
	list avail = SCR::Dir(topath(sformat(".audio.alsa.cards.%1.channels", card_id)));
	if (avail == nil || size(avail)==0)
	{
	    avail = [];
	}
	foreach(`dev, devices,
	``{
	    if (contains(avail, dev))
	    {
		SCR::Write(topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", card_id, dev)), false);
	    }
	});
    }

    /**
     * stores the volume to file. stored volume will be 
     * restored after reboot
     * @param card_id 
     *
     */

    global define storeVolume(integer card_id) ``{
	if (card_id == -1)
	{
	    SCR::Execute(.audio.alsa.store, 0, 0);
	}   
	string p = sformat(".audio.alsa.cards.%1.store", card_id);

	SCR::Execute(topath(p), 0, 0);
    }


    /**
     *  Checks whether the module has been successfully loaded
     *
     * @param save_entry card config map
     * @param card_id
     * @return empty string on success/ error message on failure
     */ 

    global define check_module(map save_entry, integer card_id) ``{
	// TODO: check by /proc/asound/cards
	map pm = SCR::Read(.proc.modules);
	string mod_name=lookup(save_entry, "module", "off");
        if (!haskey (pm, mod_name) || size(get_running_cards()) <= card_id)
        {

                // To translators: label to error popup
            return sformat (_("The kernel module %1 for sound support
could not be loaded. This can be caused by incorrect
module parameters, including invalid IO or IRQ parameters."), mod_name);
        }
        return "";

    }


    /** creates itemized table entries,
     *  @param lm list of maps to take keys from
     *  @param lk list of keys to look for in 1st param
     * 
     *  @return list
     */

    global define create_table (list lm, list lk)
    ``{
	list res = [];
	integer pos = 0;
	foreach(`m, lm, 
	``{
	    res = add(res, `item(`id(pos), 
		lookup(m, select(lk, 0), ""),
		lookup(m, select(lk, 1), ""),
		lookup(m, select(lk, 2), "")
		));
	    pos = pos + 1;
	});
	return res;
    }

    /** 
     * tries to extract list of values from description
     * these values are generated from alsa modules
     * and can be in form
     * [list=value,value,..] or
     * [range=1-19] or something not recognized
     * @param des string 
     * @return list
     */
    global define parse_values (string des) ``{
        list ret = [];
        integer pos = 0;
        integer len = size (des);
        while ((pos < len) && (substring (des, pos, 1) != "["))
        {
            pos = pos + 1;
        }
        pos = pos + 1;

        if (pos < len)          // found "["
        {
            if (tolower(substring (des, pos, 5)) == "list=")
            {
                pos = pos + 5;
                integer s = pos;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == ",")
                    {
                        ret = add (ret, hextoi (substring (des, s, pos - s)));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                ret = add (ret, hextoi (substring (des, s, pos - s)));
            }
            else if (tolower(substring (des, pos, 6)) == "range=")
            {
                pos = pos + 6;
                integer s = pos;
                integer range_start = 0;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == "-")
                    {
                        range_start = tointeger(substring (des, s, pos - s));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                integer range_stop = tointeger(substring (des, s, pos - s));
                                        // now create the range list
                while (range_start <= range_stop)
                {
                    ret = add (ret, range_start);
                    range_start = range_start + 1;
                }
            }
	    else if (tolower(substring (des, pos, 4)) == "bool")
            {
                ret = [0, 1];
            }
        }

        return ret;
    }
 
  /**
   * "sformates" list from sound database, where are localized messages, with 
   * optional formating information
   * @param msg message to be formated
   * @return string
   * @example mysformat(["Message %1 %2 %3", "A", "B", "C"])  ->  "Message A B C"
   */
    global define mysformat (list msg)
    ``{
        if (size (msg) == 0)
        {
            return "";
        }

//        term format = ``(sformat (select(msg, 0)));
	term format=``(sformat());

        integer i = 0;
        while (i < size (msg))
        {
            format = add (format, select (msg, i));
            i = i + 1;
        }
        return eval (format);
    }

    /**
     * checks whether param #1 is if type of param #2
     * @param value
     * @param type expected type. one of {int, string}
     * @param poss if poss is nonempty, checks if value is one of them
     * returns error message, empty string if ok
     * @return string
     */
    global define check_value (string value, string type, list poss) ``{
        if (type == "int")
        {
            if (tolower(substring (value, 0, 2)) == "0x")               // hex number
            {
                string rest = tolower(substring (value, 2));
                if (filterchars(rest, "0123456789abcdef") != rest)
                {
                      // To translators: popup message, wrong value
                      return sformat (_("The value: %1 must be a number"), value);
                }
            }
            else                // decimal number
            {
                string rest = value;
                if (substring (value, 0, 1) == "-")      // negative number
                {
                    rest = substring (value, 1);
                }
                if (filterchars(rest, "0123456789") != rest)
                {
                            // To translators: popup message, wrong value
                    return sformat (_("The value: %1 must be a number"), value);
                }
            }
        }
        else if (type == "string")
        {
            if (filterchars (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789") != value)
            {

                integer wrong_pos = findfirstnotof (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789");
                string wrong_char = substring (value, wrong_pos, 1);
                if (wrong_char == " ")
                {
                                        // To translators: "space" means blank character
                    wrong_char = wrong_char + " " + _("(space)");
                }
                        // To translators: popup message, wrong value
                return  sformat (_("String cannot contain: %1"), wrong_char);
            }
        }

                                    // now check for poss list
        if (size (poss) > 0)
        {
            list poss_list = [];

            if (type == "int")
            {
                poss_list = maplist (`v, poss, ``(hextoi (value) == v));
            }
            else
            {
                poss_list = maplist (`v, poss, ``(value == v));
            }

            if (!contains (poss_list, true))
            {
                      // To translators: popup message, wrong value
                return sformat (_("The value must be one of %1"), poss);
            }
        }

        return "";              // ok :-)

    }

    /**
     * inserts values to already set options
     * @param params list with available options for module
     * @param values values that have been already set 
     * @return map with refreshed options
     *
     */

    global define restore_mod_params(list params, map values) ``{
	return maplist(`e, params,
	``{
	    string pname = lookup(e, "name", "");
	    e = add(e, "value", lookup(values, pname, ""));
	    return e;
	});

    }
 
    /** get_tmp_modules_conf returns path to the temporary modules.conf
     * @return 
     */
    
    global define get_tmp_modules_conf() ``{
	string tmpdir = SCR::Read (.target.tmpdir);
	// TODO: move this file to yast tmp dir
	return "/tmp/modules.conf";
    }

    /** 
     *  checks whether sound fonts have already been installed
     *	@return boolean
     *	
     */

    global define FontsInstalled() ``{
	return SCR::Read(.target.size, "/usr/share/sfbank/creative") >= 0; // fileexist("/usr/share/sfbank/creative");
    }

    /** @return true if the sound card supports sound fonts
     * @param save_entry
     */

    global define HasFonts(map save_entry) ``{
	if (contains(["snd-card-emu10k1", "snd-card-sbawe", "emu10k1"], lookup(save_entry, "module", "")))
	{
	    return true;
	}
	return false;
    }

    /** this small wizard will install sound fonts for soundblaster live/awe
     *  @param symlink is path to default.sf2 that is to be created
     *  @param dontask if true, skip the first messagebox
     */

    global define InstallFonts(string symlink, boolean dontask) ``{
	boolean answer = false;

	// step 1: want install?
	if (dontask)
	{   
	    answer = true;
	}
	else
	{
	    answer = UI::YesNoHeadlinePopup(	lookup(STRINGS, "soundFontTitle", ""), 
					lookup(STRINGS, "soundFontQuestion", ""));
	}
	
	if (!answer) 
	{
	    return;
	}

	boolean succes = false;

	while (true)
	{
    		// step 2: insert CD
	    answer = UI::ContinueCancelHeadlinePopup (lookup(STRINGS, "soundFontTitle", ""), 
						    lookup(STRINGS, "soundFontAppeal", ""));
	    if (!answer)
	    {
		return;
	    }

	    // step3: do something 
	    map res = SCR::Execute (.target.bash_output, "/usr/lib/YaST2/bin/copyfonts 2>/dev/null", $[] );
	    integer cnt = tointeger(lookup(res, "stdout", 0));
	    
	    // step4: 
	    if (cnt > 0)
	    {
		UI::MessagePopup(sformat(lookup(STRINGS, "soundFontFinal", ""), cnt, "/usr/share/sfbank/creative"));
		return;
	    }
	    else
	    {
		answer = UI::YesNoHeadlinePopup(  lookup(STRINGS, "soundFontNotFound", ""),
						lookup(STRINGS, "soundFontRetry", ""));
		if ( !answer )
		{
		    return;
		}
	    }
    
	}
    }

    /**
     * shows warning message when both nm265 and opl3sa2 cards are present
     * @param sound_cards list of sound cards
     */
    
    global define nm256_opl3sa2_warn(list sound_cards) ``{
	list s1 = filter(`e, sound_cards, 
	    ``(lookup(e, "module", "") == "snd-card-nm256"));
	list s2 = filter(`e, sound_cards, 
	    ``(lookup(e, "module", "") == "snd-card-opl3sa2"));

	if (size(s1) > 0 && size(s2) > 0)
	{
	    string name1 = lookup(select(s1, 0), "model", "");
	    string name2 = lookup(select(s2, 0), "model", "");
	    UI::LongTextPopup("",
		`RichText("<p>"+sformat(lookup(STRINGS, "opl3sa_nm256_warn", ""), name1, name2)+"</p>"),
		50, 12);
	}
    }

    
    /**
     *	when user wants to delete a card, all cards using given module must be removed.
     *  this function returns list of positions of cards using the module
     *  @param	save_info all cards' donfiguration
     *	@param	mod_name module name
     *  @param  card_id id of currently removed card
     *  @return list of integers
     */

    global define get_indices_for_removal(list save_info, string mod_name, integer card_id)
    ``{
	list ret = [];
	boolean remove_all = false;
	integer pos = 0;
	maplist(`e, save_info, 
	``{  
	    if (lookup(e, "module", "") == mod_name)
	    {
		ret = add(ret, pos);
	    }
	    else
	    {
		if (size(ret) > 0)
		{
		    remove_all = true;
		}   
	    }
	    pos = pos + 1;
	});
	if (!remove_all)
	{
	    return [card_id];
	}
	return ret;
    }

    /**
     * remove memebers listed in id_list list
     * @param input 
     * @param id_list 
     * @return list modified list
     *
     */

    global define multi_remove(list input, list id_list) ``{
	id_list = sort(`x, `y, id_list, ``(x >= y));
	maplist(`e, id_list, ``{if (e < size(input)) input = remove(input, e); });
	return input;
    }

    /**
     * removes entries from save_info listed by indices in id_list 
     * @param save_info list
     * @param id_list list of id's to be removed
     * @return new save_info
     */

    global define remove_save_entries(list save_info, list id_list)
    ``{
	save_info = multi_remove(save_info, id_list);

	integer pos = 0;
	save_info = maplist(`e, save_info, 
	``{
	    map opts = lookup(e, "options", $[]);
//	    opts = add(opts, "snd_index", sformat("%1", pos));
//	    opts = add(opts, "snd_id", sformat("card%1", pos + 1));
	    e = add_alias(e, pos);
	    e = add_common_options(e, pos);
//	    e = add(e, "alias", sformat("snd-card-%1", pos));
//	    e = add(e, "options", opts);
	    pos = pos + 1;
	    return e;
	});
	return save_info;
    }

    /**
     * stops all programs using sound devices
     * @return true if nothing's using sound, false otherwise
     *
     */

    global define stop_programs() ``{
	integer fuser = SCR::Execute (.target.bash, "/bin/fuser /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]);

	if (fuser == 0)
        {
                  // To translators: To reset the sound configuration these programs must be terminated
                  // To translators: label message
	    string msg = lookup(STRINGS, "WhichDialogMsg", "");
                  // Yes, No - button labels
            boolean terminate = UI::YesNoPopup (msg);
            if (terminate)
            {
		SCR::Execute (.target.bash, "/bin/fuser -k /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]);
            }
            else
            {
		return false;
            }
        }
	return true;
    }
    
    /**
     * creates hardware-summary-like list of configured cards
     *
     * @return richtext
     * @param save_info
     */

    global define ConfCardsRT(list save_info) ``{
	list retlist = [];
	list conflist = [];
	foreach(`entry, save_info,
	``{
	    conflist = add(conflist, lookup(entry, "model", ""));
	});
	integer i = 0;
	foreach(`card, conflist,
	``{
	    // to translators: '(sound card is) Configured as snd-card-1'
	    retlist = add(retlist, summaryDevice(card, sformat(_("Configured as snd-card-%1."), i)));
	    i = i + 1;
	});

	return summaryDevicesList(retlist);

    }

}

