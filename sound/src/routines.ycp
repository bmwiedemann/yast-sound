/**
 * File:
 *   routines.ycp
 * 
 * Module:
 *   Sound
 * 
 * Summary:
 *   Routines for sound card configuration
 * 
 * Authors:
 *   Dan Veselý <dan@suse.cz>
 *
 * $Id$
 *
 */


{

    textdomain "sound";
    include "misc_defines.ycp";
    include "lan/lan_routines.ycp";
    include "browser.ycp";

// !!!!!!!!!!!!!!!Hack!!!!!!!!!!!!!!!!!!!!

define isnil(any a)
``{ return false; }

  /**
   * reads variables listed in 'vars' from rc.config
   * @return list
   */
    global define read_rc_vars (list vars) ``{
        return listmap (`k, vars, ``([k, SCR(`Read(topath(sformat (".rc.system.%1", k))))]));
    }

    

    /**
     *  Converts hex num to integer keeps decimal number as is. Hexadecimal
     *  number assumes to have prefix ``0x''. Doesn't  check the syntax.
     *
     */

    global define hextoi(string num) ``{
	return tointeger(num);
    }

    /**
     *  writes unique keys of the configured cards to /var/lib/YaST/unique.inf
     *  @param list of maps
     *  @return void
     *  
     *
     */

    global define save_unique_keys (list cards, list configured_unique) ``{
        list orig = SCR(`Read(.var.lib.yast.unique));
	y2error(sformat("uniques   %1", orig));
        if (isnil(orig))
        {
            orig = [];
        }
        list sound_unique = maplist (`e, configured_unique, ``($["unique" : e, "state" : "configured"]));
        orig = filter (`e, orig, ``(lookup(e, "section", "") != "sound"));
	list final=add (orig, $["contents" : sound_unique, "section" : "sound"]);
	y2error(sformat("uniques    %1", final));
        SCR(`Write(.var.lib.yast.unique, final));
    }


    /**
     * Reads /proc/asound/cards and removes entries form save_info with no corresponding entry in /proc/asound/cards
     *
     * @param list save_info
     * @return list modified list of save_info
     */

    global define remove_invalid_save_info(list save_info) ``{
	list cards=nil;
	if(fileexist("/proc/asound/cards"))
	{
	    cards = SCR(`Read(.proc.asound.cards));
/*            if (is(select (asound, 0), map))
            {
                return asound;
            }
*/ 
	    return save_info;
	}
	// no /proc/asound/cards exists -> no cards configured
	return [];
    }

    /**
     * returns sound card database
     * @return list
     */

    global define GetCardDatabase() ``{
	any database=SCR(`Read (.target.yast2, "sndcards.ycp"));
	textdomain "sound_db";
	database = UI (database);
	textdomain "sound";
	return database;
    }

    /**
     * Used for searching. returns index of the card in the database identified by name
     * @return integer
     */

    global define search_card_id (string name) ``{
        list all_cards = get_cards ("all");
        integer pos = 0;
        integer len = size (name);
	name = tolower(name);
	integer bound = size (all_cards);
        while (pos < bound)
        {
            if (substring (tolower(select (all_cards, pos)), 0, len) == name)
            {
                return pos;
            }
            pos = pos + 1;
        };
        return -1;
    }

    /**
     * creates "libhd entry" from db info
     * @return map
     */
    /* !!! variable db is inherited from module sound.ycp*/
    global define get_card (string module_name, string card_name) ``{
        map ret = $[];
        map db_entry = $[];

        if (module_name == UI(_("All")))
        {
            list tmp = filter (`e, db, ``(contains(lookup (e, "cards"), card_name)));
            if (size (tmp) > 0)
            {
                db_entry = select (tmp, 0);
            }
            else
            {
                db_entry = select (filter (`e, db, ``(lookup (e, "name", "") == card_name)), 0, $[]);
            }
        }
        else
        {
            db_entry = select (filter (`e, db, ``(lookup (e, "name", "") == module_name)), 0, $[]);
        }



        if (size (db_entry) == 0)
        {
            y2error ("Db entry not found");
            return ret;
        }

        map module_entry = $["params" : lookup (db_entry, "params", []),
                            "module"  : lookup (db_entry, "module", $[])];

        ret = add (ret, "module", module_entry);
        ret = add (ret, "sub_vendor", card_name);
        if (tolower (module_name) == "all")
        {
            ret = add (ret, "sub_device", sformat ("(%1)", card_name));
        }
        else
        {
            ret = add (ret, "sub_device", sformat ("(%1)", module_name));
        }
        map libhd = select (lookup (db_entry, "libhd", []), 0, $[]);
        ret = add (ret, "vendor_id", lookup (libhd, "vendor_id", 0));

        if (is (lookup (libhd, "device_id"), list))
        {
            ret = add (ret, "device_id", select (lookup (libhd, "device_id", 0), 0));
            ret = add (ret, "bus", "PCI");
        }
        else
        {
            ret = add (ret, "device_id", lookup (libhd, "device_id", 0));
            ret = add (ret, "bus", "ISA");
        }
        return ret;
    }

    /**
     * returns list of sound cards. get_cards("all") returns all cards
     * @return list
     */

    /* !!! variable cards is inherited from module sound_manual.ycp*/
    global define get_cards (string module_name) ``{
        list ret = [];

        if (tolower(module_name) == "all")
        {	// copy the whole database
        maplist (`e, db,
            ``{
                if (size (lookup (e, cards)) > 0) ret = add (ret, lookup (e, cards));
                else ret = add (ret, [lookup (e, "name")]);
            });
        }
        else
        {	// filter by name 
            ret = maplist (`c, filter (`e, db, ``(lookup (e, "name", "") == module_name)), ``(lookup (c, "cards", [])));
            ret = filter (`e, ret, ``(size(e) > 0));

            if (size (ret) == 0)
            {
                ret = add (ret, [module_name]);
            }
        }
        return sort(flatten(ret));
    }

    /**
     * Itemize list for selection box
     * @return list
     */
    global define itemize_list (list l, integer default) ``{
        integer i = 0;
        list itemized_list = [];
        integer s = size (l);
        while (i < s)
        {
            itemized_list = add (itemized_list, `item (`id(i), select (l, i), (i == default)));
            i = i + 1;
        }
        return itemized_list;
    };



    /**
     *  Returns list of already running cards
     *  @return list
     *  
     *
     */

    global define get_running_cards () ``{
        if (fileexist("/proc/asound/cards"))
        {
            list asound = SCR(`Read(.proc.asound.cards));
            if (is(select (asound, 0), map))
            {
                return asound;
            }
        }
        return [];
    }

/*    define get_configured_cards () ``{
	list keys = read_unique_keys ();
	list res  = maplist(`l, keys, ``$);

	return res;
    }
*/

    /**
     * Returns list of keys read from /var/lib/YaST/unique.inf
     * @return list with unique keys
     */

    global define read_unique_keys () ``{
	list already = [];
	if (SCR(`Read(.target.size, "/var/lib/YaST/unique.inf")) > 0)
	{
	    already = SCR (`Read(.var.lib.yast.unique));
	}
	else
	{
	    already = [];
	}
	already = maplist (`k, lookup (select (filter (`e, already, ``(lookup (e, "section") == "sound")), 0, $[]), "contents", []),
                           ``(lookup (k, "unique")));	
	return already;
    }

    /**
     *  @return boolean
     *  
     *
     */

    global define nm256hack (map card) ``{
        string module_name = "";
        if (!haskey(card, "module"))
        {
            module_name = lookup(get_module (card), "name", "");
        }
        else
        {
            module_name = lookup (lookup(lookup (card, "module", $[]), "module", ""), "name", "");
        }
        if (module_name == "snd-card-nm256")
        {
            // special warning message for in a special case
            string warn_text=lookup(STRINGS, "nm256hackWarning");
//          return UI(`WarnDialog (warn_text));
	    return UI(`YesNoPopup(warn_text));
        }
        return true;
    }




    /**
     * same as  ()?():(); statement in c
     * @return any
     */
    global define condition (boolean c, any s1, any s2) ``{
	if (c) 
	{ 
	    return eval (s1);
	}
	else
	{
	    return eval (s2);
	}
    };


    /**
     * Simply returns list with ALSA OSS/Free emulation modules
     * Params: "number" ... number of sound cards
     * @return list
     */
    global define alsa_oss (integer number) ``{
	list modules = [];
	integer i = 0;
	// map with minor as a key and module as value
	map oss_list = $[		
	    0  : "snd-mixer-oss",
	    11 : "snd-mixer-oss",
	    3  : "snd-pcm-oss",
	    12 : "snd-pcm-oss",
	    1  : "snd-seq-oss",
	    8  : "snd-seq-oss"
	    ];
	
	while (i < number) 
	{
	    modules = add (modules, $["name"   : sformat ("snd-card-%1", i),
				      "modules" : $["alias" : sformat ("sound-slot-%1", i)]]);

	    modules = union (modules, maplist (`minor, `mod, oss_list, ``(
		$["name"   : sformat ("%1", mod),
		  "modules" : $["alias" : sformat ("sound-service-%1-%2", i, minor)]])));

	    i = i + 1;
	}   
	return modules;
    }


    /**
     * This is no alsa hack function
     * @return map
     */
    global define no_alsa (string mod_name) ``{
	return $[
	    "modules" : [
		$["name"   : mod_name,
		 "modules" : $["alias" :  "char-major-14"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "sound"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "midi"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "sound-slot-0"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "sound-service-0-0"]]	    
		],
	    "volume" : $[
		"mixer" : "/usr/bin/aumix \"$CHANNEL\" $VOLUME"
		]
	    ];
    }

    /**
     * simply gets detected audio. 
     * @return map
     */
    global define get_audio (boolean test_mode, boolean config_mode) ``{
	if (!test_mode && !config_mode) 
	{
	    list ret = SCR(`Read(.probe.sound));
	    if (isnil (ret)) ret = [];
	    return ret;
	}
	return [$["baseclass"    : "Multimedia controller", 
		 "bus"           : "PCI", 
		 "device"        : "ES1371 [AudioPCI-97]", 
		 "device_id"     : 70513, 
		 "resource"      : $["io":[$["active":true, "length":0, "mode":"rw", "start":28672]], 
				    "irq":[$["count":0, "enabled":true, "irq":10]]], 
		 "rev"           : "6", 
		 "sub_device"    : "Creative Sound Blaster AudioPCI64V, AudioPCI128", 
		 "sub_device_id" : 70513, 
		 "sub_vendor"    : "Ensoniq", 
		 "sub_vendor_id" : 70260, 
		 "subclass"      : "Multimedia audio controller", 
		 "vendor"        : "Ensoniq", 
		 "vendor_id"     : 70260,
		 "unique_key"    : "test.test"],
	  $["baseclass"    : "Multimedia controller", 
	   "bus"           : "PCI", 
	   "device"        : "ES1371 [AudioPCI-97]", 
	   "device_id"     : 98309, 
	   "resource"      : $["io":[$["active":true, "length":0, "mode":"rw", "start":28672]], 
			    "irq":[$["count":0, "enabled":true, "irq":10]]], 
	   "rev"           : "6", 
	   "sub_device"    : "Creative Sound Blaster AudioPCI64V, AudioPCI128", 
	   "sub_device_id" : 70513, 
	   "sub_vendor"    : "Ensoniq", 
	   "sub_vendor_id" : 70260, 
	   "subclass"      : "Multimedia audio controller", 
	   "vendor"        : "Ensoniq", 
	   "vendor_id"     : 69832,
	   "unique_key"    : "test2.test2"]];

  }

    /**
     * Looks up in the database for the module
     * @return map
     */
    global define get_module (map card) ``{
	if (db == nil)
	{
	    return $[];
	}

	string bus        = lookup (card, "bus");
	integer offset    = condition ((tolower (bus) == "isa"), 0x20000, 0x10000);
	integer vendor_id = lookup (card, "vendor_id", 0);
	integer device_id = lookup (card, "device_id", 0);

	list fc = [];
	
	if (tolower (bus) == "pci") 
	{
	    fc = filter (`d, db, 
			 ``(filter(`c, lookup (d, "libhd"), ``((lookup (c, "vendor_id") == vendor_id - offset) && 
							       (contains(lookup(c, "device_id"), device_id - offset)))) != []));
	}
	else 
	{
	    fc = filter (`d, db, 
		   ``(filter(`c, lookup (d, "libhd"), ``((lookup (c, "vendor_id") == vendor_id - offset) &&
							 (lookup (c, "device_id") == device_id - offset))) != []));
	}
	if (!isnil(fc))
	{
	    if (size (fc) > 0) return select (fc, 0);
	}
	return $[];
    }

    /**
     * Use another module than alsa
     * @return boolean
     */
    global define no_alsa_exception (map card, boolean config_mode) ``{
	if (!config_mode)
	{
	    return MacRisc ();
	}
	return false;
    }

    /**
     * true if system is MacRISC
     * @return boolean
     */

    global define MacRisc () ``{
	if (lookup (select (SCR(`Read(.probe.system)), 0), "system") == "MacRISC")
	{
	    return true;
	}
	return false;
    }

    /**
     * Creates save information based on card map return by libhd
     * First list of exceptions is processed (has two keys : "try" with function to 
     * provide test and "handle" with function to handle (return) the corrected result
     * otherwise vendor_id, device_id search in sound db is run
     *
     * @return map
     */
    global define create_save_info (map card, integer card_id) ``{
	list except_list = []; //[$["try" : ``(MacRisc ()), "handle" : ``(mac_risc ())]];
	integer exp_id = 0;
	
	while (exp_id < size (except_list))
	{
	      if (eval(lookup(select (except_list, exp_id), "try")))
	      {
		  return eval(lookup(select (except_list, exp_id), "handle"));
	      }
	      exp_id = exp_id + 1;
	}

	// no exceptions, normal way ...


	map mod     = $[];
	if (haskey (card, "module"))
	{
	    mod = lookup (card, "module");
	}
	else
	{
	    mod = get_module (card);
	}

	list params = filter (`e, lookup (lookup (card, "module", $[]), "params", []), ``(size (lookup (e, "value")) > 0));
	map options = listmap (`e, params, ``([lookup (e, "name", ""), lookup (e, "value", "")]));

	if (lookup (lookup (mod, "module", $[]), "name" , "off") != "off") 
	{
	    options = add (options, "snd_id", sformat ("card%1", card_id + 1));
	    options = add (options, "snd_index", sformat ("%1", card_id));
	}

	return $["name"   : lookup (lookup (mod, "module", $[]), "name" , "off"),
		"modules" : $["alias"  : sformat ("snd-card-%1", card_id),
			     "options" : options]];
    }

    /**
     * command must be string with $CHANNEL and $VALUE included
     * @return any
     */
    global define SetVolume (string command, string channel, string value, integer card_num) ``{
	return SCR(`Execute (.target.bash, command, $["CHANNEL" : channel, "VOLUME" : value, "CARD_NUM" : card_num]));
    }

    /**
     * reads already saved info from modules.conf
     * @return list 
     */
    global define read_save_info () ``{
	string prefix = "";
	list aliases  = SCR(`Read(topath (sformat ("%1.modules.alias", prefix))));
	list options  = SCR(`Read(topath (sformat ("%1.modules.options", prefix))));
	list save     = [];		// structure to save
	integer i     = 0;

	if (contains (aliases, "char-major-116")) 
	{
	      // alsa modules
	      
	      
	    if (SCR(`Read(topath(sformat ("%1.modules.alias", prefix)), "char-major-116")) == "snd") 
	    {
		list minor_list = [0, 1, 3, 8, 11, 12];		
		integer cards   = tointeger (lookup (SCR(`Read(topath (sformat ("%1.modules.options", prefix)), "snd")), "snd_cards_limit", 1));
		map entry       = $[];
		map mod_entry   = $[];

		string alias    = "";
		string module_name   = "";
		string comment  = "";

		    // read the cards
		while (i < cards) 
		{

			  // == snd-card-X ==
		    entry = $[];
		    alias = sformat ("snd-card-%1", i);

		    if (!contains(aliases, alias)) 
		    {
			i = i + 1; continue; // not found
		    }
			  
		    module_name  = SCR(`Read(topath (sformat ("%1.modules.alias", prefix)), alias));
		    if ((module_name == "off") || (module_name == "null")) 
		    { 
			i = i + 1; continue; 
		    }
		    comment = SCR(`Read(topath (sformat ("%1.modules.alias.comment", prefix)), alias));

		    entry = add (entry, "name", module_name);
		    mod_entry = add (mod_entry, "alias", alias);
		    if (contains (options, module_name)) 
		    {
			mod_entry = add (mod_entry, "options", SCR(`Read(topath (sformat ("%1.modules.options", prefix)), module_name)));
		    }
		    if (size (comment) > 0) 
		    {
			entry = add (entry, "comment", comment);
		    }
			  
		    entry = add (entry, "modules", mod_entry);
		    save = add (save, entry);

		    i = i + 1;
		}
	    }
	}
	else if (contains (aliases, "char-major-14")) 
	{
	      // oss (poor support, should be enhanced ... )
	      
	      // list of aliases to be read
	    list local_aliases = ["char-major-14",
				  "sound",
				  "midi",
				  "sound-slot-0",
				  "sound-service-0-0"];

	    map entry      = $[];
	    map option     = $[];
	    string module_name  = "";
	    string comment = "";
	      
	    maplist (`alias, local_aliases, 
	      ``{
		if (contains (aliases, alias)) 
		{
		    entry   = $[];
		    module_name  = SCR (`Read(topath (sformat ("%1.modules.alias", prefix)), alias));
		    comment = SCR (`Read(topath (sformat ("%1.modules.alias.comment", prefix)), alias));
		    if (contains (options, module_name)) 
		    {
			option = SCR (`Read(topath (sformat ("%1.modules.options", prefix)), module_name));
		    }
		    else 
		    {
			option = $[];
		    }

		    if ((module_name != "off") && (module_name != "null")) 
		    {
			if (size (module_name) > 0) 
			{
			    entry = add (entry, "alias", alias);
			    entry = add (entry, "name", module_name);
			    if (size (option) > 0) 
			    {
				entry = add (entry, "options", option);
			    }
			    if (size (comment) > 0) 
			    {
				entry = add (entry, "comment", comment);
			    }
			}
		    }
		    if (size (entry) > 0) 
		    {
			save = add (save, entry);
		    }
		}
	      });
	}
	return save;
    }
    
    /**
     * here the test sound is played, by
     * default ist alsa whistle sound, but
     * if snd_au package is installed,
     * than it's Linus Torvals voice, the
     * if the test file cannot be found,
     * the message is displayed
     *
     * @return string returns empty string on succes, otherwise error string 
     */

    global define PlayTest (map user_settings, integer card_id) ``{

        if (!fileexist(lookup (user_settings, "audio_file")))
        {
            string file = lookup (user_settings, "audio_file");

                  // To translators: just one file will be displayed
                  // To translators: if the test audio file can not be found this message is displayed
                  // To translators: This is just popup message, shouldn't be too long
            string msg = sformat (UI (_("Cannot find file:\n %1\n\n(test audio file)")), file);

            return msg;
        }
        else
        {
            string play_cmd = lookup (user_settings, "play_cmd", "");
            string audio_file = lookup (user_settings, "audio_file", "");
                  // more cards
            if (no_alsa)
            {
                Shell(sformat("%1 %2 &", play_cmd, audio_file), $[]);
            }
            else
            {
                Shell(sformat("%1 -c %2 %3 &", play_cmd, card_id, audio_file), $[]);
            }
        }
        return "";
    };

        /**
     * tries to insert module with options (if any)
     * @return string with error message (empty string if ok)
     */

    global define probe_module (map card, map user_settings) ``{

        string module_name    = lookup (lookup (card, "module", $[]), "name", "");
        list params           = filter (`e, lookup (lookup (card, "module", $[]), "params", []), ``(size (lookup (e, "value")) > 0));
        string module_options = mergestring (maplist (`e, params, ``(sformat("%1=%2", lookup (e, "name", ""), lookup (e, "value", "")))), " ");
        boolean probe         = lookup (lookup (card, "module", $[]), "modprobe", true);
        boolean mod_active    = lookup (lookup (card, "module", $[]), "active", false);

        if (size (module_name) == 0)
        {
                // To translators: error message
            return UI(_("Invalid module name."));
        }

        SCR(`Execute (.target.bash, "/sbin/depmod -a -F /boot/System.map-`uname -r` `uname -r`", $[]));

        if (!mod_active)
        {
            if (!probe)
            {
                SCR (`Execute (.target.insmod, module_name, module_options));
            }
            else
            {
                SCR(`Execute (.target.modprobe, module_name, module_options));
            }
        }

        if (no_alsa)
        {
            user_settings = add (user_settings, "play_cmd", "/usr/bin/play");
            user_settings = add (user_settings, "mixer", "/usr/bin/aumix \"$CHANNEL\" $VOLUME");
        }
        else
        {
            SCR(`Execute (.target.modprobe, "snd-pcm-oss", "")); // backwards OSS compatibility
        }

        map pm = SCR(`Read(.proc.modules));

        if (!haskey (pm, module_name))
        {

                // To translators: label to error popup
            return sformat (UI(_("The kernel module %1 for sound support\ncould not be loaded.")), module_name);
        }
        return "";
    };

    /** creates itemized table entries,
     *  @param lm list of maps to take keys from
     *  @param lk list of keys to look for in 1st param
     * 
     *  @return list
     */

    global define create_table (list lm, list lk)
    ``{
        integer i = 0;
        list itemized_list = [];
        integer s = size (lm);
        term val = `item ();

        while (i < s)
        {
            val = `item (`id(i));
            foreach (`k, lk,
                ``{
                val = add (val, lookup (select (lm, i), k, ""));
                });

            itemized_list = add (itemized_list, val);
            i = i + 1;
        }

        return itemized_list;
    };

    /* 
     * tries to extract list of values from description
     * these values are generated from alsa modules
     * and can be in form
     * [list=value,value,..] or
     * [range=1-19] or something not recognized
     * @return list
     */
    global define parse_values (string des) ``{
        list ret = [];
        integer pos = 0;
        integer len = size (des);
        while ((pos < len) && (substring (des, pos, 1) != "["))
        {
            pos = pos + 1;
        }
        pos = pos + 1;

        if (pos < len)          // found "["
        {
            if (tolower(substring (des, pos, 5)) == "list=")
            {
                pos = pos + 5;
                integer s = pos;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == ",")
                    {
                        ret = add (ret, hextoi (substring (des, s, pos - s)));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                ret = add (ret, hextoi (substring (des, s, pos - s)));
            }
            else if (tolower(substring (des, pos, 6)) == "range=")
            {
                pos = pos + 6;
                integer s = pos;
                integer range_start = 0;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == "-")
                    {
                        range_start = tointeger(substring (des, s, pos - s));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                integer range_stop = tointeger(substring (des, s, pos - s));
                                        // now create the range list
                while (range_start <= range_stop)
                {
                    ret = add (ret, range_start);
                    range_start = range_start + 1;
                }
            }
	    else if (tolower(substring (des, pos, 4)) == "bool")
            {
                ret = [0, 1];
            }
        }

        return ret;
    }
 
  /**
   * "sformates" list from sound database, where are localized messages, with 
   * optional formating information
   * @return string
   * @example mysformat(["Message %1 %2 %3", "A", "B", "C"])  ->  "Message A B C"
   */
    global define mysformat (list msg)
    ``{
        if (size (msg) == 0)
        {
            return "";
        }

        integer i = 1;
        term format = ``(sformat (select(msg, 0)));

        while (i < size (msg))
        {
            format = add (format, select (msg, i));
            i = i + 1;
        }
        return eval (format);
    }

    /**
     * checks whether param #1 is if type of param #2
     * @param 1st value
     * @param 2nd expected type. one of {int, string}
     * @param 3nd if poss is nonempty, checks if value is one of them
     * returns error message, empty string if ok
     * @return string
     */
    global define check_value (string value, string type, list poss) ``{
        if (type == "int")
        {
            if (tolower(substring (value, 0, 2)) == "0x")               // hex number
            {
                string rest = tolower(substring (value, 2));
                if (filterchars(rest, "0123456789abcdef") != rest)
                {
                      // To translators: popup message, wrong value
                      return sformat (UI(_("The value: %1 must be a number")), value);
                }
            }
            else                // decimal number
            {
                string rest = value;
                if (substring (value, 0, 1) == "-")      // negative number
                {
                    rest = substring (value, 1);
                }
                if (filterchars(rest, "0123456789") != rest)
                {
                            // To translators: popup message, wrong value
                    return sformat (UI(_("The value: %1 must be a number")), value);
                }
            }
        }
        else if (type == "string")
        {
            if (filterchars (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789") != value)
            {

                integer wrong_pos = findfirstnotof (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789");
                string wrong_char = substring (value, wrong_pos, 1);
                if (wrong_char == " ")
                {
                                        // To translators: "space" means blank character
                    wrong_char = wrong_char + " " + UI(_("(space)"));
                }
                        // To translators: popup message, wrong value
                return  sformat (UI(_("String cannot contain: %1")), wrong_char);
            }
        }

                                    // now check for poss list
        if (size (poss) > 0)
        {
            list poss_list = [];

            if (type == "int")
            {
                poss_list = maplist (`v, poss, ``(hextoi (value) == v));
            }
            else
            {
                poss_list = maplist (`v, poss, ``(value == v));
            }

            if (!contains (poss_list, true))
            {
                      // To translators: popup message, wrong value
                return sformat (UI(_("The value must be one of %1")), poss);
            }
        }

        return "";              // ok :-)

    }

   /**
   * Detected, but not configured cards
   *
   * @return list
   */
    global define get_not_yet () ``{
        list all = get_audio (test_mode, config_mode);
        list not_yet = get_unique_not (all, ["configured"], "sound", false, config_mode);

        return not_yet;
    }

    /**
     * 
     *
     *
     *
     */    
    
    define InsertOptions(list optionList, map modifiedOptions) ``{
	integer i=0;
	integer iopt=0;
	list ret=[];
	map option=$[];
//	string value="";
	string optname="";
	while(i<size(optionList))
	{
	    option=select(optionList, i);
	    optname=lookup(option, "name");

/*	    while(iopt<size(modifiedOptions))
	    {
		if(lookup(select(modifiedOptions, iopt), "name")==optname)
		{
		    value=lookup(select(modifiedOptions, iopt), "value");
		    break;
		}
		iopt=iopt+1;
	    }
*/	    
	    ret=add(ret, add(option, "value", lookup(modifiedOptions, optname, "")));
	    i=i+1;
	}
	return ret;
    }    

    /**
     * inserts values to already set options
     * @param 1st card that is going to be modified
     * @param 2st save_info with card options
     *
     *
     */

    global define RestoreCardInfo(map card, list save_info) ``{
	card =  add (card, "module", get_module (card));

	string calias=lookup(lookup(lookup(card, "module", "") , "module", ""), "name", "");
	
	list save=filter(`s, save_info, ``(calias==lookup(s, "name", "")));

	if(size(save)==0)
	{
	    return card;
	}
	map save_opts=lookup(lookup(select(save, 0), "modules", []), "options", []);
	list options=lookup(lookup(card, "module", $[]), "params", []);   
 
	options=InsertOptions(options, save_opts);

	map newModule=lookup(card, "module");
	newModule=add(newModule, "params", options);
	card=add(card, "module", newModule);

	return card;
    }
   
}
