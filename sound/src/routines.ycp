/** File:
 *   routines.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Routines for sound card configuration
 *
 * Authors:
 *   Dan Veselý <dan@suse.cz>
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 */

{
    textdomain "sound";

    /**
     * common function to extract 'name' of hardware
     * @param hardware_entry map
     * @return string readable name of the card
     */

    global define string hardware_name (map hardware_entry) ``{
        string sub_vendor = "";
        string sub_device = "";

        sub_vendor = lookup (hardware_entry, "sub_vendor", "");
        sub_device = lookup (hardware_entry, "sub_device", "");

        if ((sub_vendor != "") && (sub_device != ""))
            return (sub_vendor + "\n" + sub_device);
        else
            return (lookup (hardware_entry, "vendor", "") + 
                    ((lookup (hardware_entry, "vendor", "") != "") ? "\n" : "") + 
                    lookup (hardware_entry, "device", ""));
    };


    /**
     * fliters out already configured cards
     * @param save_info info from modules.conf
     * @param cards autodetected cards
     * @return list of entries of not configured cards
     */

    global define list filter_configured(list save_info, list cards) ``{
        cards = filter(`e, cards,
        ``{
            string uniq     = lookup(e, "unique_key", "");
            boolean retval  = true;
            foreach(`s, save_info,
            ``{
                if (lookup(s, "unique_key", "") == uniq)
                {
                    retval = false;
                }
            });
            return retval;
        });
        return cards;
    }

    /**
     * returns the result of /usr/bin/whoami. currently broken. no idea why...
     * @return string username
     */

    global define string whoami() ``{
	string cmd = "/usr/bin/whoami";
	map ret = SCR::`Execute(.target.bash_output, cmd, $[]);
	string out = lookup(ret, "stdout", "");
	list l = splitstring(out, "\n");
	if (size(l) > 0)
	{
	    return select(l, 0, "dontknow");
	}
	return "";
    }

    /**
     * logtime- logs current time - used for performance
     * improvements. logs comment with current time
     * @param comment string
     * @return void
     */

    global define void logtime(string comment) ``{
	string s    = SCR::Read(.target.string, "/proc/uptime");
	list l	    = splitstring(s, " ");
	float f	    = tofloat(select(l, 0, ""));
	y2error("%1 %2 : %3", comment, select(l, 0, ""), f-oldf);
	oldf = f;
    }

    /**
     * for a given card detected by libhd this function creates a
     * label
     * @param card map entry from .probe.audio
     * @return string card label
     *
     */

    global define string get_card_label(map card)
    ``{
        list lab = splitstring(hardware_name(card),"\n");
	if (size(lab) == 0 )
	{
	    return "";
	}
        if (size(lab) == 1 || select(lab, 1, "") == "")
        {
            return select(lab, 0, "");
        }
        return select(lab, 1, "");
    }

    /**
     * returns true if given string is valid sound alias
     * (snd-card-1 .. snd-card-16)
     * @param alias string
     * @return boolean is/is not
     *
     */

    global define boolean is_snd_alias(string alias) ``{
	if (use_alsa)
	{
	    return regexpmatch(alias, "^snd-card-[0-9]*$");
	}
	else
	{
	    return regexpmatch(alias, "^sound-slot-[0-9]*$");
	}
    }


    /**
     * unique key for non-pci/pnp cards or virtual cards
     * @return string key for legacy isa cards
     */

    global define string isa_uniq() ``{
	return "uniq.virtual";
    }

  /**
   * reads variables listed in 'vars' from rc.config
   * @return map optname: value
   */
    global define map read_rc_vars () ``{
	string load_alsa = "no";
	if (Runlevel::ServiceEnabled("alsasound"))
	{
	    load_alsa = "yes";
	}

	return $["LOAD_ALSA" : load_alsa , "LOAD_ALSA_SEQ" : SCR::Read(.sysconfig.sound.LOAD_ALSA_SEQ)];

//        return listmap (`k, vars, ``([k, SCR::Read(topath(sformat (".rc.system.%1", k)))]));
    }


    /**
     *  writes unique keys of the configured cards to /var/lib/YaST/unique.inf
     *  this function should not be used
     *  @param keys list with uniq keys
     *  @return boolean success/failure
     *
     *
     */

//    global define boolean save_unique_keys (list keys) ``{
//        list orig = SCR::Read(.var.lib.yast.unique);
//        if (orig == nil)
//        {
//            orig = [];
//       }
//        list keys = maplist (`e, keys, ``($["unique" : e, "state" : "configured"]));
//        orig = filter (`e, orig, ``(lookup(e, "section", "") != "sound"));
//	list final = add (orig, $["contents" : keys, "section" : "sound"]);
//        return SCR::Write(.var.lib.yast.unique, final);
//    }

    /**
     * saves uniq keys to .probe.status
     * @param configured list of strings of configured cards uniq keys
     * @param unconfigured list of string of unconfigured cards uniq keys
     * @return boolean
     */

    global define boolean SaveUniqueKeys(list configured, list unconfigured) ``{
        maplist(`e, configured, ``{
            SCR::Write(.probe.status.configured, e, `yes);
        });

        maplist(`e, unconfigured, ``{
            SCR::Write(.probe.status.configured, e, `no);
        });

        return true;
    }



    /**
     * Used for searching. returns index of the card in the database identified by name
     * @param name card name
     * @return integer position of the card
     */

    global define integer search_card_id (string name) ``{
        list all_cards = get_card_names ("all");
        integer pos = 0;
        integer len = size (name);
	name = tolower(name);
	integer bound = size (all_cards);
        while (pos < bound)
        {
            if (substring (tolower(select (all_cards, pos, "")), 0, len) == name)
            {
                return pos;
            }
            pos = pos + 1;
        };
        return -1;
    }

    /**
     * Itemize list for selection box
     * @param l list with values
     * @param default value to select as default
     * @return list items to be shown in list widget
     */
    global define list itemize_list (list l, integer default) ``{
        integer i = 0;
        list itemized_list = [];
        integer s = size (l);
        while (i < s)
        {
            itemized_list = add (itemized_list, `item (`id(i), select (l, i, ""), (i == default)));
            i = i + 1;
        }
        return itemized_list;
    };



    /**
     * Returns list of keys read from /var/lib/YaST/unique.inf
     * @return list with unique keys
     */

    global define list read_unique_keys () ``{
	list already = [];
	if (SCR::Read(.target.size, "/var/lib/YaST/unique.inf") > 0)
	{
	    already = SCR::Read(.var.lib.yast.unique);
	}
	else
	{
	    already = [];
	}
	// select the sound section

	list output = [];

	already = filter(`e, already, ``(lookup(e, "section", "") == "sound"));
	if (size(already) == 0) return [];
	already = lookup(select(already, 0, ""), "contents", []);
	already = maplist(`e, already,
	``{
	    if (lookup(e, "state", "") == "configured")
	    {
		output = add(output, lookup(e, "unique", ""));
	    }
	}

	);

	already = output;

	return already;
    }

    /**
     *	show a warning popup for nm256 snd cards if needed
     *  @param modname string module name
     *  @return boolean continue/abort
     */

    global define boolean nm256hack (string modname) ``{
        if (modname == "snd-nm256")
        {
            // special warning message for in a special case
            string warn_text = lookup(STRINGS, "nm256hackWarning", "");
	    return UI::YesNoPopup(warn_text);
        }
        return true;
    }

    /**
     * Looks up in the database for the module
     * @param card map read from .probe.sound
     * @return map relevant card info found in db
     */
    global define map get_module (map card) ``{

	Sound::LoadDatabase();

	string bus        = lookup (card, "bus", "");
	integer offset    = (tolower (bus) == "isa") ? 0x20000 : 0x10000;
	integer vendor_id = lookup (card, "vendor_id", 0) - offset;
	integer device_id = lookup (card, "device_id", 0) - offset;

	map m1 = lookup(Sound::db_indices, vendor_id, $[]);
	if (m1 == $[])
	{
	    y2debug("vendor_id not found...");
	    return $[];
	}

	integer m2 = lookup(m1, device_id, -1);
	if (m2 == -1)
	{
	    y2debug("device_id not found");
	    return $[];
	}

	string modname = lookup(Sound::db_module_index, m2, "");

	map ret = lookup(Sound::db_modules, modname, $[]);

	if (ret != $[] && !haskey(ret, "name"))
	{
	    // we must supply the 'name' key with the module name
	    ret = add(ret, "name", modname);
	}

	return ret;
    }

    /**
     * umnute channel 'devide' of the 'card_id'-th sound card. alsa only
     * @param devices list of channels to be unmuted
     * @param card_id of the card
     * @return void
     */

    global define void unmute(list devices, integer card_id) ``{
	if (Sound::autoinstallation)
	{
	    // TODO: store this info some elsewhere...
	    return;
	}

	list avail = SCR::Dir(topath(sformat(".audio.alsa.cards.%1.channels", card_id)));
	if (avail == nil || size(avail)==0)
	{
	    avail = [];
	}
	foreach(`dev, devices,
	``{
	    if (contains(avail, dev))
	    {
		SCR::Write(topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", card_id, dev)), false);
	    }
	});
    }

    /**
     * stores the volume to file. stored volume will be
     * restored after reboot
     * @param card_id card id
     * @return boolean success/failure
     */

    global define boolean storeVolume(integer card_id) ``{
	if (card_id == -1)
	{
	    SCR::Execute(.audio.alsa.store, 0, 0);
	}
	string p = sformat(".audio.alsa.cards.%1.store", card_id);

	return SCR::Execute(topath(p), 0, 0);
    }


    /**
     *  Checks whether the module has been successfully loaded
     *
     * @param save_entry card config map
     * @param card_id card id
     * @return string empty on success/ error message on failure
     */

    global define string check_module(map save_entry, integer card_id) ``{
	map pm = SCR::Read(.proc.modules);
	string mod_name=lookup(save_entry, "module", "off");
        if (!haskey (pm, mod_name) || size(get_running_cards()) <= card_id)
        {

                // To translators: label to error popup
            return sformat (_("The kernel module %1 for sound support
could not be loaded. This can be caused by incorrect
module parameters, including invalid IO or IRQ parameters."), mod_name);
        }
        return "";

    }


    /**
     *  creates itemized table entries,
     *  @param lm list of maps to take keys from
     *  @param lk list of keys to look for in 1st param
     *
     *  @return list of items
     */

    global define list create_table (list lm, list lk)
    ``{
	list res = [];
	integer pos = 0;
	foreach(`m, lm,
	``{
	    res = add(res, `item(`id(pos),
		lookup(m, select(lk, 0, $[]), ""),
		lookup(m, select(lk, 1, $[]), ""),
		lookup(m, select(lk, 2, $[]), "")
		));
	    pos = pos + 1;
	});
	return res;
    }

    /**
     * !OBSOLETE (probably)
     * tries to extract list of values from description
     * these values are generated from alsa modules
     * and can be in form
     * [list=value,value,..] or
     * [range=1-19] or something not recognized
     * @param des string
     * @return list of...
     */
    global define list parse_values (string des) ``{
        list ret = [];
        integer pos = 0;
        integer len = size (des);
        while ((pos < len) && (substring (des, pos, 1) != "["))
        {
            pos = pos + 1;
        }
        pos = pos + 1;

        if (pos < len)          // found "["
        {
            if (tolower(substring (des, pos, 5)) == "list=")
            {
                pos = pos + 5;
                integer s = pos;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == ",")
                    {
                        ret = add (ret, tointeger (substring (des, s, pos - s)));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                ret = add (ret, tointeger (substring (des, s, pos - s)));
            }
            else if (tolower(substring (des, pos, 6)) == "range=")
            {
                pos = pos + 6;
                integer s = pos;
                integer range_start = 0;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == "-")
                    {
                        range_start = tointeger(substring (des, s, pos - s));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                integer range_stop = tointeger(substring (des, s, pos - s));
                                        // now create the range list
                while (range_start <= range_stop)
                {
                    ret = add (ret, range_start);
                    range_start = range_start + 1;
                }
            }
	    else if (tolower(substring (des, pos, 4)) == "bool")
            {
                ret = [0, 1];
            }
        }

        return ret;
    }


    /**
     * checks whether param #1 is if type of param #2
     * @param value value
     * @param type expected type. one of {int, string}
     * @param poss if poss is nonempty, checks if value is one of them
     * returns error message, empty string if ok
     * @return string error message
     */
    global define string check_value (string value, string type, list poss) ``{
        if (type == "int")
        {
            if (tolower(substring (value, 0, 2)) == "0x")               // hex number
            {
                string rest = tolower(substring (value, 2));
                if (filterchars(rest, "0123456789abcdef") != rest)
                {
                      // To translators: popup message, wrong value
                      return sformat (_("The value: %1 must be a number"), value);
                }
            }
            else                // decimal number
            {
                string rest = value;
                if (substring (value, 0, 1) == "-")      // negative number
                {
                    rest = substring (value, 1);
                }
                if (filterchars(rest, "0123456789") != rest)
                {
                            // To translators: popup message, wrong value
                    return sformat (_("The value: %1 must be a number"), value);
                }
            }
        }
        else if (type == "string")
        {
            if (filterchars (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789") != value)
            {

                integer wrong_pos = findfirstnotof (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789");
                string wrong_char = substring (value, wrong_pos, 1);
                if (wrong_char == " ")
                {
                                        // To translators: "space" means blank character
                    wrong_char = wrong_char + " " + _("(space)");
                }
                        // To translators: popup message, wrong value
                return  sformat (_("String cannot contain: %1"), wrong_char);
            }
        }

                                    // now check for poss list
        if (size (poss) > 0)
        {
            list poss_list = [];

            if (type == "int")
            {
                poss_list = maplist (`v, poss, ``(tointeger (value) == v));
            }
            else
            {
                poss_list = maplist (`v, poss, ``(value == v));
            }

            if (!contains (poss_list, true))
            {
                      // To translators: popup message, wrong value
                return sformat (_("The value must be one of %1"), poss);
            }
        }

        return "";              // ok :-)

    }

    /**
     * inserts values to already set options
     * @param params list with available options for module
     * @param values values that have been already set
     * @return map with refreshed options
     *
     */

    global define map restore_mod_params(map params, map values) ``{
	return mapmap(`e, `f, params,
	``{
	    f = add(f, "value", lookup(values, e, ""));
	    return [e, f];
	});

    }

    /**
     *  checks whether sound fonts have already been installed
     *	@return boolean already installed/not installed
     *
     */

    global define boolean FontsInstalled() ``{
	return SCR::Read(.target.size, "/usr/share/sfbank/creative") >= 0; // fileexist("/usr/share/sfbank/creative");
    }

    /**
     * return true if the sound card supports sound fonts
     * @param save_entry save entry
     * @return boolean	card supports fonts/it doesn't
     */

    global define boolean HasFonts(map save_entry) ``{
	if (Sound::autoinstallation)
	{
	    // don't install sound fonts during autoinstallation
	    return false;
	}

	if (contains(["snd-emu10k1", "snd-sbawe", "emu10k1"], lookup(save_entry, "module", "")))
	{
	    return true;
	}
	return false;
    }

    /**
     *  this small wizard will install sound fonts for soundblaster live/awe
     *  @param symlink is path to default.sf2 that is to be created
     *  @param dontask if true, skip the first messagebox
     *  @return void
     */

    global define void InstallFonts(string symlink, boolean dontask) ``{
	boolean answer = false;

	// step 1: want install?
	if (dontask)
	{
	    answer = true;
	}
	else
	{
	    answer = UI::YesNoHeadlinePopup(	lookup(STRINGS, "soundFontTitle", ""),
					lookup(STRINGS, "soundFontQuestion", ""));
	}

	if (!answer)
	{
	    return;
	}

	boolean succes = false;

	while (true)
	{
		// step 2: insert CD
	    answer = UI::ContinueCancelHeadlinePopup (lookup(STRINGS, "soundFontTitle", ""),
						    lookup(STRINGS, "soundFontAppeal", ""));
	    if (!answer)
	    {
		return;
	    }

	    // step3: do something
	    map res = SCR::Execute (.target.bash_output, "/usr/lib/YaST2/bin/copyfonts 2>/dev/null", $[] );
	    integer cnt = tointeger(lookup(res, "stdout", 0));

	    // step4:
	    if (cnt > 0)
	    {
		UI::MessagePopup(sformat(lookup(STRINGS, "soundFontFinal", ""), cnt, "/usr/share/sfbank/creative"));
		return;
	    }
	    else
	    {
		answer = UI::YesNoHeadlinePopup(  lookup(STRINGS, "soundFontNotFound", ""),
						lookup(STRINGS, "soundFontRetry", ""));
		if ( !answer )
		{
		    return;
		}
	    }
	}
    }

    /**
     * does this machine need a nm256/opl3sa warning?
     * @param sound_cards sound cards
     * @return boolean see as above
     *
     */

    global define boolean need_nm256_opl3sa2_warn(list sound_cards) ``{
	list mods = maplist(`e, sound_cards, lookup(e, "module", ""));
	if (contains(mods, "snd-nm256") && contains(mods, "snd-opl3sa2"))
	{
	    return true;
	}
	return false;
    }

    /**
     * shows warning message when both nm265 and opl3sa2 cards are present
     * @param sound_cards list of sound cards
     * @return void
     */

    global define void nm256_opl3sa2_warn(list sound_cards) ``{
	list s1 = filter(`e, sound_cards,
	    ``(lookup(e, "module", "") == "snd-nm256"));
	list s2 = filter(`e, sound_cards,
	    ``(lookup(e, "module", "") == "snd-opl3sa2"));

	if (size(s1) > 0 && size(s2) > 0)
	{
	    string name1 = lookup(select(s1, 0, $[]), "model", "");
	    string name2 = lookup(select(s2, 0, $[]), "model", "");
	    UI::LongTextPopup("",
		`RichText("<p>"+sformat(lookup(STRINGS, "opl3sa_nm256_warn", ""), name1, name2)+"</p>"),
		50, 12);
	}
    }


    /**
     * removes entries from save_info listed by indices in id_list
     * @param save_info list
     * @return list new save_info
     */

    global define list recalc_save_entries(list save_info)
    ``{
	integer pos = 0;
	save_info = maplist(`e, save_info,
	``{
	    map opts = lookup(e, "options", $[]);
	    e = add_alias(e, pos);
	    e = add_common_options(e, pos);
	    pos = pos + 1;
	    return e;
	});
	return save_info;
    }

    /**
     * stops all programs using sound devices
     * @return boolean true if nothing's using sound, false otherwise
     *
     */

    global define boolean stop_programs() ``{
	if (Sound::autoinstallation)
	{
	    return true;
	}
	integer fuser = SCR::Execute (.target.bash, "/bin/fuser /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]);

	if (fuser == 0)
        {
                  // To translators: To reset the sound configuration these programs must be terminated
                  // To translators: label message
	    string msg = lookup(STRINGS, "WhichDialogMsg", "");
                  // Yes, No - button labels
            boolean terminate = UI::YesNoPopup (msg);
            if (terminate)
            {
		SCR::Execute (.target.bash, "/bin/fuser -k /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]);
            }
            else
            {
		return false;
            }
        }
	return true;
    }

    /**
     * creates hardware-summary-like list of configured cards
     *
     * @return string richtext
     * @param save_info save info
     */

    global define string ConfCardsRT(list save_info) ``{
	list retlist = [];
	list conflist = [];
	foreach(`entry, save_info,
	``{
	    conflist = add(conflist, lookup(entry, "model", ""));
	});
	integer i = 0;
	foreach(`card, conflist,
	``{
	    // to translators: '(sound card is) Configured as snd-card-1'
	    retlist = add(retlist, Summary::Device(card, sformat(_("Configured as snd-card-%1."), i)));
	    i = i + 1;
	});

	return Summary::DevicesList(retlist);

    }

}

