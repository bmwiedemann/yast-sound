/**
 * File:
 *   routines.ycp
 * 
 * Module:
 *   Sound
 * 
 * Summary:
 *   Routines for sound card configuration
 * 
 * Authors:
 *   Dan Veselý <dan@suse.cz>
 *
 * $Id$
 *
 */

{
    textdomain "sound";
    include "misc_defines.ycp";
    include "lan/lan_routines.ycp";

    global define add_card_manually(list save_info) ``{
	symbol ui=nil;
	map entry=$["unique_key": isa_uniq(), "options": $[]];
	while(true)
	{
            res=CallModule("sound_manual", []);

            if(lookup(res, "ui", nil)==`next)
            {
                entry=add(entry, "model", lookup(res, "model", ""));
                entry=add(entry, "module", lookup(res, "module", ""));
            }
            else
            {
                ui=lookup(res, "ui");
                if(ui==`abort || ui==`cancel)
                {
                    return $["ui": `abort];
                }
                break;
            }
	    res=OneCardWizard(entry,  size(save_info), `next, 6, false, save_info);
	    if(lookup(res, "ui", `cancel)==`next)
	    {
	        entry=lookup(res, "return", $[]);
	        ui=`next;
	        break;
	    }
	    else
	    {
	        if(lookup(res, "ui", `cancel)!=`back)
	        {
	            ui=`abort;
	            break;
	        }
	    }
	}
	return $["ui": ui, "return": entry];
    }

    /** returns list of items: [`item(`id(module_name), "module label")]
     */
    global define get_module_names() ``{
	list ret=[];
	if(db==nil) return [];
	foreach(`e, db, 
	``{
	    ret=add(ret, `item(`id(lookup(lookup(e, "module", $[]), "name", "")), lookup(e, "name", _("Unknown module name"))));
	});
	ret=sort(`a, `b, ret, ``(select(a, 1)<select(b, 1)));

	return ret;
    }

    /** returns card models list 
     *
     * @param modname if "all" returns all models
     *
     *
     */

    global define get_card_names(string modname) ``{
	if(modname=="all")
	{
	    list cards=[];
	    foreach(`e, db,
	    ``{
		cards=add(cards, lookup(e, "cards", []));
	    });

	    cards=flatten(cards);
	    return sort(cards);
	}

	list mods=filter(`e, db, 
	``(lookup(lookup(e, "module", $[]), "name", "")==modname));
	if(size(mods)==0)
	{
	    return [];
	}
	return sort(lookup(select(mods, 0), "cards", []));
    }

    /**  
     *	returns module name for a given card model
     *
     */

    global define get_module_by_cardname(string cardname) ``{
	list mod=filter(`e, db,
	``(contains(lookup(e, "cards"), cardname))
	);
	return lookup(lookup(select(mod, 0), "module", $[]), "name", "unknown");
    }

    /**
     * returns the 'params' section from sndcards.ycp of the given module
     * @param modname module name
     * @return list with params and their descriptions
     */

    global define get_module_params(string modname) ``{
	// database must be read some elsewhere
	list mod=filter(`e, db, ``(lookup(lookup(e, "module", $[]), "name", "")==modname));
	if(size(mod)>0)
	{
	    return lookup(select(mod, 0), "params", []);
	}
	return [];
    }

    /**
     * unique key for non-pci/pnp cards or virtual cards	
     *
     */

    global define isa_uniq() ``{
	return "uniq.virtual";
    }

    /**
     * returns true if char is blank
     */
    global define isBlank(string s) ``{
        if(s=="\n" || s=="\t" || s==" ")
        {
            return true;
        }
        return false;
    }

    /**
     *  removes trailing and leading blank chars from string
     *
     *
     */
    global define removeBlanks(string str)``{
        //emtpy  string
        if(size(str)==0) return "";

        integer bound=size(str);
        integer first=0;
        integer last=size(str)-1;
        // find first non-blank char
        while(first<bound && isBlank(substring(str, first, 1)))
        {
            first=first+1;
        }

        while(last>=0 && isBlank(substring(str, last, 1)))
        {
            last=last-1;
        }
        if(last>first)
        {
            return substring(str, first, last-first+1);
        }
        return "";
    }


  /** 
   * returns the substring that is after the last occurence of the given character(string)
   * @param str input string
   * @param delim deliminator string (usually 1 character)
   * @return string that is after last occurence of delim string in str string
   */
    global define afterLast(string str, string delim) ``{
	integer cut=0;
	while(true)
	{
	    cut=find(str, delim);
	    if(cut==-1)
	    {
		return str;
	    }
	    str=substring(str, cut+size(delim), size(str)-cut-size(delim));
	}
	// unreachable code
	return "";
    }

  /**
   * returns substring that is before the last occurence of the given character(string)
   * @see afterLast
   */

    global define beforeLast(string str, string delim) ``{
	if(!issubstring(str, delim))
	{
	    return str;
	}
	integer pos=size(str)-size(delim);
	while(pos>=0)
	{
	    if(find(substring(str, pos, size(str)-pos), delim)==0)
	    {
		return substring(str, 0, pos);
	    }
	    pos=pos-1;
	}
	return str;
    }

  /**
   * reads variables listed in 'vars' from rc.config
   * @return list
   */
    global define read_rc_vars (list vars) ``{
        return listmap (`k, vars, ``([k, SCR(`Read(topath(sformat (".rc.system.%1", k))))]));
    }

    

    /**
     *  Converts hex num to integer keeps decimal number as is. Hexadecimal
     *  number assumes to have prefix ``0x''. Doesn't  check the syntax.
     *
     */

    global define hextoi(string num) ``{
	return tointeger(num);
    }

    /**
     *  writes unique keys of the configured cards to /var/lib/YaST/unique.inf
     *  @param list of keys
     *  @return void
     *  
     *
     */

    global define save_unique_keys (list keys) ``{
        list orig = SCR(`Read(.var.lib.yast.unique));
        if (orig==nil)
        {
            orig = [];
        }
        list keys = maplist (`e, keys, ``($["unique" : e, "state" : "configured"]));
        orig = filter (`e, orig, ``(lookup(e, "section", "") != "sound"));
	list final=add (orig, $["contents" : keys, "section" : "sound"]);
        SCR(`Write(.var.lib.yast.unique, final));
    }


    /**
     * Reads /proc/asound/cards and removes entries form save_info with no corresponding entry in /proc/asound/cards
     *
     * @param list save_info
     * @return list modified list of save_info
     */

    global define remove_invalid_save_info(list save_info) ``{
	list cards=nil;
	if(fileexist("/proc/asound/cards"))
	{
	    cards = SCR(`Read(.proc.asound.cards));
/*            if (is(select (asound, 0), map))
            {
                return asound;
            }
*/ 
	    return save_info;
	}
	// no /proc/asound/cards exists -> no cards configured
	return [];
    }

    /**
     * returns sound card database
     * @return list
     */

    global define GetCardDatabase() ``{
	any database=SCR(`Read (.target.yast2, "sndcards.ycp"));
	y2error("### Reading sndcards.ycp");
	textdomain "sound_db";
	database = UI (database);
	textdomain "sound";
	return database;
    }

    /**
     * Used for searching. returns index of the card in the database identified by name
     * @return integer
     */

    global define search_card_id (string name) ``{
        list all_cards = get_cards ("all");
        integer pos = 0;
        integer len = size (name);
	name = tolower(name);
	integer bound = size (all_cards);
        while (pos < bound)
        {
            if (substring (tolower(select (all_cards, pos)), 0, len) == name)
            {
                return pos;
            }
            pos = pos + 1;
        };
        return -1;
    }

    /**
     * creates "libhd entry" from db info
     * @return map
     */
    /* !!! variable db is inherited from module sound.ycp*/
    global define get_card (string module_name, string card_name) ``{
        map ret = $[];
        map db_entry = $[];

        if (module_name == "All") //UI(_("All")))
        {
            list tmp = filter (`e, db, ``(contains(lookup (e, "cards", []), card_name)));
            if (size (tmp) > 0)
            {
                db_entry = select (tmp, 0);
            }
            else
            {
                db_entry = select (filter (`e, db, ``(lookup (e, "name", []) == card_name)), 0, $[]);
            }
        }
        else
        {
            db_entry = select (filter (`e, db, ``(lookup (e, "name", "") == module_name)), 0, $[]);
        }



        if (size (db_entry) == 0)
        {
            y2error ("Db entry not found");
            return ret;
        }

        map module_entry = $["params" : lookup (db_entry, "params", []),
                            "module"  : lookup (db_entry, "module", $[])];

        ret = add (ret, "module", module_entry);
        ret = add (ret, "sub_vendor", card_name);
        if (tolower (module_name) == "all")
        {
            ret = add (ret, "sub_device", sformat ("(%1)", lookup(db_entry, "name", card_name)));
        }
        else
        {
            ret = add (ret, "sub_device", sformat ("(%1)", module_name));
        }
        map libhd = select (lookup (db_entry, "libhd", []), 0, $[]);
        ret = add (ret, "vendor_id", lookup (libhd, "vendor_id", 0));

        if (is (lookup (libhd, "device_id", 0), list))
        {
            ret = add (ret, "device_id", select (lookup (libhd, "device_id", 0), 0));
            ret = add (ret, "bus", "PCI");
        }
        else
        {
            ret = add (ret, "device_id", lookup (libhd, "device_id", 0));
            ret = add (ret, "bus", "ISA");
        }
        return ret;

    }

    /**
     * returns list of sound cards. get_cards("all") returns all cards
     * @return list
     */

    /* !!! variable cards is inherited from module sound_manual.ycp*/
    global define get_cards (string module_name) ``{
        list ret = [];

        if (tolower(module_name) == "all")
        {	// copy the whole database
        maplist (`e, db,
            ``{
                if (size (lookup (e, "cards", [])) > 0) ret = add (ret, lookup (e, "cards"));
                else ret = add (ret, [lookup (e, "name", "")]);
            });
        }
        else
        {	// filter by name 
            ret = maplist (`c, filter (`e, db, ``(lookup (e, "name", "") == module_name)), ``(lookup (c, "cards", [])));
            ret = filter (`e, ret, ``(size(e) > 0));

            if (size (ret) == 0)
            {
                ret = add (ret, [module_name]);
            }
        }
        return sort(flatten(ret));
    }

    /**
     * Itemize list for selection box
     * @return list
     */
    global define itemize_list (list l, integer default) ``{
        integer i = 0;
        list itemized_list = [];
        integer s = size (l);
        while (i < s)
        {
            itemized_list = add (itemized_list, `item (`id(i), select (l, i), (i == default)));
            i = i + 1;
        }
        return itemized_list;
    };



    /**
     *  Returns list of already running cards
     *  @return list
     *  
     *
     */

    global define get_running_cards () ``{
        if (fileexist("/proc/asound/cards"))
        {
            list asound = SCR(`Read(.proc.asound.cards));
            if (is(select (asound, 0), map))
            {
                return asound;
            }
        }
        return [];
    }

        /**
     *
     *
     * @return list with configred cards. eg:
     *  [
     *      $["unique" : "asdas.asdasd", "state" : "configured", "model" : "SoundBlaster16"],
     *      $[...]
     *  ]
     */

    global define read_configured_cards() ``{
        if (SCR(`Read(.target.size, "/var/lib/YaST/unique.inf")) == 0)
        {
            return [];
        }
        list uniq_inf=SCR (`Read(.var.lib.yast.unique));
        list snd_uniq=[];
        foreach(`e, uniq_inf,
        ``{
            if(lookup(e, "section", "")=="sound")
            {
                snd_uniq=lookup(e, "contents", []);
            }
        });
        // now the "configured" values look like 'configured:SoundBlaster16'
        // we must deivide this and create new key

        string state="";
        list strings=[];

        list probedcards=[];

        snd_uniq=maplist(`e, snd_uniq,
        ``{
            state=lookup(e, "state", ":");
            strings=splitstring(state, ":");
            e=add(e, "state", select(strings, 0));
            if(size(strings)>1)
            {
		string modname=select(strings, 1);
		// substitute underscores by spaces
		modname=mergestring(splitstring(modname, "_"), " ");
                e=add(e, "model", modname);
            }
            else
            {
                string modelname=UI(_("Unknown model"));

                // this probably means, that the system has been upgraded
                if(probedcards==[])
                {
                    probedcards=SCR(`Read(.probe.sound));
                }
                foreach(`g, probedcards,
                ``{
                    if(lookup(g, "unique_key", "")==lookup(e, "unique", ""))
                    {
			if(lookup(g, "sub_device", "")!="")
			{
			    modelname=lookup(g, "sub_device", modelname);
			}
			else 
			{
			    modelname=lookup(g, "device", modelname);
	    		}    
                    }
                });

                e=add(e, "model", modelname);


            }
            return e;
        });

        return snd_uniq;
    }




    /**
     * Returns list of keys read from /var/lib/YaST/unique.inf
     * @return list with unique keys
     */

    global define read_unique_keys () ``{
	list already = [];
	if (SCR(`Read(.target.size, "/var/lib/YaST/unique.inf")) > 0)
	{
	    already = SCR (`Read(.var.lib.yast.unique));
	}
	else
	{
	    already = [];
	}
	// select the sound section

	list output=[];

	already = filter(`e, already, ``(lookup(e, "section", "")=="sound"));
	if(size(already)==0) return [];
	already = lookup(select(already, 0), "contents", []);
	already = maplist(`e, already, 
	``{
	    if(lookup(e, "state", "")=="configured")
	    {
		output=add(output, lookup(e, "unique", nil));
	    }
	}

	);

	already=output;

	return already;
    }

    /**
     * difflist 
     * @return list with positions of members from a that are not present in b
     *
     */

    global define difflist(list a, list b) ``{
	integer i=0;
	list ret=[];
	while(i<size(a))
	{
	    if(!contains(b, select(a, i)))
	    {
		ret=add(ret, i);
	    }
	    i=i+1;
	}   
	return ret;
    }

    /**
     * get_obsoletes
     * @return list with obsolete indices of unique keys
     * @param  cards from .probe.sound
     * @param  keys unique keys from /var/lib/YaST/unique.inf
     *
     * e.g. if in /var/lib/YaST/unique.inf in sound section are keys ["a", "b", "c"]
     * and card with id "b" is not present in computer, then [1] is returned;
     */

    global define get_obsoletes(list cards, list keys) ``{
	list audio_keys=[];
        integer i=0;
        integer bound=size(cards);

	while(i<bound)
        {
            audio_keys=add(audio_keys, lookup(select(cards, i), "unique_key", ""));
            i=i+1;
	    
        }
   
        return difflist(keys, audio_keys);
    }

    /**
     * get_present_unique_keys
     * @return list with unique keys. keys of removed hardware are removed
     * @param cards is passed to get_obsoletes
     * @param keys  is passed to get_obsoletes
     *
     *
     */

    global define get_present_unique_keys (list cards, list keys) ``{
	list obs=get_obsoletes(cards, keys);
	integer i=size(obs)-1;

	while(i>=0)
	{
	    keys=remove(keys, select(obs, i));
	    i=i-1;
	}		
	return keys;
    }

    /**
     *  @return boolean
     *  
     *
     */

    global define nm256hack (string modname) ``{
        if (modname == "snd-card-nm256")
        {
            // special warning message for in a special case
            string warn_text=lookup(STRINGS, "nm256hackWarning", "");
	    return UI(`YesNoPopup(warn_text));
        }
        return true;
    }




    /**
     * same as  ()?():(); statement in c
     * @return any
     */
    global define condition (boolean c, any s1, any s2) ``{
	if (c) 
	{ 
	    return eval (s1);
	}
	else
	{
	    return eval (s2);
	}
    };


    /**
     * This is no alsa hack function
     * @return map
     */
    global define no_alsa (string mod_name) ``{
	return $[
	    "modules" : [
		$["name"   : mod_name,
		 "modules" : $["alias" :  "char-major-14"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "sound"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "midi"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "sound-slot-0"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "sound-service-0-0"]]	    
		],
	    "volume" : $[
		"mixer" : "/usr/bin/aumix \"$CHANNEL\" $VOLUME"
		]
	    ];
    }

    /** 
     * returns list of detected soundcards
     *
     * return example:
     *          [       
     *          "bus"           : "PCI",
     *          "device"        : "ES1371 [AudioPCI-97]",
     *          "device_id"     : 70513,
     *          "resource"      : $["io":[$["active":true, "length":0, "mode":"rw", "start":28672]],
     *                             "irq":[$["count":0, "enabled":true, "irq":10]]],
     *          "rev"           : "6",
     *          "sub_device"    : "Creative Sound Blaster AudioPCI64V, AudioPCI128",
     *          "sub_device_id" : 70513,
     *          "sub_vendor"    : "Ensoniq",
     *          "sub_vendor_id" : 70260,
     *          "vendor"        : "Ensoniq",
     *          "vendor_id"     : 70260,
     *          "unique_key"    : "test.test",
     *          "module"        : $["name":"eps23"]]
     *          ]
     */

    global define get_audio() ``{
        string tmpdir=SCR (`Read (.target.tmpdir));
        if(fileexist(tmpdir+"/audio.ycp"))
        {
            return SCR(`Read(.target.ycp, tmpdir+"/audio.ycp"));
        }

        list ret = SCR(`Read(.probe.sound));
        if (ret==nil) ret = [];
        SCR(`Write(.target.ycp, tmpdir+"/audio.ycp", ret));
        return ret;
    }


    /**
     * runs a perl script 'fetchmodule' and returns a sndcards-like module record    
     * for a non-alsa module
     * @param 1st modude name (eg. 'cs4231')
     */

    global define fetchmodule(string modname)
    ``{
	string tmpdir=SCR (`Read (.target.tmpdir));
	SCR (`Execute (.target.bash, sformat ("/usr/bin/fetchmodule %1.o > %2/mod.ycp" , modname, tmpdir)));
	{
	    map out=SCR(`Read(.target.ycp, tmpdir+"/mod.ycp"));
	    return UI(out);
	}
	return [];
    }

    /**
     * Looks up in the database for the module
     * @return map
     */
    global define get_module (map card) ``{
	if (db == nil)
	{
	    return $[];
	}

	string bus        = lookup (card, "bus", "");
	integer offset    = condition ((tolower (bus) == "isa"), 0x20000, 0x10000);
	integer vendor_id = lookup (card, "vendor_id", 0);
	integer device_id = lookup (card, "device_id", 0);

	list fc = [];
/*
	if(size(lookup(card, "module", [])) > 0)
	{
	    map mod=select(lookup(card, "module", []), 0);
	    map fmod=fetchmodule(lookup(mod, "name", []));
	    if(lookup(mod, "name", "") != "")
	    {
		return $["name": lookup(mod, "name", ""),
			 "module": mod, 
			 "params": lookup(fmod, "params", []),
			 "libhd": [],
			 "cards": ["Multimedia audio controller"]];
	    }
	}
*/	
	if (tolower (bus) == "pci") 
	{
	    fc = filter (`d, db, 
			 ``(filter(`c, lookup (d, "libhd", []), ``((lookup (c, "vendor_id", 0) == vendor_id - offset) && 
							       (contains(lookup(c, "device_id", 0), device_id - offset)))) != []));
	}
	else 
	{
	    fc = filter (`d, db, 
		   ``(filter(`c, lookup (d, "libhd", []), ``((lookup (c, "vendor_id", 0) == vendor_id - offset) &&
							 (lookup (c, "device_id", 0) == device_id - offset))) != []));
	}

	if (fc!=nil)
	{
	    if (size (fc) > 0) return select (fc, 0);
	}

	return $[];
    }

    /**
     * Use another module than alsa
     * @return boolean
     */
    global define no_alsa_exception (map card, boolean config_mode) ``{
	if (!config_mode)
	{
	    return MacRisc ();
	}
	return false;
    }

    /**
     * true if system is MacRISC
     * @return boolean
     */

    global define MacRisc () ``{
	if (lookup (select (SCR(`Read(.probe.system)), 0), "system", "") == "MacRISC")
	{
	    return true;
	}
	return false;
    }

    /**
     * Creates save information based on card map return by libhd
     * First list of exceptions is processed (has two keys : "try" with function to 
     * provide test and "handle" with function to handle (return) the corrected result
     * otherwise vendor_id, device_id search in sound db is run
     *
     * @return map
     */
    global define create_save_info (map card, integer card_id) ``{
	list except_list = []; //[$["try" : ``(MacRisc ()), "handle" : ``(mac_risc ())]];
	integer exp_id = 0;
	
	while (exp_id < size (except_list))
	{
	      if (eval(lookup(select (except_list, exp_id), "try", "")))
	      {
		  return eval(lookup(select (except_list, exp_id), "handle", ""));
	      }
	      exp_id = exp_id + 1;
	}

	// no exceptions, normal way ...


	map mod     = $[];
	if (haskey (card, "module"))
	{
	    mod = lookup (card, "module");
	}
	else
	{
	    mod = get_module (card);
	}

	list params = filter (`e, lookup (lookup (card, "module", $[]), "params", []), ``(size (lookup (e, "value")) > 0));
	map options = listmap (`e, params, ``([lookup (e, "name", ""), lookup (e, "value", "")]));

	if (lookup (lookup (mod, "module", $[]), "name" , "off") != "off") 
	{
	    options = add (options, "snd_id", sformat ("card%1", card_id + 1));
	    options = add (options, "snd_index", sformat ("%1", card_id));
	}

	return $["name"   : lookup (lookup (mod, "module", $[]), "name" , "off"),
		"modules" : $["alias"  : sformat ("snd-card-%1", card_id),
			     "options" : options]];
    }

    /**
     * command must be string with $CHANNEL and $VALUE included
     * @return any
     */
    global define SetVolume (string command, string channel, string value, integer card_num) ``{
	return SCR(`Execute (.target.bash, command, $["CHANNEL" : channel, "VOLUME" : value, "CARD_NUM" : card_num]));
    }

    /**
     * here the test sound is played, by
     * default ist alsa whistle sound, but
     * if snd_au package is installed,
     * than it's Linus Torvals voice, the
     * if the test file cannot be found,
     * the message is displayed
     *
     * @return string returns empty string on succes, otherwise error string 
     */

    global define PlayTest (map user_settings, integer card_id) ``{

        if (!fileexist(lookup (user_settings, "audio_file", "")))
        {
            string file = lookup (user_settings, "audio_file", "");

                  // To translators: just one file will be displayed
                  // To translators: if the test audio file can not be found this message is displayed
                  // To translators: This is just popup message, shouldn't be too long
            string msg = sformat (UI (_("Cannot find file:\n %1\n\n(test audio file)")), file);

            return msg;
        }
        else
        {
            string play_cmd = lookup (user_settings, "play_cmd", "");
            string audio_file = lookup (user_settings, "audio_file", "");
                  // more cards
            if (no_alsa)
            {
                SCR(`Execute (.target.bash_background, sformat("%1 %2", play_cmd, audio_file)));
            }
            else
            {
		SCR(`Execute (.target.bash_background, sformat("%1 -c %2 %3 ", play_cmd, card_id, audio_file)));
//                Shell(sformat("%1 -c %2 %3 &", play_cmd, card_id, audio_file), $[]);
            }
        }
        return "";
    };

        /**
     * tries to insert module with options (if any)
     * @return string with error message (empty string if ok)
     */

    global define probe_module (map card, map user_settings) ``{

        string module_name    = lookup (lookup (card, "module", $[]), "name", "");
        list params           = filter (`e, lookup (lookup (card, "module", $[]), "params", []), ``(size (lookup (e, "value", "")) > 0));
        string module_options = mergestring (maplist (`e, params, ``(sformat("%1=%2", lookup (e, "name", ""), lookup (e, "value", "")))), " ");
        boolean probe         = lookup (lookup (card, "module", $[]), "modprobe", true);
        boolean mod_active    = lookup (lookup (card, "module", $[]), "active", false);

        if (size (module_name) == 0)
        {
                // To translators: error message
            return UI(_("Invalid module name."));
        }

	SCR(`Execute (.target.bash, "/etc/init.d/alsasound stop"));
	
	// create a dummy modules.conf file
	string dumbconf=SCR (`Read (.target.tmpdir));
	dumbconf="/tmp/modules.conf.tmp";
	SCR(`Execute (.target.bash, sformat("/bin/touch %1", dumbconf), $[]));	

	

        SCR(`Execute (.target.bash, sformat("/sbin/depmod -C %1 -a -F /boot/System.map-`uname -r` `uname -r`", dumbconf), $[]));

        if (!mod_active)
        {
            if (!probe)
            {
		SCR (`Execute (.target.bash, sformat("/sbin/insmod -C %1 %2 %3", dumbconf, module_name, module_options), $[]));
            }
            else
            {
		SCR(`Execute(.target.bash, sformat("/sbin/modprobe -C %1 %2 %3", dumbconf, module_name, module_options), $[]));
            }
        }

        if (no_alsa)
        {
            user_settings = add (user_settings, "play_cmd", "/usr/bin/play");
            user_settings = add (user_settings, "mixer", "/usr/bin/aumix \"$CHANNEL\" $VOLUME");
        }
        else
        {
            SCR(`Execute (.target.modprobe, "snd-pcm-oss", "")); // backwards OSS compatibility
        }

        map pm = SCR(`Read(.proc.modules));

        if (!haskey (pm, module_name))
        {

                // To translators: label to error popup
            return sformat (UI(_("The kernel module %1 for sound support\ncould not be loaded.")), module_name);
        }
        return "";
    };

    /**
     *  Checks whether the module has been successfully loaded
     *
     * @return empty string on success/ error message on failure
     */ 

    global define check_module(map save_entry) ``{
	// TODO: check by /proc/asound/cards
	map pm = SCR(`Read(.proc.modules));
	string mod_name=lookup(save_entry, "module", "off");
        if (!haskey (pm, mod_name))
        {

                // To translators: label to error popup
            return sformat (UI(_("The kernel module %1 for sound support\ncould not be loaded.")), mod_name);
        }
        return "";

    }


    /** creates itemized table entries,
     *  @param lm list of maps to take keys from
     *  @param lk list of keys to look for in 1st param
     * 
     *  @return list
     */

    global define create_table (list lm, list lk)
    ``{
/*	integer i = 0;
        list itemized_list = [];
        integer s = size (lm);
        term val = `item ();

        while (i < s)
        {
            val = `item (`id(i));
            foreach (`k, lk,
            ``{
                val = add (val, lookup (select (lm, i), k, ""));
            });

            itemized_list = add (itemized_list, val);
            i = i + 1;
        }
        return itemized_list;
*/
	list res=[];
	integer pos=0;
	foreach(`m, lm, 
	``{
	    res=add(res, `item(`id(pos), 
		lookup(m, select(lk, 0), ""),
		lookup(m, select(lk, 1), ""),
		lookup(m, select(lk, 2), "")
		));
	    pos=pos+1;
	});
	return res;
    }

    /* 
     * tries to extract list of values from description
     * these values are generated from alsa modules
     * and can be in form
     * [list=value,value,..] or
     * [range=1-19] or something not recognized
     * @return list
     */
    global define parse_values (string des) ``{
        list ret = [];
        integer pos = 0;
        integer len = size (des);
        while ((pos < len) && (substring (des, pos, 1) != "["))
        {
            pos = pos + 1;
        }
        pos = pos + 1;

        if (pos < len)          // found "["
        {
            if (tolower(substring (des, pos, 5)) == "list=")
            {
                pos = pos + 5;
                integer s = pos;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == ",")
                    {
                        ret = add (ret, hextoi (substring (des, s, pos - s)));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                ret = add (ret, hextoi (substring (des, s, pos - s)));
            }
            else if (tolower(substring (des, pos, 6)) == "range=")
            {
                pos = pos + 6;
                integer s = pos;
                integer range_start = 0;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == "-")
                    {
                        range_start = tointeger(substring (des, s, pos - s));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                integer range_stop = tointeger(substring (des, s, pos - s));
                                        // now create the range list
                while (range_start <= range_stop)
                {
                    ret = add (ret, range_start);
                    range_start = range_start + 1;
                }
            }
	    else if (tolower(substring (des, pos, 4)) == "bool")
            {
                ret = [0, 1];
            }
        }

        return ret;
    }
 
  /**
   * "sformates" list from sound database, where are localized messages, with 
   * optional formating information
   * @return string
   * @example mysformat(["Message %1 %2 %3", "A", "B", "C"])  ->  "Message A B C"
   */
    global define mysformat (list msg)
    ``{
        if (size (msg) == 0)
        {
            return "";
        }

        integer i = 1;
        term format = ``(sformat (select(msg, 0)));

        while (i < size (msg))
        {
            format = add (format, select (msg, i));
            i = i + 1;
        }
        return eval (format);
    }

    /**
     * checks whether param #1 is if type of param #2
     * @param 1st value
     * @param 2nd expected type. one of {int, string}
     * @param 3nd if poss is nonempty, checks if value is one of them
     * returns error message, empty string if ok
     * @return string
     */
    global define check_value (string value, string type, list poss) ``{
        if (type == "int")
        {
            if (tolower(substring (value, 0, 2)) == "0x")               // hex number
            {
                string rest = tolower(substring (value, 2));
                if (filterchars(rest, "0123456789abcdef") != rest)
                {
                      // To translators: popup message, wrong value
                      return sformat (UI(_("The value: %1 must be a number")), value);
                }
            }
            else                // decimal number
            {
                string rest = value;
                if (substring (value, 0, 1) == "-")      // negative number
                {
                    rest = substring (value, 1);
                }
                if (filterchars(rest, "0123456789") != rest)
                {
                            // To translators: popup message, wrong value
                    return sformat (UI(_("The value: %1 must be a number")), value);
                }
            }
        }
        else if (type == "string")
        {
            if (filterchars (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789") != value)
            {

                integer wrong_pos = findfirstnotof (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789");
                string wrong_char = substring (value, wrong_pos, 1);
                if (wrong_char == " ")
                {
                                        // To translators: "space" means blank character
                    wrong_char = wrong_char + " " + UI(_("(space)"));
                }
                        // To translators: popup message, wrong value
                return  sformat (UI(_("String cannot contain: %1")), wrong_char);
            }
        }

                                    // now check for poss list
        if (size (poss) > 0)
        {
            list poss_list = [];

            if (type == "int")
            {
                poss_list = maplist (`v, poss, ``(hextoi (value) == v));
            }
            else
            {
                poss_list = maplist (`v, poss, ``(value == v));
            }

            if (!contains (poss_list, true))
            {
                      // To translators: popup message, wrong value
                return sformat (UI(_("The value must be one of %1")), poss);
            }
        }

        return "";              // ok :-)

    }

   /**
   * Detected, but not configured cards. contains only cards supported by alsa
   *
   * @param unique_keys
   * @return list
   */
    global define get_not_yet (list uniques) ``{


        list all = get_audio ();
	all=filter(`e, all,
	``(!contains(uniques, lookup(e, "unique_key", "##")))
	);

        return all;
    }

    /**
     *	inserts the options values from save_info to card record
     *
     *
     *
     */    
    
    global define InsertOptions(list optionList, map modifiedOptions) ``{
	integer i=0;
	integer iopt=0;
	list ret=[];
	map option=$[];
//	string value="";
	string optname="";


	while(i<size(optionList))
	{
	    option=select(optionList, i);
	    optname=lookup(option, "name", "");

	    ret=add(ret, add(option, "value", lookup(modifiedOptions, optname, "")));
	    i=i+1;
	}
	return ret;
    }    

    /**
     * inserts values to already set options
     * @param 1st save_info entry
     *
     *
     */

    global define restore_mod_params(list params, map values) ``{
	return maplist(`e, params,
	``{
	    string pname=lookup(e, "name", "");
	    e=add(e, "value", lookup(values, pname, ""));
	    return e;
	});

    }
 
    /** get_tmp_modules_conf returns path to the temporary modules.conf
     */
    
    global define get_tmp_modules_conf() ``{
	string tmpdir=SCR (`Read (.target.tmpdir));
	// TODO: move this file to yast tmp dir
	return "/tmp/modules.conf";
    }

    /**
     * alsasound_start_tmp starts alsa using temporary modules.conf
     * @param restore true - call alsactl restore, false - don't
     *
     *
     */

    global define alsasound_start_tmp(boolean restore) ``{
	string cmd="/sbin/depmod -C "+get_tmp_modules_conf();
	SCR(`Execute(.target.bash, cmd, $[]));

	list als=SCR(`Read(.tmp.modules.alias));

	
	string modname="";
	integer pos=0;
	map res=$[];
	while(contains(als, sformat("snd-card-%1", pos)))
	{
	    modname=SCR(`Read(.tmp.modules.alias, sformat("snd-card-%1", pos)));
	    cmd=sformat("/sbin/modprobe -C %1 %2", get_tmp_modules_conf(), modname);
	    res=SCR(`Execute(.target.bash_output, cmd, $[]));
	    if(lookup(res, "stderr", "")!="")
	    {
		y2error("modprobe error output: \n"+lookup(res, "stderr", ""));
	    }
	    pos=pos+1;
	}


	if(restore)
	{
	    SCR(`Execute(.target.bash, "/usr/sbin/alsactl restore", $[]));
	}
    }

    /** 
     * creates temporary modules.conf.
     * it will be used for starting sound modules
     *
     */

    global define CreateTmpModulesConf() ``{
	string cmd="";


	cmd="/bin/echo alias char-major-116 snd > "+get_tmp_modules_conf();
	SCR(`Execute(.target.bash, cmd, $[]));
	cmd="/bin/echo options snd snd_cards_limit=16 snd_major=116 >> "+get_tmp_modules_conf();
	SCR(`Execute(.target.bash, cmd, $[]));
	
	cmd=sformat("/bin/grep \"^alias.snd-card-[0-9]*\" /etc/modules.conf >> %1", get_tmp_modules_conf());
	SCR(`Execute(.target.bash, cmd, $[]));
	
	cmd=sformat("/bin/grep \"^options.snd-card-\" /etc/modules.conf >> %1", get_tmp_modules_conf());
	SCR(`Execute(.target.bash, cmd, $[]));
    }

    
    /**
     *	adds card entry to temporary modules.conf
     *
     *
     */
 
    global define add_tmp_module_record(map save_entry, integer cid) ``{
	string module_name=lookup(save_entry, "module", "off");
	string cmd=sformat("/bin/echo alias snd-card-%1 %2 >> ", cid, module_name)+get_tmp_modules_conf();
	SCR(`Execute(.target.bash, cmd, $[]));

	string options="";	

	mapmap(`e, `f, lookup(save_entry, "options", $[]),
	``{
	    options=options+" "+e+"="+f;
	}
    	);

	cmd=sformat("/bin/echo options %1 %4 >> ", module_name, cid+1, cid, options) +
	    get_tmp_modules_conf();
	SCR(`Execute(.target.bash, cmd, $[]));

	// change snd_cards_limit to cid+1
	cmd=sformat("/bin/sed s/snd_cards_limit=[0-9]*/snd_cards_limit=%1/ %2 >", cid+1, get_tmp_modules_conf())+get_tmp_modules_conf()+"2";
	SCR(`Execute(.target.bash, cmd, $[]));

	cmd="cp "+get_tmp_modules_conf()+"2 "+get_tmp_modules_conf();
	SCR(`Execute(.target.bash, cmd, $[]));
    }

    /**
     *	removes card entry from temporary modules.conf. 
     *  functional only for removing the last record.
     */

    global define remove_tmp_module_record(integer cid) ``{
	string cmd=sformat("/bin/sed /snd-card-%1/d %2 > %3", cid, get_tmp_modules_conf(), get_tmp_modules_conf()+"2");
	SCR(`Execute(.target.bash, cmd, $[]));

	cmd=sformat("/bin/sed /snd_index=%1/d %2 > %3", cid, get_tmp_modules_conf()+"2", get_tmp_modules_conf());
	SCR(`Execute(.target.bash, cmd, $[]));
    }

    /**
     *	removes entry from /tmp/modules.conf.tmp by the module name
     *
     */

    global define remove_tmp_module_by_name(string mod_name) ``{
	string cmd=sformat("/bin/sed /%1/d %2 > %3", mod_name, get_tmp_modules_conf(), get_tmp_modules_conf()+"2");	
	SCR(`Execute(.target.bash, cmd, $[]));
	

	cmd=sformat("/bin/cp %1 %2", get_tmp_modules_conf()+"2", get_tmp_modules_conf());
	SCR(`Execute(.target.bash, cmd, $[]));

    }

    /** 
     *	@return true if the fonts have already been installed
     *	
     */

    global define FontsInstalled() ``{
	return fileexist("/usr/share/sfbank/creative");
    }

    /** @return true if the sound card supports sound fonts
     */

    global define HasFonts(map save_entry) ``{
	if(lookup(save_entry, "module", "")=="snd-card-emu10k1")
	{
	    return true;
	}
	if(lookup(save_entry, "module", "")=="snd-card-sbawe")
        {
            return true;
        }   
	return false;
    }

    /** this small wizard will install sound fonts for soundblaster live/awe
     *  @param symlink is path to default.sf2 that is to be created
     */

    global define InstallFonts(string symlink, boolean dontask) ``{
	boolean answer=false;

	// step 1: want install?
	if(dontask)
	{   
	    answer=true;
	}
	else
	{
	    answer=UI(`YesNoHeadlinePopup(	lookup(STRINGS, "soundFontTitle", ""), 
					lookup(STRINGS, "soundFontQuestion", "")));
	}
	
	if(!answer) 
	{
	    return;
	}

	boolean succes=false;

	while(true)
	{
    		// step 2: insert CD
	    answer=UI(`ContinueCancelHeadlinePopup (lookup(STRINGS, "soundFontTitle", ""), 
						    lookup(STRINGS, "soundFontAppeal", "")));
	    if(!answer)
	    {
		return;
	    }

	    // step3: do something 
	    map res=SCR (`Execute (.target.bash_output, "/usr/lib/YaST2/bin/copyfonts", $[] ));
	    integer cnt=tointeger(lookup(res, "stdout", 0));
	    
	    // step4: 
	    if(cnt>0)
	    {
		UI(`MessagePopup(sformat(lookup(STRINGS, "soundFontFinal", ""), cnt, "/usr/share/sfbank/creative")));
		return;
	    }
	    else
	    {
		answer=UI(`YesNoHeadlinePopup(  lookup(STRINGS, "soundFontNotFound", ""),
						lookup(STRINGS, "soundFontRetry", "")));
		if(!answer)
		{
		    return;
		}
	    }
    
	}
    }

    /**
     *  helping hand for order_cards_by_uniques
     *  returns true, if unique_key1 is before unique_key2 in uniques list
     */

    global define uniq_order(string key1, string key2, list uniques) ``{


	integer i=0;
	while(i<size(uniques))
	{
	    if(select(uniques, i)==key2) return false;
	    if(select(uniques, i)==key1) return true;
	    i=i+1;
	}
	return true;
    }

    /** 
     *  function to order card entries to appropriate order given by uniq_keys
     *  @param cards card list from .probe.sound
     *  @param uniques unique keys from /var/lib/YaST/unique.inf
     */

    global define order_cards_by_uniques(list cards, list uniques) ``{
	return sort(`e1, `e2, cards, 
	    ``(uniq_order(lookup(e1, "unique_key", ""), lookup(e2, "unique_key", ""), uniques)));
    }

    /**
     * shows warning message when both nm265 and opl3sa2 cards are present
     * @param cards list of sound cards
     */
    
    global define nm256_opl3sa2_warn(list sound_cards) ``{
	list s1=filter(`e, sound_cards, 
	    ``(lookup(lookup(lookup(e, "module", $[]), "module", $[]), "name", "")=="snd-card-nm256"));
	list s2=filter(`e, sound_cards, 
	    ``(lookup(lookup(lookup(e, "module", $[]), "module", $[]), "name", "")=="snd-card-opl3sa2"));

	if(size(s1)>0 && size(s2)>0)
	{
	    string name1=mergestring(splitstring(hardware_name(select(s1, 0)), "\n"), " ");
	    string name2=mergestring(splitstring(hardware_name(select(s2, 0)), "\n"), " ");
	    UI(`MessagePopup(sformat(lookup(STRINGS, "opl3sa_nm256_warn", ""), name1, name2)));
	}
    }

    
    /**
     *	when user wants to delete a card, all cards using given module must be removed.
     *  this function returns list of positions of cards using the module
     *  @param	save_info 
     *	@param	module_name
     *  @return list of integers
     */

    global define get_indices_for_removal(list save_info, string mod_name)
    ``{
	list ret=[];
	integer pos=0;
	maplist(`e, save_info, 
	``{  
	    if(lookup(e, "module", "")==mod_name)
	    {
		ret=add(ret, pos);
	    }
	    pos=pos+1;
	});
	return ret;
    }

    /**
     * removes entries from save_info listed by indices in id_list 
     *
     *
     */

    global define remove_save_entries(list save_info, list id_list)
    ``{
	id_list=sort(`x, `y, id_list, ``(x>=y));
//	save_info=filter(`e, save_info, ``(lookup(e, "name", "")!=mod_name));

	maplist(`e, id_list, ``{if(e<size(save_info)) save_info=remove(save_info, e); });

	integer pos=0;
	save_info=maplist(`e, save_info, 
	``{
	    map opts=lookup(lookup(e, "modules", $[]), "options", $[]);
	    opts=add(opts, "snd_index", sformat("%1", pos));
	    opts=add(opts, "snd_id", sformat("card%1", pos+1));
	    e=add(e, "alias", sformat("snd-card-%1", pos));
	    e=add(e, "options", opts);
	    pos=pos+1;
	    return e;
	});
	return save_info;
    }

    /**
     * removes unique keys from key_list listed by position in id_list
     *
     */

    global define remove_uniques(list key_list, list id_list) ``{
	id_list=sort(`x, `y, id_list, ``(x>=y));
	maplist(`e, id_list, ``{ if(e<size(key_list)) key_list=remove(key_list, e); });
	return key_list;
    }

    /**
     * stops all programs using sound devices
     * @return true if nothing's using sound, false otherwise
     *
     */

    global define stop_programs() ``{
	integer fuser = SCR(`Execute (.target.bash, "/bin/fuser /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]));

	if (fuser == 0)
        {
                  // To translators: To reset the sound configuration these programs must be terminated
                  // To translators: label message
	    string msg=lookup(STRINGS, "WhichDialogMsg");
                  // Yes, No - button labels
            boolean terminate = UI(`YesNoPopup (msg));
            if (terminate)
            {
		SCR(`Execute (.target.bash, "/bin/fuser -k /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]));
            }
            else
            {
		return false;
            }
        }
	return true;
    }

}
