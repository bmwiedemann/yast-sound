/*
 * File:
 *   routines.ycp
 * 
 * Module:
 *   Sound
 * 
 * Summary:
 *   Routines for sound card configuration
 * 
 * Authors:
 *   Dan Veselý <dan@suse.cz>
 *
 * $Id$
 *
 */

{
    textdomain "sound";
//    include "misc_defines.ycp";
    include "lan/lan_routines.ycp";
//    include "ui/summary.ycp";

    /**
     * for a given card detected by libhd this function creates a 
     * label
     * @param map entry from .probe.audio
     * @return string card label
     *
     */
    global define get_card_label(map card)
    ``{
        list lab=splitstring(hardware_name(card),"\n");
        if(size(lab)==1 || select(lab, 1)=="")
        {
            return select(lab, 0);
        }
        return select(lab, 1);
    }

    /**
     * returns true if given string is valid sound alias
     * (snd-card-1 .. snd-card-16)
     * @param string alias
     * @return boolean
     *
     */

    global define is_snd_alias(string alias) ``{
	if(find(alias, "snd-card-")!=0)
	{
	    return false;
	}   	
	integer i=size("snd-card-");
        if(i==size(alias))
        {
            return false;
        }
        while(i<size(alias))
        {
            if(!contains(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], substring(alias, i, 1)))
            {
                 return false;
            }
            i=i+1;
        }
        return true;	
    }

    /**
     * when adding card manually, this function prepares
     * a save_info record. 
     * @param list save_info created earlier
     * @return list save_info with added card
     *
     */

    global define add_card_manually(list save_info) ``{
	symbol ui=nil;
	map entry=$["unique_key": isa_uniq(), "options": $[]];
	while(true)
	{
            res=CallFunction(`sound_manual());

            if(lookup(res, "ui", nil)==`next)
            {
                entry=add(entry, "model", lookup(res, "model", ""));
                entry=add(entry, "module", lookup(res, "module", ""));
            }
            else
            {
                ui=lookup(res, "ui", nil);
                if(ui==`abort || ui==`cancel)
                {
                    ui= `abort;
                }
                break;
            }
	    res=OneCardWizard(entry,  size(save_info), `next, 6, false, save_info);
	    if(lookup(res, "ui", `cancel)==`next)
	    {
	        entry=lookup(res, "return", $[]);
	        ui=`next;
	        break;
	    }
	    else
	    {
	        if(lookup(res, "ui", `cancel)!=`back)
	        {
	            ui=`abort;
	            break;
	        }
	    }
	}
	return $["ui": ui, "return": entry];
    }

    /** 
     * creates a list of sound modules for selection box
     * @return list of items: [`item(`id(module_name), "module label")]
     */
    global define get_module_names() ``{
	list ret=[];
	read_db();
	foreach(`e, sound_db, 
	``{
	    ret=add(ret, `item(`id(lookup(lookup(e, "module", $[]), "name", "")), lookup(e, "name", _("Unknown module name"))));
	});
	ret=sort(`a, `b, ret, ``(select(a, 1)<select(b, 1)));

	return ret;
    }

    /** returns card models list 
     *
     * @param modname if "all" returns all models
     * @return list with sound cards driven by given module
     *
     *
     */

    global define get_card_names(string modname) ``{
	read_db();
	if(modname=="all")
	{
	    list cards=[];
	    foreach(`e, sound_db,
	    ``{
		cards=add(cards, lookup(e, "cards", []));
	    });

	    cards=flatten(cards);
	    return sort(cards);
	}

	list mods=filter(`e, sound_db, 
	``(lookup(lookup(e, "module", $[]), "name", "")==modname));
	if(size(mods)==0)
	{
	    return [];
	}
	return sort(lookup(select(mods, 0), "cards", []));
    }

    /**  
     * returns module name for a given card model
     * @param string card name
     * @return modules name
     *
     */

    global define get_module_by_cardname(string cardname) ``{
	read_db();
	list mod=filter(`e, sound_db,
	``(contains(lookup(e, "cards"), cardname))
	);
	return lookup(lookup(select(mod, 0), "module", $[]), "name", "unknown");
    }

    /**
     * returns the 'params' section from sndcards.ycp of the given module
     * @param modname module name
     * @return list with params and their descriptions
     */

    global define get_module_params(string modname) ``{
	// database must be read some elsewhere
	read_db();
	list mod=filter(`e, sound_db, ``(lookup(lookup(e, "module", $[]), "name", "")==modname));
	if(size(mod)>0)
	{
	    return lookup(select(mod, 0), "params", []);
	}
	return [];
    }

    /**
     * unique key for non-pci/pnp cards or virtual cards	
     *
     */

    global define isa_uniq() ``{
	return "uniq.virtual";
    }

  /**
   * reads variables listed in 'vars' from rc.config
   * @return list
   */
    global define read_rc_vars (list vars) ``{
        return listmap (`k, vars, ``([k, SCR(`Read(topath(sformat (".rc.system.%1", k))))]));
    }

    

    /**
     *  Converts hex num to integer keeps decimal number as is. Hexadecimal
     *  number assumes to have prefix ``0x''. Doesn't  check the syntax.
     *
     */

    global define hextoi(string num) ``{
	return tointeger(num);
    }

    /**
     *  writes unique keys of the configured cards to /var/lib/YaST/unique.inf
     *  @param list of keys
     *  @return void
     *  
     *
     */

    global define save_unique_keys (list keys) ``{
        list orig = SCR(`Read(.var.lib.yast.unique));
        if (orig==nil)
        {
            orig = [];
        }
        list keys = maplist (`e, keys, ``($["unique" : e, "state" : "configured"]));
        orig = filter (`e, orig, ``(lookup(e, "section", "") != "sound"));
	list final=add (orig, $["contents" : keys, "section" : "sound"]);
        SCR(`Write(.var.lib.yast.unique, final));
    }


    /**
     * loads sound card database to global variable sound_db
     * @return list
     */

    global define GetCardDatabase() ``{
	textdomain "sound_db";
	y2debug("Reading card database");
	sound_db=eval(SCR(`Read (.target.yast2, "sndcards.ycp")));
	textdomain "sound";
//	return database;
    }

    /** 
     * function for reading sound_db on demand
     * checks if sound_db is empty. if true, loads the database
     * to it. otherwise does nothing
     *
     */

    global define read_db() ``{
	if(sound_db==nil || size(sound_db)==0)
	{
	    GetCardDatabase();
	}
    }

    /**
     * Used for searching. returns index of the card in the database identified by name
     * @return integer
     */

    global define search_card_id (string name) ``{
        list all_cards = get_cards ("all");
        integer pos = 0;
        integer len = size (name);
	name = tolower(name);
	integer bound = size (all_cards);
        while (pos < bound)
        {
            if (substring (tolower(select (all_cards, pos)), 0, len) == name)
            {
                return pos;
            }
            pos = pos + 1;
        };
        return -1;
    }

    /**
     * returns list of sound cards. get_cards("all") returns all cards
     * @return list
     */

    global define get_cards (string module_name) ``{
        list ret = [];

	read_db();
        if (tolower(module_name) == "all")
        {	// copy the whole database
        maplist (`e, sound_db,
            ``{
                if (size (lookup (e, "cards", [])) > 0) ret = add (ret, lookup (e, "cards"));
                else ret = add (ret, [lookup (e, "name", "")]);
            });
        }
        else
        {	// filter by name 
            ret = maplist (`c, filter (`e, sound_db, ``(lookup (e, "name", "") == module_name)), ``(lookup (c, "cards", [])));
            ret = filter (`e, ret, ``(size(e) > 0));

            if (size (ret) == 0)
            {
                ret = add (ret, [module_name]);
            }
        }
        return sort(flatten(ret));
    }

    /**
     * Itemize list for selection box
     * @return list
     */
    global define itemize_list (list l, integer default) ``{
        integer i = 0;
        list itemized_list = [];
        integer s = size (l);
        while (i < s)
        {
            itemized_list = add (itemized_list, `item (`id(i), select (l, i), (i == default)));
            i = i + 1;
        }
        return itemized_list;
    };



    /**
     *  Returns list of already running cards
     *  @return list
     *  
     *
     */

    global define get_running_cards () ``{
        if (fileexist("/proc/asound/cards"))
        {
            list asound = SCR(`Read(.proc.asound.cards));
            if (is(select (asound, 0), map))
            {
                return asound;
            }
        }
        return [];
    }


    /**
     * Returns list of keys read from /var/lib/YaST/unique.inf
     * @return list with unique keys
     */

    global define read_unique_keys () ``{
	list already = [];
	if (SCR(`Read(.target.size, "/var/lib/YaST/unique.inf")) > 0)
	{
	    already = SCR (`Read(.var.lib.yast.unique));
	}
	else
	{
	    already = [];
	}
	// select the sound section

	list output=[];

	already = filter(`e, already, ``(lookup(e, "section", "")=="sound"));
	if(size(already)==0) return [];
	already = lookup(select(already, 0), "contents", []);
	already = maplist(`e, already, 
	``{
	    if(lookup(e, "state", "")=="configured")
	    {
		output=add(output, lookup(e, "unique", nil));
	    }
	}

	);

	already=output;

	return already;
    }

    /**
     *  @return boolean
     *  
     *
     */

    global define nm256hack (string modname) ``{
        if (modname == "snd-card-nm256")
        {
            // special warning message for in a special case
            string warn_text=lookup(STRINGS, "nm256hackWarning", "");
	    return UI(`YesNoPopup(warn_text));
        }
        return true;
    }




    /**
     * same as  ()?():(); statement in c
     * @return any
     */
    global define condition (boolean c, any s1, any s2) ``{
	if (c) 
	{ 
	    return eval (s1);
	}
	else
	{
	    return eval (s2);
	}
    };


    /**
     * This is no alsa hack function
     * @return map
     */
    global define no_alsa (string mod_name) ``{
	return $[
	    "modules" : [
		$["name"   : mod_name,
		 "modules" : $["alias" :  "char-major-14"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "sound"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "midi"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "sound-slot-0"]],
		$["name"   : mod_name,
		 "modules" : $["alias" :  "sound-service-0-0"]]	    
		],
	    "volume" : $[
		"mixer" : "/usr/bin/aumix \"$CHANNEL\" $VOLUME"
		]
	    ];
    }

    /** 
     * returns list of detected soundcards
     *
     * return example:
     *          [       
     *          "bus"           : "PCI",
     *          "device"        : "ES1371 [AudioPCI-97]",
     *          "device_id"     : 70513,
     *          "resource"      : $["io":[$["active":true, "length":0, "mode":"rw", "start":28672]],
     *                             "irq":[$["count":0, "enabled":true, "irq":10]]],
     *          "rev"           : "6",
     *          "sub_device"    : "Creative Sound Blaster AudioPCI64V, AudioPCI128",
     *          "sub_device_id" : 70513,
     *          "sub_vendor"    : "Ensoniq",
     *          "sub_vendor_id" : 70260,
     *          "vendor"        : "Ensoniq",
     *          "vendor_id"     : 70260,
     *          "unique_key"    : "test.test",
     *          "module"        : $["name":"eps23"]]
     *          ]
     */

    global define get_audio() ``{
        string tmpdir=SCR (`Read (.target.tmpdir));
        if(fileexist(tmpdir+"/audio.ycp"))
        {
            return SCR(`Read(.target.ycp, tmpdir+"/audio.ycp"));
        }

        list ret = SCR(`Read(.probe.sound));
        if (ret==nil) ret = [];
        SCR(`Write(.target.ycp, tmpdir+"/audio.ycp", ret));
        return ret;
    }


    /**
     * runs a perl script 'fetchmodule' and returns a sndcards-like module record    
     * for a non-alsa module
     * @param 1st modude name (eg. 'cs4231')
     */

    global define fetchmodule(string modname)
    ``{
	string tmpdir=SCR (`Read (.target.tmpdir));
	SCR (`Execute (.target.bash, sformat ("/usr/bin/fetchmodule %1.o > %2/mod.ycp" , modname, tmpdir)));
	{
	    map out=SCR(`Read(.target.ycp, tmpdir+"/mod.ycp"));
	    return UI(out);
	}
	return [];
    }

    /**
     * Looks up in the database for the module
     * @return map
     */
    global define get_module (map card) ``{
	read_db();

	string bus        = lookup (card, "bus", "");
	integer offset    = condition ((tolower (bus) == "isa"), 0x20000, 0x10000);
	integer vendor_id = lookup (card, "vendor_id", 0);
	integer device_id = lookup (card, "device_id", 0);

	list fc = [];
	if (tolower (bus) == "pci") 
	{
	    fc = filter (`d, sound_db, 
		 ``(filter(`c, lookup (d, "libhd", []), 
		    ``((lookup (c, "vendor_id", 0) == vendor_id - offset) && 
		       (contains(lookup(c, "device_id", 0), device_id - offset)))) != []));
	}
	else 
	{
	    fc = filter (`d, sound_db, 
		   ``(filter(`c, lookup (d, "libhd", []), 
			``((lookup (c, "vendor_id", 0) == vendor_id - offset) &&
			   (lookup (c, "device_id", 0) == device_id - offset))) != []));
	}

	if (fc!=nil)
	{
	    if (size (fc) > 0) return select (fc, 0);
	}

	return $[];
    }

    /**
     * volume in percents (0..100)
     * @return any
     */
    global define SetVolume (string group, integer cardid, integer value) ``{
	string p=sformat(".audio.alsa.cards.%1.channels.%2.volume", cardid, group);

	SCR(`Write(topath(p), value));
    }

    global define SetVolumeFast(integer cardid, integer value) ``{
	string p=sformat(".target.volume.%1", cardid);
	if(value>=100)
	{
	    value=99;
	}
	if(value<0)
	{
	    value=0;
	}
	SCR(`Write(p, value));
    }

    global define unmute(list devices, integer card_id) ``{
	foreach(`dev, devices,
	``{
	    SCR(`Write(topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", card_id, dev)), false));
	});
    }

    /**
     * stores the volume to file. stored volume will be 
     * restored after reboot
     *
     */

    global define storeVolume(integer card_id) ``{
	if(card_id==-1)
	{
	    SCR(`Execute(.audio.alsa.store, 0, 0));
	}   
	string p=sformat(".audio.alsa.cards.%1.store", cardid);
	SCR(`Execute(topath(p), 0, 0));
    }

    /**
     * here the test sound is played, by
     * default ist alsa whistle sound, but
     * if snd_au package is installed,
     * than it's Linus Torvals voice, the
     * if the test file cannot be found,
     * the message is displayed
     *
     * @return string returns empty string on succes, otherwise error string 
     */

    global define PlayTest (map user_settings, integer card_id) ``{

        if (!fileexist(lookup (user_settings, "audio_file", "")))
        {
            string file = lookup (user_settings, "audio_file", "");

                  // To translators: just one file will be displayed
                  // To translators: if the test audio file can not be found this message is displayed
                  // To translators: This is just popup message, shouldn't be too long
            string msg = sformat (_("Cannot find file:\n %1\n\n(test audio file)"), file);

            return msg;
        }
        else
        {
            string audio_file = lookup (user_settings, "audio_file", "");
                  // more cards
	    SCR(`Execute (.target.bash_background, sformat("aplay -c %1 %2 ", card_id, audio_file)));
        }
        return "";
    };


    /**
     *  Checks whether the module has been successfully loaded
     *
     * @return empty string on success/ error message on failure
     */ 

    global define check_module(map save_entry) ``{
	// TODO: check by /proc/asound/cards
	map pm = SCR(`Read(.proc.modules));
	string mod_name=lookup(save_entry, "module", "off");
        if (!haskey (pm, mod_name))
        {

                // To translators: label to error popup
            return sformat (_("The kernel module %1 for sound support
could not be loaded. This can be caused by incorrect
module parameters, including invalid IO or IRQ parameters."), mod_name);
        }
        return "";

    }


    /** creates itemized table entries,
     *  @param lm list of maps to take keys from
     *  @param lk list of keys to look for in 1st param
     * 
     *  @return list
     */

    global define create_table (list lm, list lk)
    ``{
	list res=[];
	integer pos=0;
	foreach(`m, lm, 
	``{
	    res=add(res, `item(`id(pos), 
		lookup(m, select(lk, 0), ""),
		lookup(m, select(lk, 1), ""),
		lookup(m, select(lk, 2), "")
		));
	    pos=pos+1;
	});
	return res;
    }

    /* 
     * tries to extract list of values from description
     * these values are generated from alsa modules
     * and can be in form
     * [list=value,value,..] or
     * [range=1-19] or something not recognized
     * @return list
     */
    global define parse_values (string des) ``{
        list ret = [];
        integer pos = 0;
        integer len = size (des);
        while ((pos < len) && (substring (des, pos, 1) != "["))
        {
            pos = pos + 1;
        }
        pos = pos + 1;

        if (pos < len)          // found "["
        {
            if (tolower(substring (des, pos, 5)) == "list=")
            {
                pos = pos + 5;
                integer s = pos;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == ",")
                    {
                        ret = add (ret, hextoi (substring (des, s, pos - s)));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                ret = add (ret, hextoi (substring (des, s, pos - s)));
            }
            else if (tolower(substring (des, pos, 6)) == "range=")
            {
                pos = pos + 6;
                integer s = pos;
                integer range_start = 0;
                while ((pos < len) && substring (des, pos, 1) != "]")
                {
                    if (substring (des, pos, 1) == "-")
                    {
                        range_start = tointeger(substring (des, s, pos - s));
                        s = pos + 1;
                    }
                    pos = pos + 1;
                }
                integer range_stop = tointeger(substring (des, s, pos - s));
                                        // now create the range list
                while (range_start <= range_stop)
                {
                    ret = add (ret, range_start);
                    range_start = range_start + 1;
                }
            }
	    else if (tolower(substring (des, pos, 4)) == "bool")
            {
                ret = [0, 1];
            }
        }

        return ret;
    }
 
  /**
   * "sformates" list from sound database, where are localized messages, with 
   * optional formating information
   * @return string
   * @example mysformat(["Message %1 %2 %3", "A", "B", "C"])  ->  "Message A B C"
   */
    global define mysformat (list msg)
    ``{
        if (size (msg) == 0)
        {
            return "";
        }

//        term format = ``(sformat (select(msg, 0)));
	term format=``(sformat());

        integer i = 0;
        while (i < size (msg))
        {
            format = add (format, select (msg, i));
            i = i + 1;
        }
        return eval (format);
    }

    /**
     * checks whether param #1 is if type of param #2
     * @param 1st value
     * @param 2nd expected type. one of {int, string}
     * @param 3nd if poss is nonempty, checks if value is one of them
     * returns error message, empty string if ok
     * @return string
     */
    global define check_value (string value, string type, list poss) ``{
        if (type == "int")
        {
            if (tolower(substring (value, 0, 2)) == "0x")               // hex number
            {
                string rest = tolower(substring (value, 2));
                if (filterchars(rest, "0123456789abcdef") != rest)
                {
                      // To translators: popup message, wrong value
                      return sformat (_("The value: %1 must be a number"), value);
                }
            }
            else                // decimal number
            {
                string rest = value;
                if (substring (value, 0, 1) == "-")      // negative number
                {
                    rest = substring (value, 1);
                }
                if (filterchars(rest, "0123456789") != rest)
                {
                            // To translators: popup message, wrong value
                    return sformat (_("The value: %1 must be a number"), value);
                }
            }
        }
        else if (type == "string")
        {
            if (filterchars (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789") != value)
            {

                integer wrong_pos = findfirstnotof (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789");
                string wrong_char = substring (value, wrong_pos, 1);
                if (wrong_char == " ")
                {
                                        // To translators: "space" means blank character
                    wrong_char = wrong_char + " " + _("(space)");
                }
                        // To translators: popup message, wrong value
                return  sformat (_("String cannot contain: %1"), wrong_char);
            }
        }

                                    // now check for poss list
        if (size (poss) > 0)
        {
            list poss_list = [];

            if (type == "int")
            {
                poss_list = maplist (`v, poss, ``(hextoi (value) == v));
            }
            else
            {
                poss_list = maplist (`v, poss, ``(value == v));
            }

            if (!contains (poss_list, true))
            {
                      // To translators: popup message, wrong value
                return sformat (_("The value must be one of %1"), poss);
            }
        }

        return "";              // ok :-)

    }

    /**
     * inserts values to already set options
     * @param 1st save_info entry
     *
     *
     */

    global define restore_mod_params(list params, map values) ``{
	return maplist(`e, params,
	``{
	    string pname=lookup(e, "name", "");
	    e=add(e, "value", lookup(values, pname, ""));
	    return e;
	});

    }
 
    /** get_tmp_modules_conf returns path to the temporary modules.conf
     */
    
    global define get_tmp_modules_conf() ``{
	string tmpdir=SCR (`Read (.target.tmpdir));
	// TODO: move this file to yast tmp dir
	return "/tmp/modules.conf";
    }

    /**
     * alsasound_start_tmp starts alsa using temporary modules.conf
     * @param restore true - call alsactl restore, false - don't
     *
     *
     */

    global define alsasound_start_tmp(boolean restore) ``{
	string cmd="/sbin/depmod -C "+get_tmp_modules_conf();
	SCR(`Execute(.target.bash, cmd, $[]));

	list als=SCR(`Read(.tmp.modules.alias));

	
	string modname="";
	integer pos=0;
	map res=$[];
	while(contains(als, sformat("snd-card-%1", pos)))
	{
	    modname=SCR(`Read(.tmp.modules.alias, sformat("snd-card-%1", pos)));
	    cmd=sformat("/sbin/modprobe -C %1 %2", get_tmp_modules_conf(), modname);
	    res=SCR(`Execute(.target.bash_output, cmd, $[]));
	    if(lookup(res, "stderr", "")!="")
	    {
		y2error("modprobe error output: \n"+lookup(res, "stderr", ""));
	    }
	    pos=pos+1;
	}


	if(restore)
	{
	    SCR(`Execute(.audio.alsa.restore, 0, 0));
	}
    }

    /** 
     *	@return true if the fonts have already been installed
     *	
     */

    global define FontsInstalled() ``{
	return fileexist("/usr/share/sfbank/creative");
    }

    /** @return true if the sound card supports sound fonts
     */

    global define HasFonts(map save_entry) ``{
	if(lookup(save_entry, "module", "")=="snd-card-emu10k1")
	{
	    return true;
	}
	if(lookup(save_entry, "module", "")=="snd-card-sbawe")
        {
            return true;
        }   
	return false;
    }

    /** this small wizard will install sound fonts for soundblaster live/awe
     *  @param symlink is path to default.sf2 that is to be created
     */

    global define InstallFonts(string symlink, boolean dontask) ``{
	boolean answer=false;

	// step 1: want install?
	if(dontask)
	{   
	    answer=true;
	}
	else
	{
	    answer=UI(`YesNoHeadlinePopup(	lookup(STRINGS, "soundFontTitle", ""), 
					lookup(STRINGS, "soundFontQuestion", "")));
	}
	
	if(!answer) 
	{
	    return;
	}

	boolean succes=false;

	while(true)
	{
    		// step 2: insert CD
	    answer=UI(`ContinueCancelHeadlinePopup (lookup(STRINGS, "soundFontTitle", ""), 
						    lookup(STRINGS, "soundFontAppeal", "")));
	    if(!answer)
	    {
		return;
	    }

	    // step3: do something 
	    map res=SCR (`Execute (.target.bash_output, "/usr/lib/YaST2/bin/copyfonts", $[] ));
	    integer cnt=tointeger(lookup(res, "stdout", 0));
	    
	    // step4: 
	    if(cnt>0)
	    {
		UI(`MessagePopup(sformat(lookup(STRINGS, "soundFontFinal", ""), cnt, "/usr/share/sfbank/creative")));
		return;
	    }
	    else
	    {
		answer=UI(`YesNoHeadlinePopup(  lookup(STRINGS, "soundFontNotFound", ""),
						lookup(STRINGS, "soundFontRetry", "")));
		if(!answer)
		{
		    return;
		}
	    }
    
	}
    }

    /**
     *  helping hand for order_cards_by_uniques
     *  returns true, if unique_key1 is before unique_key2 in uniques list
     */

    global define uniq_order(string key1, string key2, list uniques) ``{


	integer i=0;
	while(i<size(uniques))
	{
	    if(select(uniques, i)==key2) return false;
	    if(select(uniques, i)==key1) return true;
	    i=i+1;
	}
	return true;
    }

    /**
     * shows warning message when both nm265 and opl3sa2 cards are present
     * @param cards list of sound cards
     */
    
    global define nm256_opl3sa2_warn(list sound_cards) ``{
	list s1=filter(`e, sound_cards, 
	    ``(lookup(lookup(lookup(e, "module", $[]), "module", $[]), "name", "")=="snd-card-nm256"));
	list s2=filter(`e, sound_cards, 
	    ``(lookup(lookup(lookup(e, "module", $[]), "module", $[]), "name", "")=="snd-card-opl3sa2"));

	if(size(s1)>0 && size(s2)>0)
	{
	    string name1=mergestring(splitstring(hardware_name(select(s1, 0)), "\n"), " ");
	    string name2=mergestring(splitstring(hardware_name(select(s2, 0)), "\n"), " ");
	    UI(`MessagePopup(sformat(lookup(STRINGS, "opl3sa_nm256_warn", ""), name1, name2)));
	}
    }

    
    /**
     *	when user wants to delete a card, all cards using given module must be removed.
     *  this function returns list of positions of cards using the module
     *  @param	save_info 
     *	@param	module_name
     *  @return list of integers
     */

    global define get_indices_for_removal(list save_info, string mod_name)
    ``{
	list ret=[];
	integer pos=0;
	maplist(`e, save_info, 
	``{  
	    if(lookup(e, "module", "")==mod_name)
	    {
		ret=add(ret, pos);
	    }
	    pos=pos+1;
	});
	return ret;
    }

    /**
     * remove memebers listed in id_list list
     *
     *
     */

    global define multi_remove(list input, list id_list) ``{
	id_list=sort(`x, `y, id_list, ``(x>=y));
	maplist(`e, id_list, ``{if(e<size(input)) input=remove(input, e); });
	return input;
    }

    /**
     * removes entries from save_info listed by indices in id_list 
     *
     *
     */

    global define remove_save_entries(list save_info, list id_list)
    ``{
//	id_list=sort(`x, `y, id_list, ``(x>=y));

//	maplist(`e, id_list, ``{if(e<size(save_info)) save_info=remove(save_info, e); });

	save_info=multi_remove(save_info, id_list);

	integer pos=0;
	save_info=maplist(`e, save_info, 
	``{
	    map opts=lookup(lookup(e, "modules", $[]), "options", $[]);
	    opts=add(opts, "snd_index", sformat("%1", pos));
	    opts=add(opts, "snd_id", sformat("card%1", pos+1));
	    e=add(e, "alias", sformat("snd-card-%1", pos));
	    e=add(e, "options", opts);
	    pos=pos+1;
	    return e;
	});
	return save_info;
    }

    /**
     * stops all programs using sound devices
     * @return true if nothing's using sound, false otherwise
     *
     */

    global define stop_programs() ``{
	integer fuser = SCR(`Execute (.target.bash, "/bin/fuser /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]));

	if (fuser == 0)
        {
                  // To translators: To reset the sound configuration these programs must be terminated
                  // To translators: label message
	    string msg=lookup(STRINGS, "WhichDialogMsg");
                  // Yes, No - button labels
            boolean terminate = UI(`YesNoPopup (msg));
            if (terminate)
            {
		SCR(`Execute (.target.bash, "/bin/fuser -k /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]));
            }
            else
            {
		return false;
            }
        }
	return true;
    }
    
    /**
     * creates hardware-summary-like list of configured cards
     *
     * @return richtext
     * @param seva_info
     */

    global define ConfCardsRT(list save_info) ``{
	list retlist=[];
	list conflist=[];
	foreach(`entry, save_info,
	``{
	    conflist=add(conflist, lookup(entry, "model", ""));
	});
	integer i=0;
	foreach(`card, conflist,
	``{
	    // to translators: '(sound card is) Configured as snd-card-1'
	    retlist=add(retlist, summaryDevice(card, sformat(_("Configured as snd-card-%1."), i)));
	    i=i+1;
	});

	return summaryDevicesList(retlist);

    }

}

