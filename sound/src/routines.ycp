/**
 * File:
 *   routines.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Routines for sound card configuration
 *
 * Authors:
 *   Dan Veselý <dan@suse.cz>
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 */

{
    import "Directory";
    import "Mode";
    import "Popup";
    import "Sound";

    textdomain "sound";


    // list of all card models (generated only once and cached)
    global list all_card_names = [];

    /**
     * returns cards manufactured by given vendor
     * @param vendor if "all" returns all models
     * @return list with sound card models
     */
    global define list get_card_names (string vendor) ``{

	// when called from ManualDialogModules, parameter is name of module,
	// otherwise (from ManualDialogModules) it is vendor

	if (!Sound::use_alsa)
	    return [sformat("Sound card (%1)", vendor)];

	Sound::LoadDatabase(true);
        if (vendor == "all" || vendor == "")
        {
	    if (all_card_names == [] || all_card_names == nil)
	    {
		// use card names from db_cards (they contain the vendor name)
		all_card_names = maplist (integer k, list v, Sound::db_cards,
		    ``(v));
		all_card_names = sort ((list)flatten (all_card_names));
	    }
	    return all_card_names;
        }
	else
	{
	    // names from db_vendors (vendor name not included - not necessary)
	    return sort (Sound::db_vendors[vendor]:[]);
	}
    }

    /**
     *  Returns list of already running cards
     *	(oss is nasty hacked, because it's not trivial to check this)
     *  @return list
     */
    global define list get_running_cards () ``{

	if (!Sound::use_alsa)
	    return [1,2,3,4,5];

	path proot = .audio.alsa.cards;
	list cards = SCR::Dir (proot);

	return maplist(string c, cards, ``($[
	    "number"	: tointeger (c),
	    "name"	: SCR::Read (add(add(proot, c), "name"))
	]));
    }

    /** ALSA only
     * Checks if name of parameter is in correct form (has 'snd_' prefix)
     * and updates it if necessary
     * @param parname original name of parameter
     * @return correct name
     */
    global define string check_parameter_name (string parname) ``{

	boolean prefix_used = Sound::snd_prefix_used ();
	if (substring (parname, 0, 4) == "snd_" && !prefix_used)
	    parname = substring (parname, 4);
	else if (prefix_used && substring (parname, 0, 4) != "snd_")
	    parname = sformat ("snd_%1", parname);

	return parname;
    }

    /**
     * returns the 'params' section from sndcards.ycp of the given module
     * @param modname module name
     * @return map with params and their descriptions
     */
    global define map get_module_params(string modname) ``{

	if (!Sound::use_alsa)
	{
	    map params = (map) SCR::Read (
		topath(sformat(".modinfo.kernel.drivers.sound.%1", modname)));
	    params = filter(string k, string v, params, ``(
		!contains(["module_author","module_description","module_filename"],k)
	    ));
	    return mapmap (string name, string desc, params, ``(
		$[ name: $[
			"name"	: name,
			"descr"	: [desc],
			"type"	: "string" ]
		]
	    ));
	}

	Sound::LoadDatabase(true);
	map params = Sound::db_modules[modname, "params"]:$[];

	// change the names of parameters if necessary
	return mapmap (string parname, map parsettings, params, ``{
	    parname = check_parameter_name (parname);
	    return $[ parname : parsettings ];
	});
    }

    /**
     * adds alias to save_info entry
     * @param entry card config
     * @param card_id card id
     * @return map modified card entry with filled alias value
     */
    global define map add_alias(map entry, integer card_id) ``{

	if (!Sound::use_alsa)
	    return add(entry, "alias", sformat("sound-slot-%1", card_id));
	else
	    return add(entry, "alias", sformat("snd-card-%1", card_id));
    }

    /**
     *  adds common options for module. for alsa it is 'snd_index=${card_id}'
     *  @param entry card config
     *  @param card_id card id
     *  @return map modified save_entry
     */
    global define map add_common_options(map entry, integer card_id) ``{

	map opts = entry["options"]:$[];

	if (!Sound::use_alsa)
	{

	    map parms = get_module_params(entry["module"]:"");
	    if (size(parms) != 0)
	    {
		map enab = filter (string name, map e, parms,
		    ``(name == "snd_enable"));
		if (size(enab) != 0)
		    opts = add(opts, "snd_enable", "1");
	    }
	    entry = add(entry, "options", opts);
	    return entry;
	}

	opts = add (opts, Sound::snd_prefix() + "index",sformat ("%1",card_id));
	opts = add (opts, Sound::snd_prefix() + "enable", "1");

	entry = add(entry, "options", opts);
	return entry;
    }

    /**
     * Simply returns list with ALSA OSS/Free emulation modules
     * @param number number of sound cards
     * @return list of oss-alsa aliases
     */
    global define list alsa_oss (integer number) ``{

	if (!Sound::use_alsa)
	    return [];

        list modules = [];
        integer i = 0;
        // map with minor as a key and module as value
        map oss_list = $[
            0  : "snd-mixer-oss",
            11 : "snd-mixer-oss",
            3  : "snd-pcm-oss",
            12 : "snd-pcm-oss",
            1  : "snd-seq-oss",
            8  : "snd-seq-oss"
            ];

        while (i < number)
        {
            modules = add (modules, $[
		    "alias"	: sformat ("sound-slot-%1", i),
		    "module"	: sformat ("snd-card-%1", i) ]
	    );
            foreach(integer key, string mod, oss_list, ``{
                modules = add (modules, $[
		    "alias"	: sformat("sound-service-%1-%2", i, key),
		    "module"	: mod]
		);
            });
            i = i + 1;
        }
        return modules;
    }

    /**
     * returns list of all available sound modules (OSS only)
     * @return list as above
     */
    global define list get_module_names() ``{

	if (Sound::use_alsa)
	    return [];

	if (all_card_names == [] || all_card_names == nil)
	{
	    list ret = SCR::Dir(.modinfo.kernel.drivers.sound);
	    ret = filter(string mod, ret, ``(mod != "sound"));
	    ret = add(ret, "emu10k1");
	    ret = add(ret, "cs4281");
	    ret = maplist(string e, ret,``{
		string descr = lookup(
		    (map)SCR::Read(add(.modinfo.kernel.drivers.sound, e)),
		    "module_description", "");
		return
		    `item(`id(e), (descr != "" && descr != "<none>")? descr: e);
	    });
	    ret = sort(term a, term b, ret,
		``(select(a, 1, "") < select(b, 1, "")));
	    all_card_names = ret;
	}
	return all_card_names;
    }

    /**
     * get_vol_settings
     * creates a list of stored values of volume and mute for each channel
     * of each card.
     * example: [
		    [ ["PCM", 32, false], ["Master", 100, true]],
		    [ [....], .....                            ]
		]
     * @return list as above
     */
    global define list get_vol_settings() ``{

	if (!Sound::use_alsa)
	    return [];

	Sound::LoadDatabase(true);
	integer bound	= size(SCR::Dir(.audio.alsa.cards));
	integer i	= 0;
	list retlist	= [];
	while (i < bound)
	{
	    list sublist = [];
	    string modname = Sound::modules_conf[i,"module"]:"snd-dummy";
	    list chans = Sound::db_modules[modname, "mixer_elements"]:[];

	    if (chans == [])
	    {
		if (contains(SCR::Dir(.audio.alsa.cards), sformat("%1", i)))
		{
		    chans = SCR::Dir(topath(
			sformat(".audio.alsa.cards.%1.channels", i)));
		}
		else
		{
		    chans = [];
		}
	    }

	    foreach (string e, chans, ``{
		path pth1 = topath(sformat(".audio.alsa.cards.%1.channels.%2.volume", i, e));
		path pth2 = topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", i, e));
		sublist = add(sublist, [e, SCR::Read(pth1), SCR::Read(pth2)]);
	    });
	    retlist = add (retlist, sublist);
	    i = i + 1;
	}
	return retlist;
    }

    /**
     * stores values generated by get_vol_settings
     * @param vol_settings volume settings
     * @return boolean success/failure
     */
    global define boolean set_vol_settings(list vol_settings) ``{

	if (!Sound::use_alsa)
	    return true;

	integer i = 0;
	foreach(list channels, vol_settings, ``{
	    foreach(list channel, channels, ``{
		string name = channel[0]:"Master";
		path pth1 = topath (
		    sformat(".audio.alsa.cards.%1.channels.%2.volume", i,name));
		path pth2 = topath (
		    sformat(".audio.alsa.cards.%1.channels.%2.mute", i, name));
		SCR::Write (pth1, channel[1]:0);
		SCR::Write (pth2, channel[2]:false);
	    });
	    i = i + 1;
	});
	SCR::Execute(.audio.alsa.store, nil);
	return true;
    }


    /**
     * common function to extract 'name' of hardware
     * @param hardware_entry map
     * @return string readable name of the card
     */
    global define string hardware_name (map hardware_entry) ``{

	y2debug("hardware_entry: %1", hardware_entry);

        string sub_vendor	= hardware_entry["sub_vendor"]:"";
	string sub_device	= hardware_entry["sub_device"]:"";
	string vendor		= hardware_entry["vendor"]:"";
	string device		= hardware_entry["device"]:"";

        if ((sub_vendor != "") && (sub_device != ""))
            return (sub_vendor + "\n" + sub_device);
        else if ((vendor == "") && (device == ""))
	{
	    string model	= hardware_entry["model"]:"";
	    string module_desc	= hardware_entry["module", "description"]:"";

	    return (size(model) > 0 && size(module_desc) > 0) ?
		model + " - " + module_desc : model + module_desc;
	}
	else return vendor + ((vendor != "") ? "\n" : "") + device;
    };


    /**
     * filters out already configured cards
     * @param save_info info from modules.conf
     * @param cards autodetected cards
     * @return list of entries of not configured cards
     */
    global define list filter_configured(list save_info, list cards) ``{

        return filter(map det_card, cards, ``{
            string uniq     = det_card["unique_key"]:"";
            boolean retval  = true;
            foreach(map saved_card, save_info, ``{
                if (saved_card["unique_key"]:"" == uniq)
                {
                    retval = false;
                }
            });
            return retval;
        });
    }

    /**
     * returns the result of /usr/bin/whoami. currently broken. no idea why...
     * @return string username
     */
    global define string whoami() ``{
	map ret	= (map)SCR::Execute(.target.bash_output,"/usr/bin/whoami", $[]);
	string out = ret["stdout"]:"";
	list l = splitstring(out, "\n");
	if (size(l) > 0)
	{
	    return l[0]:"dontknow";
	}
	return "";
    }

    /**
     * for a given card detected by libhd this function creates a label
     * @param card map entry from .probe.audio
     * @return string card label
     */
    global define string get_card_label(map card) ``{

        list lab = splitstring(hardware_name(card),"\n");

	y2debug("Card label: %1", lab);

	if (size(lab) == 0 )
	{
	    return "";
	}
        if (size(lab) == 1 || lab[1]:"" == "")
        {
            return lab[0]:"";
        }
        return lab[1]:"";
    }

    /**
     * returns true if given string is valid sound alias
     * (snd-card-1 .. snd-card-16)
     * @param alias string
     * @return boolean is/is not
     */
    global define boolean is_snd_alias(string alias) ``{
	if (Sound::use_alsa)
	{
	    return regexpmatch(alias, "^snd-card-[0-9]*$");
	}
	else
	{
	    return regexpmatch(alias, "^sound-slot-[0-9]*$");
	}
    }

    /**
     * unique key for non-pci/pnp cards or virtual cards
     * @return string key for legacy isa cards
     */
    global define string isa_uniq() ``{
	return "uniq.virtual";
    }

    /**
     * reads variables listed in 'vars' from rc.config
     * @return map optname: value
     */
    global define map read_rc_vars () ``{

	return $["LOAD_ALSA_SEQ" : SCR::Read(.sysconfig.sound.LOAD_SEQUENCER)];
    }

    /**
     * saves uniq keys to .probe.status
     * @param configured list of strings of configured cards uniq keys
     * @param unconfigured list of string of unconfigured cards uniq keys
     * @return boolean true
     */
    global define boolean SaveUniqueKeys(list configured, list unconfigured) ``{
        maplist (string uk, configured, ``{
            SCR::Write(.probe.status.configured, uk, `yes);
        });

        maplist(string uk, unconfigured, ``{
            SCR::Write(.probe.status.configured, uk, `no);
        });

        return true;
    }



    /**
     * Used for searching. returns index of the card in the database
     * identified by name (more exactly: returns index of first name matching
     * the given substring)
     * @param name card name (or its substring)
     * @return integer position of the card
     */
    global define integer search_card_id (string name) ``{
        list all_cards = get_card_names ("all");
        integer pos = 0;
        integer len = size (name);
	name = tolower(name);
	integer bound = size (all_cards);
        while (pos < bound)
        {
            if (substring (tolower(all_cards[pos]:""), 0, len) == name)
            {
                return pos;
            }
            pos = pos + 1;
        };
        return -1;
    }

    /**
     * Itemize list for selection box
     * @param l list with values
     * @param default value to select as default
     * @return list items to be shown in list widget
     */
    global define list itemize_list (list l, integer default) ``{
        integer i = 0;
        list itemized_list = [];
        integer s = size (l);
        while (i < s)
        {
            itemized_list = add (itemized_list,
		`item (`id(i), select (l, i, ""), (i == default)));
            i = i + 1;
        }
        return itemized_list;
    };


    /**
     *	show a warning popup for nm256 snd cards if needed
     *  @param modname string module name
     *  @return boolean continue/abort
     */

    global define boolean nm256hack (string modname) ``{
        if (modname == "snd-nm256")
        {
            // special warning message for in a special case
            string warn_text = Sound::STRINGS["nm256hackWarning"]:"";
	    return Popup::YesNo(warn_text);
        }
        return true;
    }

    /**
     * Looks up in the database for the module
     * @param card map read from .probe.sound
     * @return map relevant card info found in db
     */
    global define map get_module (map card) ``{

	Sound::LoadDatabase (true);

	string bus        = card["bus"]:"";
	integer offset    = (tolower (bus) == "isa") ? 0x20000 : 0x10000;
	integer vendor_id = card["vendor_id"]:0 - offset;
	integer device_id = card["device_id"]:0 - offset;

	map m1 = Sound::db_indices[vendor_id]:$[];
	if (m1 == $[])
	{
	    y2debug("vendor_id not found...");
	    return $[];
	}

	integer m2 = m1[device_id]:-1;
	if (m2 == -1)
	{
	    y2debug("device_id not found");
	    return $[];
	}

	string modname = Sound::db_module_index [m2]:"";

	map ret = Sound::db_modules [modname]:$[];

	if (ret != $[] && !haskey(ret, "name"))
	{
	    // we must supply the 'name' key with the module name
	    ret = add(ret, "name", modname);
	}

	return ret;
    }

    /**
     * umnute channel 'devide' of the 'card_id'-th sound card. alsa only
     * @param devices list of channels to be unmuted
     * @param card_id of the card
     * @return void
     */
    global define void unmute(list devices, integer card_id) ``{
	if (Mode::config)
	{
	    return;
	}

	list avail = SCR::Dir(topath(sformat(".audio.alsa.cards.%1.channels", card_id)));
	if (avail == nil || size(avail)==0)
	{
	    avail = [];
	}
	foreach(`dev, devices,
	``{
	    if (contains(avail, dev))
	    {
		SCR::Write(topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", card_id, dev)), false);
	    }
	});
    }


    /**
     * Checks whether the module has been successfully loaded
     *
     * @param save_entry card config map
     * @param card_id card id
     * @return string empty on success/ error message on failure
     */
    global define string check_module(map save_entry, integer card_id) ``{
	map pm		= (map) SCR::Read(.proc.modules);
	string mod_name	= save_entry["module"]:"off";
        if (!haskey (pm, mod_name) || size(get_running_cards()) <= card_id)
        {

                // To translators: label to error popup
            return sformat (_("The kernel module %1 for sound support
could not be loaded. This can be caused by incorrect
module parameters, including invalid IO or IRQ parameters."), mod_name);
        }
        return "";

    }

    /**
     * inserts values to already set options
     * @param params list with available options for module
     * @param values values that have been already set
     * @return map with refreshed options
     *
     */
    global define map restore_mod_params(map params, map values) ``{
	return mapmap(string parname, map parmap, params, ``{
	    parmap = add (parmap, "value", values[parname]:"");
	    return $[parname : parmap];
	});
    }

    /**
     *  checks whether sound fonts have already been installed
     *	@return boolean already installed/not installed
     *
     */

    global define boolean FontsInstalled() ``{
	return SCR::Read(.target.size, "/usr/share/sfbank/creative") >= 0;
    }

    /**
     * return true if the sound card supports sound fonts
     * @param save_entry save entry
     * @return boolean	card supports fonts/it doesn't
     */

    global define boolean HasFonts(map save_entry) ``{
	if (Mode::config)
	{
	    // don't install sound fonts during autoinstallation config
	    return false;
	}

	if (contains(["snd-emu10k1", "snd-sbawe", "emu10k1"], save_entry["module"]:""))
	{
	    return true;
	}
	return false;
    }

    /**
     *  this small wizard will install sound fonts for soundblaster live/awe
     *  @param symlink is path to default.sf2 that is to be created
     *  @param dontask if true, skip the first messagebox
     *  @return void
     */

    global define void InstallFonts(string symlink, boolean dontask) ``{
	boolean answer = false;

	// step 1: want install?
	if (dontask)
	{
	    answer = true;
	}
	else
	{
	    answer = Popup::YesNoHeadline(Sound::STRINGS["soundFontTitle"]:"",
		Sound::STRINGS["soundFontQuestion"]:"");
	}

	if (!answer)
	{
	    return;
	}

	while (true)
	{
	    // step 2: insert CD
	    if (!Popup::ContinueCancelHeadline (
		    Sound::STRINGS["soundFontTitle"]:"",
		    Sound::STRINGS["soundFontAppeal"]:""))
	    {
		return;
	    }

	    // step3: do something
	    map res = (map) SCR::Execute (.target.bash_output,
		Directory::ybindir + "/copyfonts 2>/dev/null", $[] );

	    integer cnt = tointeger(lookup(res, "stdout", 0));

	    // restart ALSA after sound font copy
	    y2milestone("Restarting ALSA: %1",
		SCR::Execute(.target.bash, "/etc/init.d/alsasound restart"));

	    // step4:
	    if (cnt > 0)
	    {
		Popup::Message (sformat(Sound::STRINGS["soundFontFinal"]:"",
		    cnt, "/usr/share/sfbank/creative"));
		return;
	    }
	    else
	    {
		if (!Popup::YesNoHeadline (
			Sound::STRINGS["soundFontNotFound"]:"",
			Sound::STRINGS["soundFontRetry"]:""))
		{
		    return;
		}
	    }
	}
    }

    /**
     * does this machine need a nm256/opl3sa warning?
     * @param sound_cards sound cards
     * @return boolean see as above
     */
    global define boolean need_nm256_opl3sa2_warn(list sound_cards) ``{
	list mods = maplist (map card, sound_cards, ``(card["module"]:""));
	if (contains(mods, "snd-nm256") && contains(mods, "snd-opl3sa2"))
	{
	    return true;
	}
	return false;
    }

    /**
     * shows warning message when both nm265 and opl3sa2 cards are present
     * @param sound_cards list of sound cards
     * @return void
     */
    global define void nm256_opl3sa2_warn(list sound_cards) ``{
	list s1 = filter(map e, sound_cards, ``(e["module"]:"" == "snd-nm256"));
	list s2 = filter(map e, sound_cards, ``(e["module"]:""=="snd-opl3sa2"));

	if (size(s1) > 0 && size(s2) > 0)
	{
	    string name1 = s1[0, "model"]:"";
	    string name2 = s2[0, "model"]:"";
	    Popup::LongText("",
		`RichText ("<p>" +
		    sformat(Sound::STRINGS["opl3sa_nm256_warn"]:"", name1,name2)
		    +"</p>"),
		50, 12);
	}
    }


    /**
     * removes entries from save_info listed by indices in id_list
     * @param save_info list
     * @return list new save_info
     */
    global define list recalc_save_entries(list save_info) ``{
	integer pos = 0;
	save_info = maplist(map card, save_info, ``{
	    map opts	= card["options"]:$[];
	    card	= add_alias (card, pos);
	    card	= add_common_options (card, pos);
	    pos		= pos + 1;
	    return card;
	});
	return save_info;
    }

}//EOF
