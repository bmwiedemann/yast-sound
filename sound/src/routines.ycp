/**
 * File:
 *   routines.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Routines for sound card configuration
 *
 * Authors:
 *   Dan Veselý <dan@suse.cz>
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 */

{
    import "Directory";
    import "Mode";
    import "Popup";
    import "Sound";
    import "Summary";

    textdomain "sound";

    /**
     * common function to extract 'name' of hardware
     * @param hardware_entry map
     * @return string readable name of the card
     */
    global define string hardware_name (map hardware_entry) ``{

	y2debug("hardware_entry: %1", hardware_entry);

        string sub_vendor	= hardware_entry["sub_vendor"]:"";
	string sub_device	= hardware_entry["sub_device"]:"";
	string vendor		= hardware_entry["vendor"]:"";
	string device		= hardware_entry["device"]:"";

        if ((sub_vendor != "") && (sub_device != ""))
            return (sub_vendor + "\n" + sub_device);
        else if ((vendor == "") && (device == ""))
	{
	    string model	= hardware_entry["model"]:"";
	    string module_desc	= hardware_entry["module", "description"]:"";

	    return (size(model) > 0 && size(module_desc) > 0) ?
		model + " - " + module_desc : model + module_desc;
	}
	else return vendor + ((vendor != "") ? "\n" : "") + device;
    };


    /**
     * filters out already configured cards
     * @param save_info info from modules.conf
     * @param cards autodetected cards
     * @return list of entries of not configured cards
     */
    global define list filter_configured(list save_info, list cards) ``{

        return filter(map det_card, cards, ``{
            string uniq     = det_card["unique_key"]:"";
            boolean retval  = true;
            foreach(map saved_card, save_info, ``{
                if (saved_card["unique_key"]:"" == uniq)
                {
                    retval = false;
                }
            });
            return retval;
        });
    }

    /**
     * returns the result of /usr/bin/whoami. currently broken. no idea why...
     * @return string username
     */
    global define string whoami() ``{
	map ret	= SCR::Execute (.target.bash_output,"/usr/bin/whoami", $[]);
	string out = ret["stdout"]:"";
	list l = splitstring(out, "\n");
	if (size(l) > 0)
	{
	    return l[0]:"dontknow";
	}
	return "";
    }

    /**
     * for a given card detected by libhd this function creates a label
     * @param card map entry from .probe.audio
     * @return string card label
     */
    global define string get_card_label(map card) ``{

        list lab = splitstring(hardware_name(card),"\n");

	y2debug("Card label: %1", lab);

	if (size(lab) == 0 )
	{
	    return "";
	}
        if (size(lab) == 1 || lab[1]:"" == "")
        {
            return lab[0]:"";
        }
        return lab[1]:"";
    }

    /**
     * returns true if given string is valid sound alias
     * (snd-card-1 .. snd-card-16)
     * @param alias string
     * @return boolean is/is not
     */
    global define boolean is_snd_alias(string alias) ``{
	if (Sound::use_alsa)
	{
	    return regexpmatch(alias, "^snd-card-[0-9]*$");
	}
	else
	{
	    return regexpmatch(alias, "^sound-slot-[0-9]*$");
	}
    }

    /**
     * unique key for non-pci/pnp cards or virtual cards
     * @return string key for legacy isa cards
     */
    global define string isa_uniq() ``{
	return "uniq.virtual";
    }

    /**
     * reads variables listed in 'vars' from rc.config
     * @return map optname: value
     */
    global define map read_rc_vars () ``{

	return $["LOAD_ALSA_SEQ" : SCR::Read(.sysconfig.sound.LOAD_SEQUENCER)];
    }

    /**
     * saves uniq keys to .probe.status
     * @param configured list of strings of configured cards uniq keys
     * @param unconfigured list of string of unconfigured cards uniq keys
     * @return boolean true
     */
    global define boolean SaveUniqueKeys(list configured, list unconfigured) ``{
        maplist (string uk, configured, ``{
            SCR::Write(.probe.status.configured, uk, `yes);
        });

        maplist(string uk, unconfigured, ``{
            SCR::Write(.probe.status.configured, uk, `no);
        });

        return true;
    }



    /**
     * Used for searching. returns index of the card in the database
     * identified by name (more exactly: returns index of first name matching
     * the given substring)
     * @param name card name (or its substring)
     * @return integer position of the card
     */
    global define integer search_card_id (string name) ``{
        list all_cards = get_card_names ("all");
        integer pos = 0;
        integer len = size (name);
	name = tolower(name);
	integer bound = size (all_cards);
        while (pos < bound)
        {
            if (substring (tolower(all_cards[pos]:""), 0, len) == name)
            {
                return pos;
            }
            pos = pos + 1;
        };
        return -1;
    }

    /**
     * Itemize list for selection box
     * @param l list with values
     * @param default value to select as default
     * @return list items to be shown in list widget
     */
    global define list itemize_list (list l, integer default) ``{
        integer i = 0;
        list itemized_list = [];
        integer s = size (l);
        while (i < s)
        {
            itemized_list = add (itemized_list,
		`item (`id(i), select (l, i, ""), (i == default)));
            i = i + 1;
        }
        return itemized_list;
    };


    /**
     *	show a warning popup for nm256 snd cards if needed
     *  @param modname string module name
     *  @return boolean continue/abort
     */

    global define boolean nm256hack (string modname) ``{
        if (modname == "snd-nm256")
        {
            // special warning message for in a special case
            string warn_text = STRINGS["nm256hackWarning"]:"";
	    return Popup::YesNo(warn_text);
        }
        return true;
    }

    /**
     * Looks up in the database for the module
     * @param card map read from .probe.sound
     * @return map relevant card info found in db
     */
    global define map get_module (map card) ``{

	Sound::LoadDatabase (true);

	string bus        = card["bus"]:"";
	integer offset    = (tolower (bus) == "isa") ? 0x20000 : 0x10000;
	integer vendor_id = card["vendor_id"]:0 - offset;
	integer device_id = card["device_id"]:0 - offset;

	map m1 = Sound::db_indices[vendor_id]:$[];
	if (m1 == $[])
	{
	    y2debug("vendor_id not found...");
	    return $[];
	}

	integer m2 = m1[device_id]:-1;
	if (m2 == -1)
	{
	    y2debug("device_id not found");
	    return $[];
	}

	string modname = Sound::db_module_index [m2]:"";

	map ret = Sound::db_modules [modname]:$[];

	if (ret != $[] && !haskey(ret, "name"))
	{
	    // we must supply the 'name' key with the module name
	    ret = add(ret, "name", modname);
	}

	return ret;
    }

    /**
     * umnute channel 'devide' of the 'card_id'-th sound card. alsa only
     * @param devices list of channels to be unmuted
     * @param card_id of the card
     * @return void
     */
    global define void unmute(list devices, integer card_id) ``{
	if (Mode::config)
	{
	    // TODO: store this info some elsewhere...
	    return;
	}

	list avail = SCR::Dir(topath(sformat(".audio.alsa.cards.%1.channels", card_id)));
	if (avail == nil || size(avail)==0)
	{
	    avail = [];
	}
	foreach(`dev, devices,
	``{
	    if (contains(avail, dev))
	    {
		SCR::Write(topath(sformat(".audio.alsa.cards.%1.channels.%2.mute", card_id, dev)), false);
	    }
	});
    }

    /**
     * stores the volume to file. stored volume will be
     * restored after reboot
     * @param card_id card id
     * @return boolean success/failure
     */
    global define boolean storeVolume(integer card_id) ``{
	if (card_id == -1)
	{
	    SCR::Execute(.audio.alsa.store, 0, 0);
	}
	string p = sformat(".audio.alsa.cards.%1.store", card_id);

	return SCR::Execute(topath(p), 0, 0);
    }


    /**
     *  Checks whether the module has been successfully loaded
     *
     * @param save_entry card config map
     * @param card_id card id
     * @return string empty on success/ error message on failure
     */

    global define string check_module(map save_entry, integer card_id) ``{
	map pm		= SCR::Read(.proc.modules);
	string mod_name	= save_entry["module"]:"off";
        if (!haskey (pm, mod_name) || size(get_running_cards()) <= card_id)
        {

                // To translators: label to error popup
            return sformat (_("The kernel module %1 for sound support
could not be loaded. This can be caused by incorrect
module parameters, including invalid IO or IRQ parameters."), mod_name);
        }
        return "";

    }


    /**
     *  creates itemized table entries,
     *  @param lm list of maps to take keys from
     *  @param lk list of keys to look for in 1st param
     *
     *  @return list of items
     */

    global define list create_table (list lm, list lk)
    ``{
	list res = [];
	integer pos = 0;
	foreach (map m, lm, ``{
	    res = add(res, `item(`id(pos),
		lookup(m, lk[0]:"", ""),
		lookup(m, lk[1]:"", ""),
		lookup(m, lk[2]:"", "")
	    ));
	    pos = pos + 1;
	});
	return res;
    }

    /**
     * checks whether param #1 is if type of param #2
     * @param value value
     * @param type expected type. one of {int, string}
     * @param poss if poss is nonempty, checks if value is one of them
     * returns error message, empty string if ok
     * @return string error message
     */
    global define string check_value (string value, string type, list poss) ``{
        if (type == "int")
        {
            if (tolower(substring (value, 0, 2)) == "0x")	// hex number
            {
                string rest = tolower(substring (value, 2));
                if (filterchars(rest, "0123456789abcdef") != rest)
                {
                      // To translators: popup message, wrong value
                      return sformat (_("The value: %1 must be a number"), value);
                }
            }
            else                // decimal number
            {
                string rest = value;
                if (substring (value, 0, 1) == "-")      // negative number
                {
                    rest = substring (value, 1);
                }
                if (filterchars(rest, "0123456789") != rest)
                {
                    // To translators: popup message, wrong value
                    return sformat (_("The value: %1 must be a number"), value);
                }
            }
        }
        else if (type == "string")
        {
            if (filterchars (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789") != value)
            {

                integer wrong_pos = findfirstnotof (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789");
                string wrong_char = substring (value, wrong_pos, 1);
                if (wrong_char == " ")
                {
                    // To translators: "space" means blank character
                    wrong_char = wrong_char + " " + _("(space)");
                }
                // To translators: popup message, wrong value
                return  sformat (_("String cannot contain: %1"), wrong_char);
            }
        }

        // now check for poss list
        if (size (poss) > 0)
        {
            list poss_list = [];

            if (type == "int")
            {
                poss_list = maplist (`v, poss, ``(tointeger (value) == v));
            }
            else
            {
                poss_list = maplist (`v, poss, ``(value == v));
            }

            if (!contains (poss_list, true))
            {
                // popup message: wrong value; %1 is list of right values
                return sformat (_("The value must be one of
%1"), mergestring (poss,","));
            }
        }

        return "";  // ok :-)
    }

    /**
     * inserts values to already set options
     * @param params list with available options for module
     * @param values values that have been already set
     * @return map with refreshed options
     *
     */
    global define map restore_mod_params(map params, map values) ``{
	return mapmap(string parname, map parmap, params, ``{
	    parmap = add (parmap, "value", values[parname]:"");
	    return [parname, parmap];
	});
    }

    /**
     *  checks whether sound fonts have already been installed
     *	@return boolean already installed/not installed
     *
     */

    global define boolean FontsInstalled() ``{
	return SCR::Read(.target.size, "/usr/share/sfbank/creative") >= 0;
    }

    /**
     * return true if the sound card supports sound fonts
     * @param save_entry save entry
     * @return boolean	card supports fonts/it doesn't
     */

    global define boolean HasFonts(map save_entry) ``{
	if (Mode::config)
	{
	    // don't install sound fonts during autoinstallation config
	    return false;
	}

	if (contains(["snd-emu10k1", "snd-sbawe", "emu10k1"], save_entry["module"]:""))
	{
	    return true;
	}
	return false;
    }

    /**
     *  this small wizard will install sound fonts for soundblaster live/awe
     *  @param symlink is path to default.sf2 that is to be created
     *  @param dontask if true, skip the first messagebox
     *  @return void
     */

    global define void InstallFonts(string symlink, boolean dontask) ``{
	boolean answer = false;

	// step 1: want install?
	if (dontask)
	{
	    answer = true;
	}
	else
	{
	    answer = Popup::YesNoHeadline(
		STRINGS["soundFontTitle"]:"", STRINGS["soundFontQuestion"]:"");
	}

	if (!answer)
	{
	    return;
	}

	while (true)
	{
	    // step 2: insert CD
	    if (!Popup::ContinueCancelHeadline (
		STRINGS["soundFontTitle"]:"", STRINGS["soundFontAppeal"]:""))
	    {
		return;
	    }

	    // step3: do something
	    map res = SCR::Execute (.target.bash_output,
		Directory::ybindir + "/copyfonts 2>/dev/null", $[] );

	    integer cnt = tointeger(lookup(res, "stdout", 0));

	    // restart ALSA after sound font copy
	    y2milestone("Restarting ALSA: %1",
		SCR::Execute(.target.bash, "/etc/init.d/alsasound restart"));

	    // step4:
	    if (cnt > 0)
	    {
		Popup::Message (sformat(STRINGS["soundFontFinal"]:"", cnt,
		    "/usr/share/sfbank/creative"));
		return;
	    }
	    else
	    {
		if (!Popup::YesNoHeadline (STRINGS["soundFontNotFound"]:"",
			STRINGS["soundFontRetry"]:""))
		{
		    return;
		}
	    }
	}
    }

    /**
     * does this machine need a nm256/opl3sa warning?
     * @param sound_cards sound cards
     * @return boolean see as above
     */
    global define boolean need_nm256_opl3sa2_warn(list sound_cards) ``{
	list mods = maplist (map card, sound_cards, card["module"]:"");
	if (contains(mods, "snd-nm256") && contains(mods, "snd-opl3sa2"))
	{
	    return true;
	}
	return false;
    }

    /**
     * shows warning message when both nm265 and opl3sa2 cards are present
     * @param sound_cards list of sound cards
     * @return void
     */
    global define void nm256_opl3sa2_warn(list sound_cards) ``{
	list s1 = filter(map e, sound_cards, ``(e["module"]:"" == "snd-nm256"));
	list s2 = filter(map e, sound_cards, ``(e["module"]:""=="snd-opl3sa2"));

	if (size(s1) > 0 && size(s2) > 0)
	{
	    string name1 = lookup(select(s1, 0, $[]), "model", "");
	    string name2 = lookup(select(s2, 0, $[]), "model", "");
	    Popup::LongText("",	`RichText("<p>" +
		sformat(STRINGS["opl3sa_nm256_warn"]:"", name1, name2)+"</p>"),
		50, 12);
	}
    }


    /**
     * removes entries from save_info listed by indices in id_list
     * @param save_info list
     * @return list new save_info
     */
    global define list recalc_save_entries(list save_info) ``{
	integer pos = 0;
	save_info = maplist(map card, save_info, ``{
	    map opts	= card["options"]:$[];
	    card	= add_alias (card, pos);
	    card	= add_common_options (card, pos);
	    pos		= pos + 1;
	    return card;
	});
	return save_info;
    }

    /**
     * stops all programs using sound devices
     * @return boolean true if nothing's using sound, false otherwise
     */
    global define boolean stop_programs() ``{
	if (Mode::config)
	{
	    return true;
	}
	integer fuser = SCR::Execute (.target.bash, "/bin/fuser /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]);

	if (fuser == 0)
        {
	    string msg		= STRINGS["WhichDialogMsg"]:"";
            boolean terminate	= Sound::use_ui ? Popup::YesNo (msg) : true;
            if (terminate)
            {
		SCR::Execute (.target.bash, "/bin/fuser -k /dev/dsp* /dev/audio* /dev/mixer* /dev/midi* /dev/mixer*", $[]);
            }
            else
            {
		return false;
            }
        }
	return true;
    }

    /**
     * creates hardware-summary-like list of configured cards
     * @return string richtext
     * @param save_info save info
     */
    global define string ConfCardsRT(list save_info) ``{
	list retlist = [];
	list conflist = [];
	foreach(map card, save_info, ``{
	    conflist = add (conflist, card["model"]:"");
	});
	integer i = 0;
	foreach(string cardname, conflist, ``{
	    retlist = add (retlist, Summary::Device (cardname,
		// to translators: '(sound card is) Configured as snd-card-1'
		sformat(_("Configured as snd-card-%1."), i)));
	    i = i + 1;
	});
	return Summary::DevicesList(retlist);
    }

}//EOF
