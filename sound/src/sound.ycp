/**
 *
 *
 * File:
 *   sound.ycp
 *
 * Module:
 *   Sound
 *
 * Authors:
 *   Dan Vesely <dan@suse.cz> Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * Installation of the sound card. If the sound card was not auto-detected ask user.
 *
 *
 */

{

    textdomain "sound";

    // REMOVEME

    import "Arch";
    import "Runlevel";

    include "wizard/sequencer.ycp";
    import  "Wizard_hw";
    include "ui/common_popups.ycp";
    import  "Wizard";

    include "sound/card_wizard.ycp";
    include "sound/read_routines.ycp";
    include "sound/routines.ycp";
    include "sound/ui.ycp";
    include "sound/write_routines.ycp";
    include "sound/volume.ycp";
    include "sound/options.ycp";
    include "sound/complex.ycp";
    include "sound/select.ycp";
    include "sound/manual.ycp";
    include "sound/joystick.ycp";

    boolean autoinstall = false;

    boolean use_alsa = !Arch::sparc;
    if (size(Args()) > 0 && Args(0)==.oss)
    {
	use_alsa=false;
    }

    if (use_alsa)
    {
	include "sound/alsa_routines.ycp";
    }
    else
    {
	include "sound/oss_routines.ycp";
    }
    include "sound/texts.ycp";


    // check for database existence

    if (use_alsa && SCR::Read(.target.size, "/usr/lib/YaST2/sndcards.ycp")==-1)
    {
        UI::MessagePopup(_("Sound card database not found. Please check your installation."));
        UI::CloseDialog();
        return;
    }

    import "Sound";
    // text constants for sound module
    map STRINGS=STRINGS_();
    float oldf=0.0;

    // just cover functions for wizard sequencer
    // these global variables are used and modified:
    //	  save_info
    //	  card_id
    //    sound_cards


    map save_entry = $[];
    boolean was_complex = false;

    /**
     * card selection dialog
     *
     */

    global define symbol _snd_select() ``{
	Sound::UpdateUnconfiguredCards();
//#	sound_cards = getConfigurableCards(save_info);
	if ((size(Sound::unconfigured_cards) == 0) && (!was_complex))
	{
	    return `detail;
	}
	list nh	    = maplist(`e, Sound::unconfigured_cards, ``(lookup(e, "model", "")));

        list ch	    = maplist(`e, Sound::modules_conf, ``(lookup(e, "model", "")));
	map res	    = sound_select(nh, Sound::modules_conf);
	symbol ui   = lookup(res, "ui", `abort);

	card_id = lookup(res, "id", 0);
	if (card_id == -1)
	{
	    return `manual;
	}
	return lookup(res, "ui", `abort);
    }

    /**
     * quick configuration step #1 dialog
     *
     */

    global define symbol _snd_quick() ``{
	save_entry = select(Sound::unconfigured_cards, 0, $[]);
	card_id = 0;
	string modelname    = lookup(save_entry, "model", "");
	map res		    = quickConfig(modelname, "snd-card-0", card_id, 15);
	symbol ui	    = lookup(res, "ui", nil);
	return ui;
    }

    /**
     * quick config step #2 dialog
     * @param type boolean quick/normal config
     */

    global define symbol _snd_quick2(boolean type) ``{
	save_entry  = add_common_options(save_entry, 0);
	save_entry  = add_alias(save_entry, 0);
	map res	    = sound_volume(save_entry, 0, true, type, []);
	symbol ui   = lookup(res, "ui", nil);
	if (ui == `next)
	{
	    Sound::modules_conf = [save_entry];
	}
	return ui;
    }

    /**
     * dialog for manual card selection
     *
     */

    global define symbol _snd_manual() ``{
	map res = sound_manual();

	// if user selects the soundcards that has been already autodetected,
	// use the detected card instead of manual selection (because it causes
	// some problems with uniq. keys)

	symbol ui = lookup(res, "ui", `abort);

	boolean override = false;
	string uniq_k = "";
	string label = "";


	if (ui == `next)
	{
	    uniq_k = isa_uniq();
	    label = lookup(res, "model", "Sound card");

	    // set default values for options
	    map optlist = lookup(Sound::db_modules, lookup(res, "module", ""), $[]);
	    optlist = lookup(optlist, "params", $[]);
	    map options = $[];
	    maplist(`k, `v, optlist,
	    ``{
		if (haskey(v, "default"))
		{
		    options = add(options, k, lookup(v, "default", ""));
		}
	    });

	    list cds = filter(`e, Sound::unconfigured_cards, ``(lookup(e, "module", "") == lookup(res, "module", nil)));
	    y2debug("%1", cds);
	    if (size(cds) > 0)
	    {
		label  = lookup(select(cds, 0, $[]), "model", "Sound card");
		uniq_k = lookup(select(cds, 0, $[]), "unique_key", isa_uniq());
	    }

	    save_entry = $[
		"module"     : lookup(res, "module", ""),
		"model"	     : label,
		"unique_key" : uniq_k,
		"options"    : options
		];
	    card_id = -1;
	}
	if (ui == `back)
	{
	    save_entry = $[];
	}
	return ui;
    }

    /**
     * add card from complex dialog
     *
     */

    global define symbol _snd_add() ``{
	list nh     = maplist(`e, Sound::unconfigured_cards, ``(lookup(e, "model", "")));
	map res	    = WhichDialog(nh);
	symbol ui   = lookup(res, "ui", `back);
        card_id	    = lookup(res, "card_id", -1);
        if (card_id == -1 && ui == `next)
        {
            return `manual;
        }

	return ui;
    }

    /**
     * sound card deletion
     *
     */

    global define symbol _snd_delete() ``{
	if (UI::YesNoPopup(_("Do you really want to delete this entry?")))
	{
	    boolean terminate = stop_programs();
	    if (terminate == false)
            {
                return `next;
            }
            string modname = lookup(select(Sound::modules_conf, card_id, $[]), "module", "");

            // we have to rember volume/mute settings because after a card removal
            // everything is muted and set to 0.
            list vol_settings = get_vol_settings();

            Sound::modules_conf	    = remove(Sound::modules_conf, card_id);
	    Sound::modules_conf	    = recalc_save_entries(Sound::modules_conf);

	    vol_settings    = remove(vol_settings, card_id); //multi_remove(vol_settings, rem);

	    if (!Sound::autoinstallation)
	    {
		sound_stop();
		sound_start_tmp(true);
		set_vol_settings(vol_settings);
		// now we have to update the unconfigured cards list
		Sound::UpdateUnconfiguredCards();
	    }


	}

	return `next;
    }

    /**
     * configure selected card
     *
     */

    global define symbol _snd_config() ``{
	if (card_id >= 0)
	{
	    save_entry = select(Sound::unconfigured_cards, card_id, $[]);
	}
	map res = OneCardWizard(save_entry, size(Sound::modules_conf), 15, false, Sound::modules_conf);

        symbol ui = lookup(res, "ui", nil);
        if (ui == `next)
        {
	    // copy card_entry from unconfigured to configured list
            Sound::modules_conf = add(Sound::modules_conf, lookup(res, "return", $[]));
	    if (card_id >= 0)
	    {
		// if this this card was autodetedted
		// remove card we've just configured from unconfigured card list.
		Sound::unconfigured_cards = remove(Sound::unconfigured_cards, card_id);
	    }
	    if (size(Sound::unconfigured_cards) == 0)
	    {
		// no other detected && unconfigured cards remained
		return `detail;
	    }
        }
	return ui;
    }

    /**
     * complex dialog
     *
     */

    global define symbol _snd_complex() ``{
	was_complex = true;
	map res	    = sound_complex();
        symbol ui   = lookup(res, "ui", nil);
        if (ui == `next)
        {
            state	= `save;
        }
	return ui;
    }

    /*
     *
     * ========== MAIN ==========
     *
     */
//if (!use_alsa)
//{
//    UI::MessagePopup("BETA INFO for OSS:\nThis module requires to have 'mpg123' and 'aumix'
//installed on your system. Also copy some (short) mp3 file to
///usr/share/sounds/test.mp3 . This file will be played as
//test sound.");
//}

    OpenMainDialog();
    InitializingDialog ();

    Wizard::DisableAbortButton();

    if (whoami() != "root")
    {
	UI::MessagePopup(_("You need to be logged in as root 
to configure sound cards.
"));
	UI::CloseDialog();
	return;
    }


    boolean test_mode     = false;
    boolean config_mode   = false;
    boolean autoinst_mode = false;
//    boolean use_alsa      = true;	// default
    boolean from_menu     = false;

    integer arg_n = size (Args ()) - 1;
    while (arg_n >= 0)
    {
	if (Args(arg_n) == .test)
	{
	    test_mode     = true;
	}
	if (Args(arg_n) == .autoinst_mode)
	{
	    autoinst_mode = true;
	}
	if (Args(arg_n) == .conf_mode)
	{
	    config_mode   = true;
	}
	if (Args(arg_n) == ".from_menu")
	{
	    from_menu     = true;
	}
	arg_n = arg_n - 1;
    }

    if (!Sound::autoinstallation && !Sound::installation)
    {
	Sound::Read(``{});
    }

    if (Sound::installation)
    {
	Sound::StoreSettings();
	Sound::UpdateUnconfiguredCards();
	sound_stop();
	sound_start_tmp(true);
    }

    Sound::use_ui = true;

    /*
     * this variable will not be touched.
     * it's purpose is for checking whether
     * changes were done to config.
     */
    list save_info_backup = Sound::modules_conf;


//#    map rc_vars       = read_rc_vars (["START_ALSA", "START_ALSA_SEQ"]);
    map rc_vars_backup = Sound::rc_vars;
    integer card_id   = 0;
    integer n_cards   = 0;
    map result        = $[];
    boolean cont      = true;

    boolean exit = false;

    if (use_alsa && SCR::Read(.target.size, "/usr/lib/YaST2/sndcards.ycp")==-1)
    {
	UI::MessagePopup(_("Sound card database not found. Please check your installation."));
	UI::CloseDialog();
	return;
    }
//#    sound_cards = getConfigurableCards(save_info);
    integer all_cards_num = size(Sound::unconfigured_cards);

    if (exit)
    {	// no sound cards database present, shutting down
	UI::CloseDialog ();
	return;
    }

    nm256_opl3sa2_warn(flatten(add([Sound::modules_conf], Sound::unconfigured_cards)));

    symbol state = `card_select;


// test data
//    save_info=[];
//    sound_cards=[$["model":"Pokusna karta", "module": "snd-card-emu10k1", "unique_key":"kx", "options": []]];

    string initial = "intro";

    // when running this module as non-root, go to complex-dialog
    if (size(Sound::unconfigured_cards) == 1 && size(Sound::modules_conf) == 0)
    {
	card_id = 0;
	initial = "quick";
    }
    else if (size(Sound::unconfigured_cards) == 0)
    {
	initial = "complex";
    }
    

    map m_aliases = $[
	    "intro"	: ``(_snd_select()),

	    "config1"	: ``(_snd_config()),
	    "config2"	: ``(_snd_config()),

	    "manual1"	: ``(_snd_manual()),
	    "manual2"	: ``(_snd_manual()),

	    "complex"	: ``(_snd_complex()),
	    "delete"	: ``(_snd_delete()),
	    "select"	: ``(_snd_add()),

	    // quick configuration
	    "quick"	: ``(_snd_quick()),
	    "quick2"	: ``(_snd_quick2(true)),
	    "quick3"	: ``(_snd_quick2(false)),

	    "joystick"	: ``(joystick())
	];

    map m_sequence = $[
	    "ws_start"	: initial,
	    "quick"	:
		$[
		    `quick	    :	"quick2",
		    `normal	    :	"quick3",
		    `abort	    :	`abort,
		    `intro	    :	"intro"
		],
	    "quick2"	:
		$[
		    `next	    :	`finish,
		    `abort	    :	`abort
		],
	    "quick3"	:
		$[
		    `next	    :	`finish,
		    `abort	    :	`abort
		],


	    "intro"	: 
		$[
		    `next	    :	`finish,
		    `configure	    :   "config1",
		    `manual	    :	"manual1",
		    `detail	    :	"complex",
		    `abort	    :	`abort
		],


	    "config1"	: 
		$[
		    `next	    :	"intro",
		    `detail	    :	"intro",
		    `abort	    :   `abort
		],
	    "manual1"	: 
		$[
		    `next	    :	"config1",
		    `abort	    :	`abort		
		],

	    "config2"	: 
		$[
		    `next	    :	"complex",
		    `detail	    :	"complex",
		    `abort	    :   `abort
		],
	    "manual2"	: 
		$[
		    `next	    :	"config2",
		    `abort	    :	`abort		
		],


	    "complex"	:
		$[
		    `next	    :	`finish,
		    `abort	    :	`abort,
		    `add_manual     :	"manual2",
		    `add_select	    :	"select",
		    `delete	    :	"delete"
		],
	    "select"	:
		$[
		    `abort	    :	`abort,
		    `next	    :	"config2",
		    `manual	    :	"manual2"
		],
	    "delete"	:
		$[
		    `next	    :	"complex"
		]
	];

    symbol ui = WizardSequencer(m_aliases, m_sequence);

    if (ui == `back || ui == `abort)
    {
	if (Sound::installation)
	{
	    Sound::RestoreSettings();
	}
	UI::CloseDialog();
	return;
    }

    n_cards = size (Sound::modules_conf);

    map save_map = $[];

    if (Sound::installation)
    {
	if (ui != `finish)
	{
	    Sound::RestoreSettings();
	}
    }

    if (ui == `finish && !Sound::autoinstallation)
    {
	if (!Sound::installation && (Sound::modules_conf != save_info_backup || Sound::rc_vars != rc_vars_backup))
	{
	    Sound::Write(``{}, ``{});
	}
    }

    UI::CloseDialog ();
}
