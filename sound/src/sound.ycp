/**
 *
 *
 * File:
 *   sound.ycp
 *
 * Module:
 *   Sound 	 
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * Installation of the sound card. If the sound card was not auto-detected ask user.
 *		     
 *
 */

{

    textdomain "sound";

    include "misc_defines.ycp";
    include "sound/routines.ycp";
    include "sound/ui.ycp";
    include "sound/texts.ycp";
    include "sound/read_routines.ycp";
    include "sound/alsa_routines.ycp";

    include "browser.ycp";

    // text constants for sound module
    map STRINGS=STRINGS_();
  
    // Menuentry for the YaST2 menu
    if (Args() == [ "get_menuentry" ])
    {
	return [ "sound", $[
	    `menuentry    : UI(_("Hardware/Sound")),
	    `arguments    : [ ],
	    `widget       : `RichText(
	    //
	    UI(_("Launch this module to configure your sound card."))
	    +
	    UI(_("<p>You need to be logged in as <i>root</i> in order to do this.</p>"))),
	    `codefragment : nil ]
	];
    }

    
    /**
     * Wizard steps: 1. displayname 
     * <br>
     * 2. modprobe and volume settings
     * @param   card_info as returned by libhd
     * @param	car_id index of configured car
     * @param	ui 
     * @param	flags defines which radioboxes has to be enabled (0x1 - first, 0x2 second, 0x4 third...)
     * @param	finish true if no complex dialog is to be called (then the popup "Config will be saved.." will appear)
     * @return  list with save info, as required by sound_write for one cards
     */
    global define OneCardWizard (map save_entry, integer card_id, any ui, integer flags, boolean finish, list save_info) ``{
	    // 3rd param for "sound_module" will be defined later
	    // TODO: add nm256hack
	integer state=1;

	if(ui == `back)
	{
	    state=3;
	}	

	map opts=lookup(save_entry, "options", $[]);
	save_entry=add_common_options(save_entry, card_id);
	save_entry=add_alias(save_entry, card_id);
	
	integer state=1;
	map res=$[];

	string modelname=lookup(save_entry, "model", "");
   
	boolean show_opts=false;
 
	while(state>0)
	{
	    if(state==1)
	    // display_name dialog
	    {
		res=DisplayName(modelname, lookup(save_entry, "alias"), card_id, flags);
		symbol ui=lookup(res, "ui", nil);
		
		show_opts=(ui==`options);

		map nextstate=$[`back: -1, `next: 3, `options: 2, `quick: 4, `skip: -2, `abort: -3];
		state=lookup(nextstate, ui, 0);
	    }
	    else if(state==2)
	    // options dialog
	    {
		res=CallModule ("sound_options", [save_entry]);
		symbol ui=lookup(res, "ui", nil);
		if(ui == `next)
		{
		    save_entry=lookup(res, "return", $[]);
		    save_entry=add_common_options(save_entry, card_id);
		}
		
		map nextstate=$[`next: 3, `back: 1, `abort: -3];
		state=lookup(nextstate, ui, 0);
	    }
	    else if(state==3)
	    // volume dialog
	    {
		res=CallModule ("sound_volume", [save_entry, card_id, finish, false, save_info] );
		map nextstate=$[`next: -13, `abort: -3, `back: 1];
		symbol ui=lookup(res, "ui", nil);
		if(ui==`back && show_opts)
		{
		    state=2;
		}
		else
		{
		    state=lookup(nextstate, ui, 0);
		}
	    }
	    else if(state==4)
	    // quick config
	    {
		res=CallModule ("sound_volume", [save_entry, card_id, finish, true, save_info]);
		map nextstate=$[`next: -13, `abort: -3, `back: 1];
		symbol ui=lookup(res, "ui", nil);
		if(ui==`back && show_opts)
                {
                    state=2;
                }
                else
                {
                    state=lookup(nextstate, ui, 0);
                }
	    }
	}

	map nextstate=$[-13: `next, -3: `abort, -2: `skip, -1: `back];
	return $["ui": lookup(nextstate, state, -2), "return": save_entry];
    }

    // ========== MAIN ==========
    OpenMainDialog();
    InitializingDialog ();


    UI(`DisableWizardAbortButton());

    boolean test_mode     = false;
    boolean config_mode   = false;
    boolean autoinst_mode = false;
    boolean use_alsa      = true;	// default
    boolean from_menu     = false;

    integer arg_n = size (Args ()) - 1;
    while (arg_n >= 0) 
    {
	if (Args(arg_n) == .test)
	{ 
	    test_mode     = true;
	}
	if (Args(arg_n) == .autoinst_mode) 
	{
	    autoinst_mode = true;
	}
	if (Args(arg_n) == .conf_mode)    
	{
	    config_mode   = true;
	}
	if (Args(arg_n) == .from_menu)
	{
	    from_menu     = true;
	}
	arg_n = arg_n - 1;
    }
    list sound_cards  = get_audio ();

    list save_info    = read_save_info ();
 
    CreateTmpModulesConf();
 
    map rc_vars       = $[];
    integer card_id   = 0;

    integer n_cards   = 0;
    map result        = $[];
    any ui            = nil;
    boolean cont      = true;
    boolean call_complex_dialog = false;	
    list configured_unique = []; // list of unique keys, that was configured

    boolean exit = false;
    list db = nil;

    sound_cards=filter_configured(save_info, sound_cards);
    
    if(size(sound_cards)>0)
    {
	db=GetCardDatabase();
	// get all the apropriate information from the database
	sound_cards =  maplist(`e, sound_cards, ``(add (e, "module", get_module (e))));


    // filter out modules with unspecified module name (sound card not supported by alsa / no module found)
	sound_cards = filter(`e, sound_cards, ``(lookup(e, "module", $[])!=$[]));
    
    // create save_info entries
	sound_cards = convert_to_save_info(sound_cards);
    }
    integer all_cards_num=size(sound_cards);

    if(exit)
    {	// no sound cards database present, shutting down
	UI(`CloseDialog ());
	return;
    }


    boolean skipped = false;
    if(all_cards_num == new_cards_num && all_cards_num == 1)
    {
	call_complex_dialog=false;
    }
    else
    {
	call_complex_dialog=true;
    }
    
    nm256_opl3sa2_warn(sound_cards);

    symbol state=`card_select;
    map res=$[];

    boolean can_go_back=false;

    repeat
    {
	if(state==`card_select)
	// let's select the hardware we want to configure
	{
	    if(size(sound_cards)==0)
	    {
		state=`detail;
		can_go_back=false;
		continue;
	    }
	    list nh=maplist(`e, sound_cards, ``(lookup(e, "model", "")));
	    list ch=maplist(`e, save_info, ``(lookup(e, "model", "")));
	    res=CallModule("sound_select", [nh, ch]);
	    symbol ui=lookup(res, "ui", nil);
	    if(ui==`next)
	    {
		if(lookup(res, "type", nil)==`new)
		{
		    card_id=lookup(res, "id", 0);
		    state=`card_wizard;
		}
		else if(lookup(res, "type", nil)==`configured)
		{
		    card_id=lookup(res, "id", 0);
	            state=`edit_options;
		}
		else if(lookup(res, "type", nil)==`manual)
		{
		    state=`add_manual;
		}   
	    } 
	    else if(ui==`detail)
	    {
		state=`detail;
		can_go_back=true;
	    }
	    else if(ui==`back || ui==`abort)
	    {
		state=`abort;
	    }
	}
	else if(state==`card_wizard)
	// run the card wizard for new card
	{
	    map save_entry=select(sound_cards, card_id);
	    res=OneCardWizard(save_entry, size(save_info), false, 15, false, save_info);
	    symbol ui=lookup(res, "ui", nil);
	    if(ui==`back)
	    {
		state=`card_select;
	    }
	    else if(ui==`next)
	    {
		save_info=add(save_info, lookup(res, "return", $[]));
		sound_cards=remove(sound_cards, card_id);
		// TODO: another dialog should be called
		state=`card_select;
	    }
	    else if(ui==`abort)
	    {
		state=`abort;
	    }
	}
	else if(state==`edit_options)
	// edit options
	{
	    map entry=select(save_info, card_id);
	    map res=CallModule("sound_options", [entry]);
	    symbol ui=lookup(res, "ui", nil);
	    if(ui==`next)
	    {
	        entry=lookup(res, "return", $[]);
	        entry=add_common_options(entry, card_id);
	        integer pos=0;
	        save_info=maplist(`e, save_info,
	        ``{
	            if(pos!=card_id)
	            {
	                pos=pos+1;
	                return e;
	            }
	            else
	            {
	                pos=pos+1;
	                return entry;
	            }
	        });
		state=`card_select;
	    }
	    else if(ui==`abort)
	    {
		state=`abort;
	    }
	    else
	    {
		state=`card_select;
	    }
	}
	else if(state==`detail)
	// edit card options
	{
	    map res=CallModule("sound_complex", [save_info, []]);
	    symbol ui=lookup(res, "ui", nil);
	    if(ui==`next)
	    {
		save_info=lookup(res, "save_info", []);
		state=`save;
	    }
	    else if(ui==`abort)
	    {
		state=`abort;
	    }
	    else if(ui==`back)
	    {
		if(can_go_back)
		{
		    state=`card_select;
		}
		else
		{
		    state=`abort;
		}
	    }
	}
	else if(state==`add_manual)
	{
	    map res=add_card_manually(save_info);
	    symbol ui=lookup(res, "ui", nil);
	    if(ui==`next)
	    {
		save_info=add(save_info, lookup(res, "return", $[]));
		state=`card_select;
	    }
	    else if(ui==`abort)
	    {
		state=`abort;
	    }
	    else
	    {
		state=`card_select;
	    }
	}
    } until(state==`abort || state==`exit || state==`save);
    if(state==`back || state==`abort)
    {
	UI(`CloseDialog());
	return;
    }
    else if(state==`save)
    {
	ui=`save;
    }   
			    // filter out empty enries
    save_info = filter (`e, save_info, ``(size (e) > 0));
    n_cards = size (save_info);

    map save_map = $[];

    if (ui == `save) 
    {
	CallModule ("sound_write", [save_info]);

    // always save unique keys 
	save_unique_keys (maplist(`e, save_info, ``(lookup(e, "unique_key", ""))));

	if (lookup (rc_vars, "START_ALSA", "yes") == "no")
	{
	    SCR(`Execute (.target.bash, "/etc/init.d/alsasound stop", $[]));
	}
	else
	{
	    SCR(`Execute (.target.bash, "/sbin/depmod", $[]));
	    SCR(`Execute (.target.bash, "/etc/init.d/alsasound restart", $[]));
	}
    }

    UI(`CloseDialog ());
}
