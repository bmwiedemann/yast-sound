/*
 * Module for setting options passed to the module
 * Dan Vesely <dan@suse.cz>, 2000
 *
 * $Id$
 *
 * parameters: 1st: card
 *
 */

{

    textdomain "sound";

    include "misc_defines.ycp";
    include "sound/sound_routines.ycp";


    /* creates itemized table entries,
     * params: 1st: list of maps to take keys from
     * 2nd: list of keys to look for in 1st param
     */
    define create_table (list lm, list lk) ``{
	integer i = 0;
	list itemized_list = [];
	integer s = size (lm);
	term val = `item ();

	while (i < s) {
	    val = `item (`id(i));
	    foreach (`k, lk, ``{
		val = add (val, lookup (select (lm, i), k, ""));
	    });
	    
	    itemized_list = add (itemized_list, val);
	    i = i + 1;
	}
	
	return itemized_list;
    };

    /* Chooses one message according to
     * the language, used for translating
     * sndcard options 
     */
    define Trans (map|void msgs, string lang) ``{
	string|void message = "";
	if (msgs != nil) {
	    message = lookup(msgs, lang);
	    if (message == nil)
		message = lookup(msgs, substring (lang, 0, 2));
	    if (message == nil)
		message = lookup(msgs, "default");
	    if (message == nil)
		message = "";             // Everything has failed.
	}
	return message;
    };


    /*
     * "sformates" list from sound database, where are localized messages, with 
     * optional formating information
     */
    define mysformat (list msg, string lang) ``{

	if (size (msg) == 0) return "";

	integer i = 1;
	term format = ``(sformat (Trans (select (msg, 0), lang)));

	while (i < size (msg)) {
	    format = add (format, select (msg, i));
	    i = i + 1;
	}
	
	return eval (format);
    }


    /*
     * just tests, if the item exists
     * otherwise returns default
     */
    define myselect (list l, integer i, any default) ``{
	if (i < size (l)) return select (l, i);
	return default;
    }



    /* tries to extract list of values from description
     * these value are generated from alsa modules
     * and can be in form
     * [list=value,value,..] or
     * [range=1-19] or something not
     * recognized
     */
    define parse_values (string des) ``{
	list ret = [];
	integer pos = 0;
	integer len = size (des);
	while ((pos < len) && (substring (des, pos, 1) != "[")) {
	    pos = pos + 1;
	}
	pos = pos + 1;
	    
	if (pos < len) {		// found "["
	    if (tolower(substring (des, pos, 5)) == "list=") {
		pos = pos + 5;
		integer s = pos;
		while ((pos < len) && substring (des, pos, 1) != "]") {
		    if (substring (des, pos, 1) == ",") {
			ret = add (ret, hextoi (substring (des, s, pos - s))); 
			s = pos + 1;
		    }
		    pos = pos + 1;
		}
		ret = add (ret, hextoi (substring (des, s, pos - s))); 
	    }
	    else if (tolower(substring (des, pos, 6)) == "range=") {
		pos = pos + 6;
		integer s = pos;
		integer range_start = 0;
		while ((pos < len) && substring (des, pos, 1) != "]") {
		    if (substring (des, pos, 1) == "-") {
			range_start = tointeger(substring (des, s, pos - s));
			s = pos + 1;
		    }
		    pos = pos + 1;
		}
		integer range_stop = tointeger(substring (des, s, pos - s));
				// now create the range list
		while (range_start <= range_stop) {
		    ret = add (ret, range_start);
		    range_start = range_start + 1;
		}
	    }
	    else if (tolower(substring (des, pos, 4)) == "bool") {
		ret = [0, 1];
	    }
	}
	    
	return ret;
    }

    /* 1st: checks if value is type,
     * 2nd: if poss is nonempty, checks if value is one of them
     * returns error message, empty string if ok
     */
    define check_value (string value, string type, list poss) ``{

	if (type == "int") {
	    if (tolower(substring (value, 0, 2)) == "0x") {		// hex number
		string rest = tolower(substring (value, 2));
		if (filterchars(rest, "0123456789abcdef") != rest)
		    // To translators: popup message, wrong value
		    return sformat (UI(_("The value: %1 must be a number")), value);
	    }
	    else {		// decimal number
		string rest = value;
		if (substring (value, 0, 1) == "-")	 // negative number
		    rest = substring (value, 1);
		if (filterchars(rest, "0123456789") != rest)
		    // To translators: popup message, wrong value
		    return sformat (UI(_("The value: %1 must be a number")), value);
	    }
	}
	else if (type == "string") {
	    if (filterchars (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789") != value) {
		    
		integer wrong_pos = findfirstnotof (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789");
		string wrong_char = substring (value, wrong_pos, 1);
		if (wrong_char == " ") {
				// To translators: "space" means blank character
		    wrong_char = wrong_char + " " + UI(_("(space)"));
		}
		// To translators: popup message, wrong value
		return  sformat (UI(_("String cannot contain: %1")), wrong_char);
	    }
	}

				// now check for poss list
	if (size (poss) > 0) {
		
	    list poss_list = [];
		
	    if (type == "int")
		poss_list = maplist (`v, poss, ``(hextoi (value) == v));
	    else
		poss_list = maplist (`v, poss, ``(value == v));
		
	    if (!contains (poss_list, true))
		// To translators: popup message, wrong value
		return sformat (UI(_("The value must be one of %1")), poss);
	}
	    
	return "";		// ok :-)
	    
    }



    define OptionsDialog (list options) ``{
	string help_text = "<p>";
	
					// Help text for options 1/4
	help_text = help_text + UI(_("Here, you can modify the options for the sound modules.\n"));
				// Help text for options 2/4
	help_text = help_text + UI(_("If you are not <b>absolutely sure</b> what you are doing, please leave this dialog untouched."));
	
	help_text = help_text + "</p>";
	
				// Help text for options 3/4
	help_text = help_text + UI (_("<p>Choose the option you want\
 to set, use the <b>Set</b> button to enable new value. You can reset\
 all values by pressing <b>Reset</b>. Numeric values can be entered as\
 decimal or hexadecimal (hexadecimal with a <b>0x</b> prefix).</p>"));
	
	help_text = help_text + "<p>";
	
	term con = `VBox ();
	string language = UI(`GetLanguage());

				// still omit these options -- they are assigned dynamicly
	options = filter (`op, options, ``(lookup (op, "name", "") != "snd_id"));
	options = filter (`op, options, ``(lookup (op, "name", "") != "snd_index"));
	options = maplist (`e, options, ``($["description" : mysformat (lookup (e, "description"), language),
					    "name"         : lookup (e, "name", _("No name available")),
					    "value"        : lookup (e, "default", lookup (e, "value", "")),
					    "type"         : lookup (e, "type", "string"),
					    "default"      : lookup (e, "default", "")]));

	list itemized_descriptions = create_table (options, ["description", "name", "value"]);

	integer current_option = 0;
	string current_option_name = lookup (select (options, 0), "name");

	if (size (itemized_descriptions) > 0) {
	    con = `HBox(
		`HSpacing (3),
		`VBox (
		`VSquash(`Top(`Label (`opt(`outputField), hardware_name (card)))),
		`VSpacing (),
		// To translators: Table headers "description" -- option description, "option" -- option name, "value" -- value of an option
		`Table (`id(`table), `opt (`notify, `immediate), `header(_("Description"), _("Option"),
										       `Right(_("Value"))), itemized_descriptions),
		`VSpacing (0.5),
		`VBox (
		    `TextEntry (`id (`des), current_option_name,
				lookup (select (options, current_option), "value", "")),
		    `VSpacing (0.5),
		    `HBox (
			// "set" button: Sets the option value
			`PushButton (`id (`set), `opt(`default), _("&Set")),
			// "reset" button: Resets all values
			`PushButton (`id (`reset), _("&Reset"))
			)
		    ),
		`VSpacing (0.5)
		),
		`HSpacing (3));
	    
	}
	else {			// there are no options
	    con = `VBox (`Top(`Label (hardware_name (card))),
			 // To translators: label message
			 `HVCenter (`Label (_("There are no options for this module"))));
	    
	}


	    // dialog title
	UI(`SetWizardContents (_("Sound cards"), con, help_text, true, true));
	if (size (itemized_descriptions) > 0) 
	    UI(`ChangeWidget(`id(`table), `CurrentItem, 0));

	any ui = nil;
	
	repeat {

	    ui = UI (`UserInput ());

	    if (ui == `table) {
		current_option = UI (`QueryWidget (`id(`table), `CurrentItem));
		current_option_name = select(UI(`QueryWidget(`id(`table), `Item(current_option))), 2);

		UI(`ChangeWidget(`id(`des), `Label, current_option_name));
		UI(`ChangeWidget(`id(`des), `Value, select(UI(`QueryWidget(`id(`table), `Item(current_option))), 3)));
		
	    }
	    if (ui == `set) {	// set button pressed
		string value = UI(`QueryWidget(`id(`des), `Value));

		if (size (value) == 0) { // we don't care  about empty values
		    UI (`ChangeWidget(`id(`table), `Item(current_option, 2), ""));
		    continue;
		}
		
		list possible_values = parse_values(lookup (select (options, current_option), "values", ""));

		string err = check_value (value,
					  lookup (select (options, current_option), "type", "string"),
					  []); //possible_values);
		
		if (size (err) > 0) { // error - wrong value
		    UI(`DisplayMessage (err));
		    UI(`ChangeWidget(`id(`des), `Value, ""));
					   
		}
		else {		// value is correct
		    UI (`ChangeWidget(`id(`table), `Item(current_option, 2), value));
		    list tmp = [];
		    maplist (`e, itemized_descriptions, ``{
			if (current_option == select(select (e, 0),0))
			    tmp = add (tmp, `item(select (e, 0), select (e, 1), select (e, 2), value));
			else
			    tmp = add (tmp, e);
		    });
		    itemized_descriptions = tmp;
		}
		
	    }
	    else if (ui == `reset) {
		UI(`ChangeWidget(`id(`des), `Value, ""));
		
		integer i = 0;
		while (i < size (itemized_descriptions)) {
		    UI (`ChangeWidget(`id(`table), `Item(i, 2), lookup (select(options, i), "default", "")));
		    i = i + 1;
		}

	    }
	    
	    
	} until (((ui == `back) || (ui == `next) || ui == `cancel));

	
	//UI(`DebugDialog(itemized_descriptions));

	return $["ui" : ui, "return": itemized_descriptions];
    }

// ===== MAIN =====


    map card    = Args(0);
    list params = [];
    if (haskey (card, "params"))
	params = lookup (card, "params", []);
    else
	params = lookup(lookup (card, "module", $[]), "params", []);
    map mod     = lookup (card, "module", $[]);
    map result  = OptionsDialog (params);

    // convert from table entries back to card
    //params = maplist (`e, params, ``(filter (`k, lookup (result, "return", []), ``(select (k, 2) == lookup (e, "name")))));

    params = maplist (`e, params, ``(
	add (e, "value", select (select (filter (`k, lookup (result, "return", []), ``(
	    select (k, 2) == lookup (e, "name"))), 0, []), 3, ""))));

    
    mod = add (mod, "params", params);
    card = add (card, "module", mod);


    return $["ui" : lookup (result, "ui", `cancel), "return" : card];

}
