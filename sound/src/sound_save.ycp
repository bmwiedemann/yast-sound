/**
 * File:
 *   sound_save.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Provides saving /etc/modules.conf and volume for the sound.
 *
 * Authors:
 *   Dan Veselý <dan@suse.cz>
 *
 * $Id$
 *
 *
 * Params:
 *         1st ... map with information to store with these keys:
 *                 "cards"  : <list> // list with all card-dependent information
 *                 "system" : <map> // list with all system dependent information
 *                 "other"  : <term> // function to call to provide some additional work
 *
 *                  each element of cards list will be a map with these keys:
 *
 *                                   "name"    : <string> // card name
 *                                   "modules" : <map>    // map for 'modules.conf' with "alias" and
 *                                                        // "options" keys
 *                                   "volume"  : <map>    // map for storing volume, map keys should be
 *                                                        // channels
 *
 *                  system will be a map with (possible many more) these keys:
 *
 *                                   "modules" : <list> // list of maps for 'modules.conf' - "alias",
 *                                                      // "options"; it's list because more than one entry
 *                                                      // to 'modules.conf' will be needed
 *
 *                                   "volume"  : <map>  // "mixer" ... mixer command to set-up the volume 
 *                                                                     (must include $CHANNEL and $VOLUME substrings, i.e:
 *                                                                      "/usr/bin/amixer set \"$CHANNEL\" $VOLUME% unmute")
 *                                                      // "store" ... function to call to store the info.
 *                                   "rc"      : <map>  // map with rc.config entries (i.e. START_ALSA, START_ALSA_SEQ entry etc ...)
 *                 
 *
 *        2nd ... boolean - testmode
 *
 * Steps:
 *        1. save '/etc/modules/conf'
 *        2. save '/etc/rc.config'
 *        3. save volume
 *        4. call function to provide some additional work
 *
 * Return boolean true on success, false if failed
 */

{

    textdomain "sound";

    /**
     * Saves one '/etc/modules.conf' entry
     * @param entry_name name of modules.conf entry
     * @param entry map with "alias" and "options"
     * @return boolean result of the write
     */
    define SaveOneModulesEntry (string entry_name, map entry) ``{
	boolean ret = true;
	
	if (haskey (entry, "alias")) {
	    ret = ret && SCR(`Write(.modules.alias, entry_name, lookup(entry, "alias")));

	    if (haskey (entry, "options"))
		ret = ret && SCR(`Write(.modules.options, lookup(entry, "options"), entry_name));
	}
	return ret;
    }

    /**
     * Saves all '/etc/modules.conf' entries
     * @param cards list of cards with modules.conf info
     * @param system list with system dependent (i.e. ALSA) modules
     * @return boolean success
     */
    define SaveModulesEntry (list cards, list system) ``{

	if ((contains(maplist (`e, cards, ``(SaveOneModulesEntry (lookup (e, "name", ""), lookup (e, "modules", $[])))), false))) {
				// Error message
	    err_msg = err_msg + UI(_("Error while saving '/etc/modules.conf'.\n"));
	    return false;
	}

	if (size (cards) > 0)
	    SCR(`Write(.modules.alias.comment, "\n#\n# YaST2: sound cards support\n#\n", lookup (lookup (select (cards, 0), "modules", $[]), "alias")));

	if ((contains(maplist (`e, system, ``(SaveOneModulesEntry (lookup (e, "name", ""), lookup (e, "modules", $[])))), false))) {
				// Error message	    
	    err_msg = err_msg + UI(_("Error while saving '/etc/modules.conf'.\n"));
	    return false;
	}

	if (size (system) > 0)
	    SCR(`Write(.modules.alias.comment, "\n#\n# YaST2: sound system dependent part\n#\n", 
		       lookup (lookup (select (system, 0), "modules", $[]), "alias")));

	if (!SCR(`Write(.modules, nil))) {
				// Error message
	    err_msg = err_msg + UI(_("Error while saving '/etc/modules.conf'.\n"));
	    return false;
	}
	
	return true;
    }


    /**
     * Sets volume for all channels
     * @param cards list of cards to set the volume of
     * @param command command that is used for settting up the volume
     * @return boolean success
     */
    define SetAllChannels (list cards, string command) ``{
	if (contains (maplist (`e, cards, ``(maplist(`ch, `v, lookup (e, "volume", $[]), ``(SetVolume (command, ch, v, 
		       tointeger(lookup(lookup(lookup (e, "modules", $[]), "options", $[]), "snd_index", 0))))))), false)) {
				// Error message
	    err_msg = err_msg + UI(_("Error while setting volume.\n"));
	    return false;
	}
	return true;
    }

    /**
     * Save volume (for alsa it's alsactl store)
     * @param function function name to call
     * @param mixer_command command user for volume setting
     * @param cards list of cards to set the volume of
     * @return integer shell return value
     */
    define SaveVolume (string function, string mixer_command, list cards) ``{
	
	SetAllChannels (cards, mixer_command);

	return SCR(`Execute(.target.bash, function, $[]));
    }

    /**
     * Additional hack to enable ALSA joystick support
     * @return integer shell return value
     */
    define EnableJoystick () ``{
	string tmpdir = SCR(`Read(.target.tmpdir));
	return SCR(`Execute(.target.bash, "/usr/sbin/alsactl -f "+tmpdir+"/asound.conf store;\
	    /usr/bin/sed '/\"Joystick\"/s/false/true/' "+tmpdir+"/asound.conf >/etc/asound.conf;\
	    /bin/rm -f "+tmpdir+"/asound.conf;\
            /usr/sbin/alsactl restore", $[]));
	
    }
	
    /**
     * function to finish ALSA instalation
     * @return void
     */
    define AlsaFinish () ``{

	EnableJoystick ();
    }


    /**
     * Saves rc.config values
     * @param rc map with variables
     * @return void
     */
    define SaveRCValues (map rc) ``{
	
	if (contains (maplist (`k, `v, rc, ``(SCR(`Write(topath(sformat(".rc.system.%1", k)), v)))), false) ||
	    !SCR(`Write(.rc.system, nil)))
				// Error message
	    err_msg = err_msg + UI (sformat (_("Error while saving file: %1 \n"), "/etc/rc.config"));

    }


    // ==== MAIN ====

    boolean test_mode = false;
    map sound_info = Args (0);
    string helptext = "";
    string err_msg = "";

    
    if (size (Args ()) > 1)
	test_mode = Args (1);

				// label message
    term con = `Label(_("Saving ..."));
    				// dialog title
    UI(`SetWizardContents (_("Sound configuration"), con, helptext, false, false));

    // Step ONE: save '/etc/modules.conf'
    if (!test_mode)
	SaveModulesEntry (lookup (sound_info, "cards", []), lookup (lookup (sound_info, "system", $[]), "modules", []));

    string mixer_command = lookup (lookup (lookup (sound_info, "system", $[]), "volume", $[]), "mixer", "");
    string function      = lookup (lookup (lookup (sound_info, "system", $[]), "volume", $[]), "store", "");

    // Step TWO: save '/etc.rc.config'
    if (!test_mode && size(lookup(lookup (sound_info, "system", $[]), "rc", $[])) > 0)
	SaveRCValues (lookup(lookup (sound_info, "system", $[]), "rc", $[]));

    // Step THREE: save volume
    if (!test_mode && (size (function) > 0) && (size (mixer_command) > 0))
	SaveVolume (function, mixer_command, lookup (sound_info, "cards", []));


    // Step FOUR: call "other" function to handle some additional workaround
    if (!test_mode)
	eval (lookup (sound_info, "other"));

    // Finally let's display message

    string final_msg = "";
    if (size (err_msg) > 0)
				// Error popup message	
	final_msg = sformat (UI(_("These errors occurred during saving configuration:\n%1")), err_msg);
    else {	
					// final success message
	final_msg = UI(_("The sound card was successfully configured.\nYou can now use it immediately."));
	if (size(filter (`e, lookup (sound_info, "cards", []), ``((size (e) > 0) && (lookup (e, "name") != "off")))) == 0)
					// final success message	    
	    final_msg = UI (_("The sound configuration was saved."));

    }

    if (test_mode)
	// message displayed just in the test mode
	final_msg = final_msg + " " + UI(_("(TEST MODE)"));
    
    UI(`DisplayMessage (final_msg));

    return (size (err_msg) == 0);
}
