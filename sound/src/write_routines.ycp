/**
 *
 * $Id$
 *
 * File:
 *   write_routines.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   API for writings sound configuration
 *
 * Authors:
 *   Dan Veselý <dan@suse.cz>
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 *
 */

{
    textdomain "sound";

    include "sound/routines.ycp";

    /**
     * create special comment for given model
     * @param model card description
     * @param uniq_key unique key
     * @return string comment for the alias
     */

    global define string createAliasComment(string model, string uniq_key) ``{
	string comment = "# " + uniq_key + ":" + model + "\n";
	return comment;
    }

    /**
     * Saves one '/etc/modules.conf' entry
     * @param entry card config
     * @param tmp save to temporary file, not to /etc/modules.conf
     * @return boolean success/failure
     */
    global define boolean SaveOneModulesEntry (map entry, boolean tmp) ``{
	path mod		= .modules;
        path mod_alias		= .modules.alias;
        path mod_options	= .modules.options;
        path mod_alias_comment	= .modules.alias.comment;
        if (tmp)
        {
            mod			= .tmp.modules;
            mod_alias		= .tmp.modules.alias;
            mod_options		= .tmp.modules.options;
            mod_alias_comment	= .tmp.modules.alias.comment;
        }
        boolean ret = true;
        if (haskey (entry, "alias"))
            {
                ret = ret && SCR::Write(mod_alias, lookup(entry, "module", "off"),
		    lookup(entry, "alias", "off"));
		string comment = createAliasComment(lookup(entry, "model", ""), lookup(entry, "unique_key", ""));
		// comment="# "+lookup(entry, "unique_key", "")+":"+lookup(entry, "model", "")+"\n";
		ret = ret && SCR::Write(mod_alias_comment, comment, lookup(entry, "alias", "off"));
            }
        return ret;
    }

    /**
     * saves modules options. this function has to collect parameters that use
     * different cards that use single module and create a coma separated list of values
     * @param save_info save info
     * @param tmp write to tmp modules.conf, not to /etc/modules.conf
     * @return void
     */

    global define void SaveModulesOptions(list save_info, boolean tmp)
    ``{
	path mod_options = .modules.options;
	if (tmp)
	{
	    mod_options = .tmp.modules.options;
	}

	// create distinct list of all modules
	list mods = toset(maplist(`e, save_info, ``(lookup(e, "module", "off"))));
	foreach(`modname, mods,
	``{
	    map res = Sound::CollectOptions(modname);

	    SCR::Write(mod_options, res, modname);
	});
    }

    /**
     * removeOldAliases
     * @param als list with old aliases
     *
     */

    global define void removeOldEntries(list als) ``{
	maplist(`e, als,
	``{
	    if (is_snd_alias(e) ||
		issubstring(e, "sound-service-") ||
		issubstring(e, "sound-slot-"))
		{
		    SCR::Write(mod_alias, nil, e);
		}
	});

    }

    /**
     * Saves all '/etc/modules.conf' entries
     * @param save_info cards save info
     * @param system sytem dependent part
     * @param tmp write to /tmp/modules.conf (not to /etc/modules.conf)
     * @return map return struct: $["return": boolean, "err_msg": string]
     */
    global define map SaveModulesEntry (list save_info, list system, boolean tmp) ``{
	path mod		= .modules;
	path mod_alias		= .modules.alias;
	path mod_options	= .modules.options;
	path mod_alias_comment	= .modules.alias.comment;
	if (tmp)
	{
	    mod=.tmp.modules;
	    mod_alias=.tmp.modules.alias;
	    mod_options=.tmp.modules.options;
	    mod_alias_comment=.tmp.modules.alias.comment;
	}
	SaveModulesOptions(save_info, tmp);

	list als=[];

        string err_msg = "";
	if (contains(SCR::Dir(mod), "alias"))
	{
	    als = SCR::Read(mod_alias);
	}
	// remove old entries

	removeOldEntries(als);

	SCR::Write(mod_alias, "off", "char-major-14");
	SCR::Write(mod_alias, "off", "char-major-116");

	if (size(save_info) >0)
	{
	    if (Sound::use_alsa)
	    {
		SCR::Write(mod_alias, "snd", "char-major-116");
		SCR::Write(mod_alias_comment, "\n# Alsa sound support. \n# Warning: please don't modify comments over "+
		    "aliases 'snd-card-#'", "char-major-116");
		SCR::Write(mod_options, $["snd_cards_limit": sformat ("%1", size(save_info)),
					     "snd_major":"116"], "snd");
		SCR::Write(mod_alias, "off", "char-major-14");
	    }
	    else
	    {
		if (Arch::sparc)
		{
		    string modname = lookup(select(save_info, 0, $[]), "module", "off");
		    SCR::Write(mod_alias, "sound-slot-0", "sound");
		}
		SCR::Write(mod_alias, "sound", "char-major-14");
	    }
	}

        if ((contains(maplist (`e, save_info,
		``(SaveOneModulesEntry (e, tmp))), false)))
        {
            // Error message
            err_msg = err_msg + lookup(STRINGS, "SaveModuleEntry", "");
            return $["return": false, "err_msg": err_msg];
        }
	if (size(save_info) > 0 && Sound::use_alsa)
	{

	    list oss_aliases = alsa_oss(size(save_info));
	    foreach(`e, oss_aliases,
	    ``{
		SCR::Write(mod_alias, lookup(e, "module", ""), lookup(e, "alias", ""));
	    });
	    SCR::Write(mod_alias_comment, "\n\n\n# YaST2: sound system dependent part\n#\n", "sound-slot-0");
	}
	SCR::Write(mod, nil);
        return $["return" : true, "err_msg" : ""];
    }

    /**
     * Save volume (for alsa it's alsactl store
     * @return boolean success/failure
     */
    global define boolean SaveVolume () ``{
	return SCR::Execute(.audio.alsa.store, 0, 0);
    }

    /**
     * saves rc values that are stored in map
     * @param rc map "variable" : "value", ....
     * @return string error string
     */

    global define string SaveRCValues (map rc) ``{
	SCR::Write(.sysconfig.sound.LOAD_SEQUENCER, lookup(rc, "LOAD_ALSA_SEQ", "no"));
	return "";
    }


}
